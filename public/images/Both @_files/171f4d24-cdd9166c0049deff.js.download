(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[34701],{593539:function(t,tt){/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
 * @license
 */!function(t){"use strict";let e=class e{constructor(){e.constructor_.apply(this,arguments)}static equalsWithTolerance(t,tt,ta){return Math.abs(t-tt)<=ta}getClass(){return e}get interfaces_(){return[]}};function n(t){this.message=t}function s(t,tt){this.low=0|tt,this.high=0|t}function i(){}function r(){}function o(){}function l(){}function a(){}function c(t){this.name="RuntimeException",this.message=t,this.stack=Error().stack,Error.call(this,t)}e.constructor_=function(){},s.toBinaryString=function(t){let tt,ta="";for(tt=2147483648;tt>0;tt>>>=1)ta+=(t.high&tt)===tt?"1":"0";for(tt=2147483648;tt>0;tt>>>=1)ta+=(t.low&tt)===tt?"1":"0";return ta},i.isNaN=t=>Number.isNaN(t),i.isInfinite=t=>!Number.isFinite(t),i.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){let t=new Float64Array(1),tt=new Int32Array(t.buffer);i.doubleToLongBits=function(ta){t[0]=ta;let th=0|tt[0],tu=0|tt[1];return 2146435072==(2146435072&tu)&&0!=(1048575&tu)&&0!==th&&(th=0,tu=2146959360),new s(tu,th)},i.longBitsToDouble=function(ta){return tt[0]=ta.low,tt[1]=ta.high,t[0]}}():function(){let t=Math.log2,tt=Math.floor,ta=Math.pow,th=function(){for(let th=53;th>0;th--){let tu=ta(2,th)-1;if(tt(t(tu))+1===th)return tu}return 0}();i.doubleToLongBits=function(tu){let tc,tg,t_,td,tp,tf,tm,ty,tx;if(tu<0||1/tu===Number.NEGATIVE_INFINITY?(tf=-2147483648,tu=-tu):tf=0,0===tu)return new s(ty=tf,tx=0);if(tu===1/0)return new s(ty=2146435072|tf,tx=0);if(tu!=tu)return new s(ty=2146959360,tx=0);if(td=0,tx=0,(tc=tt(tu))>1){if(tc<=th)(td=tt(t(tc)))<=20?(tx=0,ty=tc<<20-td&1048575):(tx=tc%(tg=ta(2,t_=td-20))<<32-t_,ty=tc/tg&1048575);else for(t_=tc,tx=0;0!==(t_=tt(tg=t_/2));)td++,tx>>>=1,tx|=(1&ty)<<31,ty>>>=1,tg!==t_&&(ty|=524288)}if(tm=td+1023,tp=0===tc,tc=tu-tc,td<52&&0!==tc)for(t_=0;;){if((tg=2*tc)>=1?(tc=tg-1,tp?(tm--,tp=!1):(t_<<=1,t_|=1,td++)):(tc=tg,tp?0==--tm&&(td++,tp=!1):(t_<<=1,td++)),20===td)ty|=t_,t_=0;else if(52===td){tx|=t_;break}if(1===tg){td<20?ty|=t_<<20-td:td<52&&(tx|=t_<<52-td);break}}return ty|=tm<<20,new s(ty|=tf,tx)},i.longBitsToDouble=function(t){let tt,th,tu,tc,tg;let t_=t.high,td=t.low;for(tu=-2147483648&t_?-1:1,tc=((2146435072&t_)>>20)-1023,tg=0,th=524288,tt=1;tt<=20;tt++)t_&th&&(tg+=ta(2,-tt)),th>>>=1;for(th=-2147483648,tt=21;tt<=52;tt++)td&th&&(tg+=ta(2,-tt)),th>>>=1;if(-1023===tc){if(0===tg)return 0*tu;tc=-1022}else{if(1024===tc)return 0===tg?tu/0:NaN;tg+=1}return tu*tg*ta(2,tc)}}(),c.prototype=Object.create(Error.prototype),c.prototype.constructor=Error;let h=class h extends c{constructor(){super(),h.constructor_.apply(this,arguments)}getClass(){return h}get interfaces_(){return[]}};h.constructor_=function(){if(0==arguments.length)c.constructor_.call(this);else if(1==arguments.length){let t=arguments[0];c.constructor_.call(this,t)}};let u=class u{constructor(){u.constructor_.apply(this,arguments)}static shouldNeverReachHere(){if(0==arguments.length)u.shouldNeverReachHere(null);else if(1==arguments.length){let t=arguments[0];throw new h("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1==arguments.length){let t=arguments[0];u.isTrue(t,null)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(!t)throw null===tt?new h:new h(tt)}}static equals(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];u.equals(t,tt,null)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(!tt.equals(t))throw new h("Expected "+t+" but encountered "+tt+(null!==ta?": "+ta:""))}}getClass(){return u}get interfaces_(){return[]}};u.constructor_=function(){};let g=class g{constructor(){g.constructor_.apply(this,arguments)}static hashCode(){if(1==arguments.length&&"number"==typeof arguments[0]){let t=arguments[0],tt=i.doubleToLongBits(t);return Math.trunc(tt^tt>>>32)}}setOrdinate(t,tt){switch(t){case g.X:this.x=tt;break;case g.Y:this.y=tt;break;case g.Z:this.z=tt;break;default:throw new n("Invalid ordinate index: "+t)}}equals2D(){if(1==arguments.length){let t=arguments[0];return this.x===t.x&&this.y===t.y}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,tt)&&!!e.equalsWithTolerance(this.y,t.y,tt)}}getOrdinate(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new n("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||i.isNaN(this.z)&&i.isNaN(t.z))}equals(t){return t instanceof g&&this.equals2D(t)}equalInZ(t,tt){return e.equalsWithTolerance(this.z,t.z,tt)}compareTo(t){return this.x<t.x?-1:this.x>t.x?1:this.y<t.y?-1:this.y>t.y?1:0}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return u.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new g(this)}toString(){return"("+this.x+", "+this.y+", "+this.z+")"}distance3D(t){let tt=this.x-t.x,ta=this.y-t.y,th=this.z-t.z;return Math.sqrt(tt*tt+ta*ta+th*th)}distance(t){let tt=this.x-t.x,ta=this.y-t.y;return Math.sqrt(tt*tt+ta*ta)}hashCode(){return 37*(629+g.hashCode(this.x))+g.hashCode(this.y)}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.z}getClass(){return g}get interfaces_(){return[r,o,a]}};let d=class d{constructor(){d.constructor_.apply(this,arguments)}static compare(t,tt){return t<tt?-1:t>tt?1:i.isNaN(t)?i.isNaN(tt)?0:-1:i.isNaN(tt)?1:0}compare(t,tt){let ta=d.compare(t.x,tt.x);if(0!==ta)return ta;let th=d.compare(t.y,tt.y);return 0!==th?th:this._dimensionsToTest<=2?0:d.compare(t.z,tt.z)}getClass(){return d}get interfaces_(){return[l]}};function _(t,tt){return t.interfaces_&&t.interfaces_.indexOf(tt)>-1}function f(){}function p(t){this.message=t||""}function m(){}function y(t){this.message=t||""}function x(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}d.constructor_=function(){if(this._dimensionsToTest=2,0==arguments.length)d.constructor_.call(this,2);else if(1==arguments.length){let t=arguments[0];if(2!==t&&3!==t)throw new n("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}},g.DimensionalComparator=d,g.constructor_=function(){if(this.x=null,this.y=null,this.z=null,0==arguments.length)g.constructor_.call(this,0,0);else if(1==arguments.length){let t=arguments[0];g.constructor_.call(this,t.x,t.y,t.z)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];g.constructor_.call(this,t,tt,g.NULL_ORDINATE)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this.x=t,this.y=tt,this.z=ta}},g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=i.NaN,g.X=0,g.Y=1,g.Z=2,f.prototype.add=function(){},f.prototype.addAll=function(){},f.prototype.isEmpty=function(){},f.prototype.iterator=function(){},f.prototype.size=function(){},f.prototype.toArray=function(){},f.prototype.remove=function(){},p.prototype=Error(),p.prototype.name="IndexOutOfBoundsException",m.prototype=Object.create(f.prototype),m.prototype.constructor=m,m.prototype.get=function(){},m.prototype.set=function(){},m.prototype.isEmpty=function(){},y.prototype=Error(),y.prototype.name="NoSuchElementException",x.prototype=Object.create(m.prototype),x.prototype.constructor=x,x.prototype.ensureCapacity=function(){},x.prototype.interfaces_=[m,f],x.prototype.add=function(t){return 1==arguments.length?this.array_.push(t):this.array_.splice(arguments[0],0,arguments[1]),!0},x.prototype.clear=function(){this.array_=[]},x.prototype.addAll=function(t){for(let tt=t.iterator();tt.hasNext();)this.add(tt.next());return!0},x.prototype.set=function(t,tt){let ta=this.array_[t];return this.array_[t]=tt,ta},x.prototype.iterator=function(){return new E(this)},x.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},x.prototype.isEmpty=function(){return 0===this.array_.length},x.prototype.size=function(){return this.array_.length},x.prototype.toArray=function(){let t=[];for(let tt=0,ta=this.array_.length;tt<ta;tt++)t.push(this.array_[tt]);return t},x.prototype.remove=function(t){let tt=!1;for(let ta=0,th=this.array_.length;ta<th;ta++)if(this.array_[ta]===t){this.array_.splice(ta,1),tt=!0;break}return tt},x.prototype.removeAll=function(t){for(let tt=t.iterator();tt.hasNext();)this.remove(tt.next());return!0};let E=function(t){this.arrayList_=t,this.position_=0};E.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new y;return this.arrayList_.get(this.position_++)},E.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},E.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},E.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))};let I=class I extends x{constructor(){super(),I.constructor_.apply(this,arguments)}getCoordinate(t){return this.get(t)}addAll(){if(2==arguments.length&&"boolean"==typeof arguments[1]&&_(arguments[0],f)){let t=arguments[0],tt=arguments[1],ta=!1;for(let th=t.iterator();th.hasNext();)this.add(th.next(),tt),ta=!0;return ta}return super.addAll.apply(this,arguments)}clone(){let t=super.clone.call(this);for(let tt=0;tt<this.size();tt++)t.add(tt,this.get(tt).clone());return t}toCoordinateArray(){return this.toArray(I.coordArrayType)}add(){if(1==arguments.length){let t=arguments[0];super.add.call(this,t)}else if(2==arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];return this.add(t,tt,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){let t=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(t))return null;super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];return this.add(t,tt),!0}}else if(3==arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];if(arguments[2])for(let ta=0;ta<t.length;ta++)this.add(t[ta],tt);else for(let ta=t.length-1;ta>=0;ta--)this.add(t[ta],tt);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1];if(!arguments[2]){let ta=this.size();if(ta>0&&(t>0&&this.get(t-1).equals2D(tt)||t<ta&&this.get(t).equals2D(tt)))return null}super.add.call(this,t,tt)}}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=1;ta>th&&(tu=-1);for(let tc=ta;tc!==th;tc+=tu)this.add(t[tc],tt);return!0}}closeRing(){this.size()>0&&this.add(new g(this.get(0)),!1)}getClass(){return I}get interfaces_(){return[]}};I.constructor_=function(){if(0==arguments.length);else if(1==arguments.length){let t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.ensureCapacity(t.length),this.add(t,tt)}},I.coordArrayType=[].fill(null);let N=class N{constructor(){N.constructor_.apply(this,arguments)}static intersects(){if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return ta.x>=(t.x<tt.x?t.x:tt.x)&&ta.x<=(t.x>tt.x?t.x:tt.x)&&ta.y>=(t.y<tt.y?t.y:tt.y)&&ta.y<=(t.y>tt.y?t.y:tt.y)}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=Math.min(ta.x,th.x),tc=Math.max(ta.x,th.x),tg=Math.min(t.x,tt.x),t_=Math.max(t.x,tt.x);return!(tg>tc)&&!(t_<tu)&&(tu=Math.min(ta.y,th.y),tc=Math.max(ta.y,th.y),tg=Math.min(t.y,tt.y),t_=Math.max(t.y,tt.y),!(tg>tc)&&!(t_<tu))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){return t instanceof N&&(this.isNull()?t.isNull():this._maxx===t.getMaxX()&&this._maxy===t.getMaxY()&&this._minx===t.getMinX()&&this._miny===t.getMinY())}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new N;let tt=this._minx>t._minx?this._minx:t._minx,ta=this._miny>t._miny?this._miny:t._miny,th=this._maxx<t._maxx?this._maxx:t._maxx,tu=this._maxy<t._maxy?this._maxy:t._maxy;return new N(tt,th,ta,tu)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1==arguments.length){if(arguments[0]instanceof g){let t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof N){let t=arguments[0];return!this.isNull()&&!t.isNull()&&t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];return!this.isNull()&&t>=this._minx&&t<=this._maxx&&tt>=this._miny&&tt<=this._maxy}}intersects(){if(1==arguments.length){if(arguments[0]instanceof N){let t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof g){let t=arguments[0];return this.intersects(t.x,t.y)}}else if(2==arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1];return!this.isNull()&&!((t.x<tt.x?t.x:tt.x)>this._maxx)&&!((t.x>tt.x?t.x:tt.x)<this._minx)&&!((t.y<tt.y?t.y:tt.y)>this._maxy)&&!((t.y>tt.y?t.y:tt.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||tt>this._maxy||tt<this._miny)}}}getMinY(){return this._miny}getMinX(){return this._minx}expandToInclude(){if(1==arguments.length){if(arguments[0]instanceof g){let t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof N){let t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=tt,this._maxy=tt):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),tt<this._miny&&(this._miny=tt),tt>this._maxy&&(this._maxy=tt))}}minExtent(){if(this.isNull())return 0;let t=this.getWidth(),tt=this.getHeight();return t<tt?t:tt}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){return this.isNull()?t.isNull()?0:-1:t.isNull()?1:this._minx<t._minx?-1:this._minx>t._minx?1:this._miny<t._miny?-1:this._miny>t._miny?1:this._maxx<t._maxx?-1:this._maxx>t._maxx?1:this._maxy<t._maxy?-1:this._maxy>t._maxy?1:0}translate(t,tt){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+tt,this.getMaxY()+tt)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;let t=this.getWidth(),tt=this.getHeight();return t>tt?t:tt}expandBy(){if(1==arguments.length){let t=arguments[0];this.expandBy(t,t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=tt,this._maxy+=tt,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1==arguments.length){if(arguments[0]instanceof N){let t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){let t=arguments[0];return this.covers(t)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this.covers(t,tt)}}centre(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0==arguments.length)this.setToNull();else if(1==arguments.length){if(arguments[0]instanceof g){let t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){let t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.init(t.x,tt.x,t.y,tt.y)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];t<tt?(this._minx=t,this._maxx=tt):(this._minx=tt,this._maxx=t),ta<th?(this._miny=ta,this._maxy=th):(this._miny=th,this._maxy=ta)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let tt=0;this._maxx<t._minx?tt=t._minx-this._maxx:this._minx>t._maxx&&(tt=this._minx-t._maxx);let ta=0;return this._maxy<t._miny?ta=t._miny-this._maxy:this._miny>t._maxy&&(ta=this._miny-t._maxy),0===tt?ta:0===ta?tt:Math.sqrt(tt*tt+ta*ta)}hashCode(){return 37*(37*(37*(629+g.hashCode(this._minx))+g.hashCode(this._maxx))+g.hashCode(this._miny))+g.hashCode(this._maxy)}getClass(){return N}get interfaces_(){return[r,a]}};function C(){}N.constructor_=function(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0==arguments.length)this.init();else if(1==arguments.length){if(arguments[0]instanceof g){let t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){let t=arguments[0];this.init(t)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.init(t.x,tt.x,t.y,tt.y)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this.init(t,tt,ta,th)}},N.serialVersionUID=0x51845cd552189800;let S=class S extends C{constructor(){super(),S.constructor_.apply(this,arguments)}getClass(){return S}get interfaces_(){return[]}};function w(t){this.str=t}function L(t){this.value=t}function T(){}S.constructor_=function(){C.constructor_.call(this,"Projective point not representable on the Cartesian plane.")},w.prototype.append=function(t){this.str+=t},w.prototype.setCharAt=function(t,tt){this.str=this.str.substr(0,t)+tt+this.str.substr(t+1)},w.prototype.toString=function(t){return this.str},L.prototype.intValue=function(){return this.value},L.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},L.isNaN=t=>Number.isNaN(t),T.isWhitespace=t=>t<=32&&t>=0||127===t,T.toUpperCase=t=>t.toUpperCase();let R=class R{constructor(){R.constructor_.apply(this,arguments)}static sqr(t){return R.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){let t=arguments[0];return R.parse(t)}if("number"==typeof arguments[0]){let t=arguments[0];return new R(t)}}static sqrt(t){return R.valueOf(t).sqrt()}static parse(t){let tt=0,ta=t.length;for(;T.isWhitespace(t.charAt(tt));)tt++;let th=!1;if(tt<ta){let ta=t.charAt(tt);"-"!==ta&&"+"!==ta||(tt++,"-"===ta&&(th=!0))}let tu=new R,tc=0,tg=0,t_=0;for(;!(tt>=ta);){let ta=t.charAt(tt);if(tt++,T.isDigit(ta)){let t=ta-"0";tu.selfMultiply(R.TEN),tu.selfAdd(t),tc++}else{if("."!==ta){if("e"===ta||"E"===ta){let ta=t.substring(tt);try{t_=L.parseInt(ta)}catch(tt){throw tt instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+ta+" in string "+t):tt}break}throw new NumberFormatException("Unexpected character '"+ta+"' at position "+tt+" in string "+t)}tg=tc}}let td=tu,tp=tc-tg-t_;if(0===tp)td=tu;else if(tp>0){let t=R.TEN.pow(tp);td=tu.divide(t)}else if(tp<0){let t=R.TEN.pow(-tp);td=tu.multiply(t)}return th?td.negate():td}static createNaN(){return new R(i.NaN,i.NaN)}static copy(t){return new R(t)}static magnitude(t){let tt=Math.abs(t),ta=Math.trunc(Math.floor(Math.log(tt)/Math.log(10)));return 10*Math.pow(10,ta)<=tt&&(ta+=1),ta}static stringOfChar(t,tt){let ta=new w;for(let th=0;th<tt;th++)ta.append(t);return ta.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,tt){let ta=this.abs(),th=R.magnitude(ta._hi),tu=R.TEN.pow(th);(ta=ta.divide(tu)).gt(R.TEN)?(ta=ta.divide(R.TEN),th+=1):ta.lt(R.ONE)&&(ta=ta.multiply(R.TEN),th-=1);let tc=th+1,tg=new w,t_=R.MAX_PRINT_DIGITS-1;for(let tt=0;tt<=t_;tt++){t&&tt===tc&&tg.append(".");let th=Math.trunc(ta._hi);if(th<0)break;let tu=!1,td=0;th>9?(tu=!0,td="9"):td="0"+th,tg.append(td),ta=ta.subtract(R.valueOf(th)).multiply(R.TEN),tu&&ta.selfAdd(R.TEN);let tp=!0,tf=R.magnitude(ta._hi);if(tf<0&&Math.abs(tf)>=t_-tt&&(tp=!1),!tp)break}return tt[0]=th,tg.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof R){let t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){let t=arguments[0];return this.add(-t)}}equals(){if(1==arguments.length&&arguments[0]instanceof R){let t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof R){let t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){let t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1==arguments.length){if(arguments[0]instanceof R){let t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){let t=arguments[0];return this.selfDivide(t,0)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=null,th=null,tu=null,tc=null,tg=null,t_=null,td=null,tp=null;return tg=this._hi/t,ta=(t_=R.SPLIT*tg)-tg,tp=R.SPLIT*t,tp=(ta=t_-ta)*(tu=tp-(tu=tp-t))-(td=tg*t)+ta*(tc=t-tu)+(th=tg-ta)*tu+th*tc,tp=tg+(t_=(this._hi-td-tp+this._lo-tg*tt)/t),this._hi=tp,this._lo=tg-tp+t_,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof R){let t=arguments[0],tt=null,ta=null,th=null,tu=null,tc=null,tg=null,t_=null,td=null;return tc=this._hi/t._hi,tt=(tg=R.SPLIT*tc)-tc,td=R.SPLIT*t._hi,ta=tc-(tt=tg-tt),th=td-t._hi,t_=tc*t._hi,td=tt*(th=td-th)-t_+tt*(tu=t._hi-th)+ta*th+ta*tu,tg=(this._hi-t_-td+this._lo-tc*t._lo)/t._hi,new R(td=tc+tg,tc-td+tg)}if("number"==typeof arguments[0]){let t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return R.valueOf(1);let tt=new R(this),ta=R.valueOf(1),th=Math.abs(t);if(th>1)for(;th>0;)th%2==1&&ta.selfMultiply(tt),(th/=2)>0&&(tt=tt.sqr());else ta=tt;return t<0?ta.reciprocal():ta}ceil(){if(this.isNaN())return R.NaN;let t=Math.ceil(this._hi),tt=0;return t===this._hi&&(tt=Math.ceil(this._lo)),new R(t,tt)}compareTo(t){return this._hi<t._hi?-1:this._hi>t._hi?1:this._lo<t._lo?-1:this._lo>t._lo?1:0}rint(){return this.isNaN()?this:this.add(.5).floor()}setValue(){if(arguments[0]instanceof R){let t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){let t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return R.valueOf(0);if(this.isNegative())return R.NaN;let t=1/Math.sqrt(this._hi),tt=this._hi*t,ta=R.valueOf(tt),th=this.subtract(ta.sqr())._hi*(.5*t);return ta.add(th)}selfAdd(){if(1==arguments.length){if(arguments[0]instanceof R){let t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){let t=arguments[0],tt=null,ta=null,th=null,tu=null,tc=null,tg=null;return tu=(th=this._hi+t)-(tc=th-this._hi),ta=(tg=(tu=t-tc+(this._hi-tu))+this._lo)+(th-(tt=th+tg)),this._hi=tt+ta,this._lo=ta+(tt-this._hi),this}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=null,th=null,tu=null,tc=null,tg=null,t_=null,td=null;tc=this._hi+t,th=this._lo+tt,t_=tc-this._hi,td=th-this._lo,tg=tc-t_,tu=th-td,tg=t-t_+(this._hi-tg),tu=tt-td+(this._lo-tu);let tp=(ta=tc+(t_=tg+th))+(t_=tu+(t_+(tc-ta))),tf=t_+(ta-tp);return this._hi=tp,this._lo=tf,this}}selfMultiply(){if(1==arguments.length){if(arguments[0]instanceof R){let t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){let t=arguments[0];return this.selfMultiply(t,0)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=null,th=null,tu=null,tc=null,tg=null,t_=null;ta=(tg=R.SPLIT*this._hi)-this._hi,t_=R.SPLIT*t,ta=tg-ta,th=this._hi-ta,tu=t_-t;let td=(tg=this._hi*t)+(t_=ta*(tu=t_-tu)-tg+ta*(tc=t-tu)+th*tu+th*tc+(this._hi*tt+this._lo*t)),tp=t_+(ta=tg-td);return this._hi=td,this._lo=tp,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return R.NaN;let t=Math.floor(this._hi),tt=0;return t===this._hi&&(tt=Math.floor(this._lo)),new R(t,tt)}negate(){return this.isNaN()?this:new R(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof R){let t=arguments[0];return t.isNaN()?R.createNaN():R.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){let t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfMultiply(t,0)}}isNaN(){return i.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){let t=R.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){let t=this.getSpecialNumberString();if(null!==t)return t;let tt=[,].fill(null),ta=this.extractSignificantDigits(!0,tt),th=tt[0]+1,tu=ta;if("."===ta.charAt(0))tu="0"+ta;else if(th<0)tu="0."+R.stringOfChar("0",-th)+ta;else if(-1===ta.indexOf(".")){let t=th-ta.length;tu=ta+R.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+tu:tu}reciprocal(){let t=null,tt=null,ta=null,th=null,tu=null,tc=null,tg=null,t_=null;tt=(tu=1/this._hi)-(t=(tc=R.SPLIT*tu)-(t=tc-tu)),ta=(t_=R.SPLIT*this._hi)-this._hi;let td=tu+(tc=(1-(tg=tu*this._hi)-(t_=t*(ta=t_-ta)-tg+t*(th=this._hi-ta)+tt*ta+tt*th)-tu*this._lo)/this._hi);return new R(td,tu-td+tc)}toSciNotation(){if(this.isZero())return R.SCI_NOT_ZERO;let t=this.getSpecialNumberString();if(null!==t)return t;let tt=[,].fill(null),ta=this.extractSignificantDigits(!1,tt),th=R.SCI_NOT_EXPONENT_CHAR+tt[0];if("0"===ta.charAt(0))throw new IllegalStateException("Found leading zero: "+ta);let tu="";ta.length>1&&(tu=ta.substring(1));let tc=ta.charAt(0)+"."+tu;return this.isNegative()?"-"+tc+th:tc+th}abs(){return this.isNaN()?R.NaN:this.isNegative()?this.negate():new R(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof R){let t=arguments[0];return R.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){let t=arguments[0];return R.copy(this).selfAdd(t)}}init(){if(1==arguments.length){if("number"==typeof arguments[0]){let t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof R){let t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._hi=t,this._lo=tt}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?R.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}getClass(){return R}get interfaces_(){return[a,r,o]}};R.constructor_=function(){if(this._hi=0,this._lo=0,0==arguments.length)this.init(0);else if(1==arguments.length){if("number"==typeof arguments[0]){let t=arguments[0];this.init(t)}else if(arguments[0]instanceof R){let t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){let t=arguments[0];R.constructor_.call(this,R.parse(t))}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.init(t,tt)}},R.PI=new R(3.141592653589793,12246467991473532e-32),R.TWO_PI=new R(6.283185307179586,24492935982947064e-32),R.PI_2=new R(1.5707963267948966,6123233995736766e-32),R.E=new R(2.718281828459045,14456468917292502e-32),R.NaN=new R(i.NaN,i.NaN),R.EPS=123259516440783e-46,R.SPLIT=134217729,R.MAX_PRINT_DIGITS=32,R.TEN=R.valueOf(10),R.ONE=R.valueOf(1),R.SCI_NOT_EXPONENT_CHAR="E",R.SCI_NOT_ZERO="0.0E0";let P=class P{constructor(){P.constructor_.apply(this,arguments)}static orientationIndex(t,tt,ta){let th=P.orientationIndexFilter(t,tt,ta);if(th<=1)return th;let tu=R.valueOf(tt.x).selfAdd(-t.x),tc=R.valueOf(tt.y).selfAdd(-t.y),tg=R.valueOf(ta.x).selfAdd(-tt.x),t_=R.valueOf(ta.y).selfAdd(-tt.y);return tu.selfMultiply(t_).selfSubtract(tc.selfMultiply(tg)).signum()}static signOfDet2x2(){if(arguments[3]instanceof R&&arguments[2]instanceof R&&arguments[0]instanceof R&&arguments[1]instanceof R){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];return t.multiply(th).selfSubtract(tt.multiply(ta)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=R.valueOf(t),tc=R.valueOf(tt),tg=R.valueOf(ta),t_=R.valueOf(th);return tu.multiply(t_).selfSubtract(tc.multiply(tg)).signum()}}static intersection(t,tt,ta,th){let tu=R.valueOf(th.y).selfSubtract(ta.y).selfMultiply(R.valueOf(tt.x).selfSubtract(t.x)),tc=R.valueOf(th.x).selfSubtract(ta.x).selfMultiply(R.valueOf(tt.y).selfSubtract(t.y)),tg=tu.subtract(tc),t_=R.valueOf(th.x).selfSubtract(ta.x).selfMultiply(R.valueOf(t.y).selfSubtract(ta.y)),td=R.valueOf(th.y).selfSubtract(ta.y).selfMultiply(R.valueOf(t.x).selfSubtract(ta.x)),tp=t_.subtract(td).selfDivide(tg).doubleValue(),tf=R.valueOf(t.x).selfAdd(R.valueOf(tt.x).selfSubtract(t.x).selfMultiply(tp)).doubleValue(),tm=R.valueOf(tt.x).selfSubtract(t.x).selfMultiply(R.valueOf(t.y).selfSubtract(ta.y)),ty=R.valueOf(tt.y).selfSubtract(t.y).selfMultiply(R.valueOf(t.x).selfSubtract(ta.x)),tx=tm.subtract(ty).selfDivide(tg).doubleValue(),tE=R.valueOf(ta.y).selfAdd(R.valueOf(th.y).selfSubtract(ta.y).selfMultiply(tx)).doubleValue();return new g(tf,tE)}static orientationIndexFilter(t,tt,ta){let th=null,tu=(t.x-ta.x)*(tt.y-ta.y),tc=(t.y-ta.y)*(tt.x-ta.x),tg=tu-tc;if(tu>0){if(tc<=0)return P.signum(tg);th=tu+tc}else{if(!(tu<0)||tc>=0)return P.signum(tg);th=-tu-tc}let t_=P.DP_SAFE_EPSILON*th;return tg>=t_||-tg>=t_?P.signum(tg):2}static signum(t){return t>0?1:t<0?-1:0}getClass(){return P}get interfaces_(){return[]}};P.constructor_=function(){},P.DP_SAFE_EPSILON=1e-15;let v=class v{constructor(){v.constructor_.apply(this,arguments)}static index(t,tt,ta){return P.orientationIndex(t,tt,ta)}static isCCW(t){let tt=t.length-1;if(tt<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let ta=t[0],th=0;for(let tu=1;tu<=tt;tu++){let tt=t[tu];tt.y>ta.y&&(ta=tt,th=tu)}let tu=th;do(tu-=1)<0&&(tu=tt);while(t[tu].equals2D(ta)&&tu!==th);let tc=th;do tc=(tc+1)%tt;while(t[tc].equals2D(ta)&&tc!==th);let tg=t[tu],t_=t[tc];if(tg.equals2D(ta)||t_.equals2D(ta)||tg.equals2D(t_))return!1;let td=v.index(tg,ta,t_);return 0===td?tg.x>t_.x:td>0}getClass(){return v}get interfaces_(){return[]}};function O(){}v.constructor_=function(){},v.CLOCKWISE=-1,v.RIGHT=v.CLOCKWISE,v.COUNTERCLOCKWISE=1,v.LEFT=v.COUNTERCLOCKWISE,v.COLLINEAR=0,v.STRAIGHT=v.COLLINEAR,O.arraycopy=(t,tt,ta,th,tu)=>{let tc=0;for(let tg=tt;tg<tt+tu;tg++)ta[th+tc]=t[tg],tc++},O.getProperty=t=>({"line.separator":"\n"})[t];let b=class b{constructor(){b.constructor_.apply(this,arguments)}static intersection(t,tt,ta,th){let tu=t.y-tt.y,tc=tt.x-t.x,tg=t.x*tt.y-tt.x*t.y,t_=ta.y-th.y,td=th.x-ta.x,tp=ta.x*th.y-th.x*ta.y,tf=tu*td-t_*tc,tm=(tc*tp-td*tg)/tf,ty=(t_*tg-tu*tp)/tf;if(i.isNaN(tm)||i.isInfinite(tm)||i.isNaN(ty)||i.isInfinite(ty))throw new S;return new g(tm,ty)}getY(){let t=this.y/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getX(){let t=this.x/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getCoordinate(){let t=new g;return t.x=this.getX(),t.y=this.getY(),t}getClass(){return b}get interfaces_(){return[]}};b.constructor_=function(){if(this.x=null,this.y=null,this.w=null,0==arguments.length)this.x=0,this.y=0,this.w=1;else if(1==arguments.length){let t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2==arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];this.x=t,this.y=tt,this.w=1}else if(arguments[0]instanceof b&&arguments[1]instanceof b){let t=arguments[0],tt=arguments[1];this.x=t.y*tt.w-tt.y*t.w,this.y=tt.x*t.w-t.x*tt.w,this.w=t.x*tt.y-tt.x*t.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1];this.x=t.y-tt.y,this.y=tt.x-t.x,this.w=t.x*tt.y-tt.x*t.y}}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this.x=t,this.y=tt,this.w=ta}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=t.y-tt.y,tc=tt.x-t.x,tg=t.x*tt.y-tt.x*t.y,t_=ta.y-th.y,td=th.x-ta.x,tp=ta.x*th.y-th.x*ta.y;this.x=tc*tp-td*tg,this.y=t_*tg-tu*tp,this.w=tu*td-t_*tc}};let M=class M{constructor(){M.constructor_.apply(this,arguments)}static log10(t){let tt=Math.log(t);return i.isInfinite(tt)?tt:i.isNaN(tt)?tt:tt/M.LOG_10}static min(t,tt,ta,th){let tu=t;return tt<tu&&(tu=tt),ta<tu&&(tu=ta),th<tu&&(tu=th),tu}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2];return t<tt?tt:t>ta?ta:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1],ta=arguments[2];return t<tt?tt:t>ta?ta:t}}static wrap(t,tt){return t<0?tt- -t%tt:t%tt}static max(){if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=t;return tt>th&&(th=tt),ta>th&&(th=ta),th}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=t;return tt>tu&&(tu=tt),ta>tu&&(tu=ta),th>tu&&(tu=th),tu}}static average(t,tt){return(t+tt)/2}getClass(){return M}get interfaces_(){return[]}};M.constructor_=function(){},M.LOG_10=Math.log(10);let D=class D{constructor(){D.constructor_.apply(this,arguments)}static segmentToSegment(t,tt,ta,th){if(t.equals(tt))return D.pointToSegment(t,ta,th);if(ta.equals(th))return D.pointToSegment(th,t,tt);let tu=!1;if(N.intersects(t,tt,ta,th)){let tc=(tt.x-t.x)*(th.y-ta.y)-(tt.y-t.y)*(th.x-ta.x);if(0===tc)tu=!0;else{let tg=(t.y-ta.y)*(th.x-ta.x)-(t.x-ta.x)*(th.y-ta.y),t_=((t.y-ta.y)*(tt.x-t.x)-(t.x-ta.x)*(tt.y-t.y))/tc,td=tg/tc;(td<0||td>1||t_<0||t_>1)&&(tu=!0)}}else tu=!0;return tu?M.min(D.pointToSegment(t,ta,th),D.pointToSegment(tt,ta,th),D.pointToSegment(ta,t,tt),D.pointToSegment(th,t,tt)):0}static pointToSegment(t,tt,ta){if(tt.x===ta.x&&tt.y===ta.y)return t.distance(tt);let th=(ta.x-tt.x)*(ta.x-tt.x)+(ta.y-tt.y)*(ta.y-tt.y),tu=((t.x-tt.x)*(ta.x-tt.x)+(t.y-tt.y)*(ta.y-tt.y))/th;if(tu<=0)return t.distance(tt);if(tu>=1)return t.distance(ta);let tc=((tt.y-t.y)*(ta.x-tt.x)-(tt.x-t.x)*(ta.y-tt.y))/th;return Math.abs(tc)*Math.sqrt(th)}static pointToLinePerpendicular(t,tt,ta){let th=(ta.x-tt.x)*(ta.x-tt.x)+(ta.y-tt.y)*(ta.y-tt.y),tu=((tt.y-t.y)*(ta.x-tt.x)-(tt.x-t.x)*(ta.y-tt.y))/th;return Math.abs(tu)*Math.sqrt(th)}static pointToSegmentString(t,tt){if(0===tt.length)throw new n("Line array must contain at least one vertex");let ta=t.distance(tt[0]);for(let th=0;th<tt.length-1;th++){let tu=D.pointToSegment(t,tt[th],tt[th+1]);tu<ta&&(ta=tu)}return ta}getClass(){return D}get interfaces_(){return[]}};D.constructor_=function(){};let A=class A{constructor(){A.constructor_.apply(this,arguments)}setOrdinate(t,tt,ta){}size(){}getOrdinate(t,tt){}getCoordinate(){}getCoordinateCopy(t){}getDimension(){}getX(t){}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getClass(){return A}get interfaces_(){return[o]}};A.constructor_=function(){},A.X=0,A.Y=1,A.Z=2,A.M=3;let F=class F{constructor(){F.constructor_.apply(this,arguments)}create(){1==arguments.length&&(arguments[0]instanceof Array||_(arguments[0],A))}getClass(){return F}get interfaces_(){return[]}};F.constructor_=function(){};let G=class G{constructor(){G.constructor_.apply(this,arguments)}filter(t){}getClass(){return G}get interfaces_(){return[]}};G.constructor_=function(){};let q=class q{constructor(){q.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equals(){if(arguments[0]instanceof q){let t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){let t=arguments[0];return t instanceof q&&this.equalsExact(t)}}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(q.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1==arguments.length){let tt=arguments[0];return t=tt,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(tt)}if(2==arguments.length){let tt=arguments[0],ta=arguments[1];return t=tt,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(tt,ta)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION)throw new n("This method does not support GeometryCollection arguments")}equal(t,tt,ta){return 0===ta?t.equals(tt):t.distance(tt)<=ta}norm(){let t=this.copy();return t.normalize(),t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new N(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,tt){let ta=t.iterator(),th=tt.iterator();for(;ta.hasNext()&&th.hasNext();){let t=ta.next(),tt=th.next(),tu=t.compareTo(tt);if(0!==tu)return tu}return ta.hasNext()?1:th.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isGeometryCollectionOrDerived(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===q.TYPECODE_MULTIPOINT||this.getTypeCode()===q.TYPECODE_MULTILINESTRING||this.getTypeCode()===q.TYPECODE_MULTIPOLYGON}get interfaces_(){return[o,r,a]}getClass(){return q}static hasNonEmptyElements(t){for(let tt=0;tt<t.length;tt++)if(!t[tt].isEmpty())return!0;return!1}static hasNullElements(t){for(let tt=0;tt<t.length;tt++)if(null===t[tt])return!0;return!1}};q.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},q.serialVersionUID=0x799ea46522854c00,q.TYPECODE_POINT=0,q.TYPECODE_MULTIPOINT=1,q.TYPECODE_LINESTRING=2,q.TYPECODE_LINEARRING=3,q.TYPECODE_MULTILINESTRING=4,q.TYPECODE_POLYGON=5,q.TYPECODE_MULTIPOLYGON=6,q.TYPECODE_GEOMETRYCOLLECTION=7,q.TYPENAME_POINT="Point",q.TYPENAME_MULTIPOINT="MultiPoint",q.TYPENAME_LINESTRING="LineString",q.TYPENAME_LINEARRING="LinearRing",q.TYPENAME_MULTILINESTRING="MultiLineString",q.TYPENAME_POLYGON="Polygon",q.TYPENAME_MULTIPOLYGON="MultiPolygon",q.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",q.geometryChangedFilter={get interfaces_(){return[G]},filter(t){t.geometryChangedAction()}};let B=class B{constructor(){B.constructor_.apply(this,arguments)}filter(t){}getClass(){return B}get interfaces_(){return[]}};B.constructor_=function(){};let V=class V{constructor(){V.constructor_.apply(this,arguments)}isInBoundary(t){}getClass(){return V}get interfaces_(){return[]}};let z=class z{constructor(){z.constructor_.apply(this,arguments)}isInBoundary(t){return t%2==1}getClass(){return z}get interfaces_(){return[V]}};z.constructor_=function(){};let Y=class Y{constructor(){Y.constructor_.apply(this,arguments)}isInBoundary(t){return t>0}getClass(){return Y}get interfaces_(){return[V]}};Y.constructor_=function(){};let U=class U{constructor(){U.constructor_.apply(this,arguments)}isInBoundary(t){return t>1}getClass(){return U}get interfaces_(){return[V]}};U.constructor_=function(){};let k=class k{constructor(){k.constructor_.apply(this,arguments)}isInBoundary(t){return 1===t}getClass(){return k}get interfaces_(){return[V]}};k.constructor_=function(){},V.Mod2BoundaryNodeRule=z,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=k,V.constructor_=function(){},V.MOD2_BOUNDARY_RULE=new z,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new k,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE;let X=class X{constructor(){X.constructor_.apply(this,arguments)}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,tt){for(let ta=0;ta<t.length;ta++){let th=t[ta];if(0>X.indexOf(th,tt))return th}return null}static scroll(t,tt){let ta=X.indexOf(tt,t);if(ta<0)return null;let th=Array(t.length).fill(null);O.arraycopy(t,ta,th,0,t.length-ta),O.arraycopy(t,0,th,t.length-ta,ta),O.arraycopy(th,0,t,0,t.length)}static equals(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(t===tt)return!0;if(null===t||null===tt||t.length!==tt.length)return!1;for(let ta=0;ta<t.length;ta++)if(!t[ta].equals(tt[ta]))return!1;return!0}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(t===tt)return!0;if(null===t||null===tt||t.length!==tt.length)return!1;for(let th=0;th<t.length;th++)if(0!==ta.compare(t[th],tt[th]))return!1;return!0}}static intersection(t,tt){let ta=new I;for(let th=0;th<t.length;th++)tt.intersects(t[th])&&ta.add(t[th],!0);return ta.toCoordinateArray()}static hasRepeatedPoints(t){for(let tt=1;tt<t.length;tt++)if(t[tt-1].equals(t[tt]))return!0;return!1}static removeRepeatedPoints(t){return X.hasRepeatedPoints(t)?new I(t,!1).toCoordinateArray():t}static reverse(t){let tt=t.length-1,ta=Math.trunc(tt/2);for(let th=0;th<=ta;th++){let ta=t[th];t[th]=t[tt-th],t[tt-th]=ta}}static removeNull(t){let tt=0;for(let ta=0;ta<t.length;ta++)null!==t[ta]&&tt++;let ta=Array(tt).fill(null);if(0===tt)return ta;let th=0;for(let tt=0;tt<t.length;tt++)null!==t[tt]&&(ta[th++]=t[tt]);return ta}static copyDeep(){if(1==arguments.length){let t=arguments[0],tt=Array(t.length).fill(null);for(let ta=0;ta<t.length;ta++)tt[ta]=new g(t[ta]);return tt}if(5==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4];for(let tc=0;tc<tu;tc++)ta[th+tc]=new g(t[tt+tc])}}static isEqualReversed(t,tt){for(let ta=0;ta<t.length;ta++){let th=t[ta],tu=tt[t.length-ta-1];if(0!==th.compareTo(tu))return!1}return!0}static envelope(t){let tt=new N;for(let ta=0;ta<t.length;ta++)tt.expandToInclude(t[ta]);return tt}static toCoordinateArray(t){return t.toArray(X.coordArrayType)}static atLeastNCoordinatesOrNothing(t,tt){return tt.length>=t?tt:[]}static indexOf(t,tt){for(let ta=0;ta<tt.length;ta++)if(t.equals(tt[ta]))return ta;return -1}static increasingDirection(t){for(let tt=0;tt<Math.trunc(t.length/2);tt++){let ta=t.length-1-tt,th=t[tt].compareTo(t[ta]);if(0!==th)return th}return 1}static compare(t,tt){let ta=0;for(;ta<t.length&&ta<tt.length;){let th=t[ta].compareTo(tt[ta]);if(0!==th)return th;ta++}return ta<tt.length?-1:ta<t.length?1:0}static minCoordinate(t){let tt=null;for(let ta=0;ta<t.length;ta++)(null===tt||tt.compareTo(t[ta])>0)&&(tt=t[ta]);return tt}static extract(t,tt,ta){tt=M.clamp(tt,0,t.length);let th=(ta=M.clamp(ta,-1,t.length))-tt+1;ta<0&&(th=0),tt>=t.length&&(th=0),ta<tt&&(th=0);let tu=Array(th).fill(null);if(0===th)return tu;let tc=0;for(let th=tt;th<=ta;th++)tu[tc++]=t[th];return tu}getClass(){return X}get interfaces_(){return[]}};let H=class H{constructor(){H.constructor_.apply(this,arguments)}compare(t,tt){return X.compare(t,tt)}getClass(){return H}get interfaces_(){return[l]}};H.constructor_=function(){};let W=class W{constructor(){W.constructor_.apply(this,arguments)}compare(t,tt){if(t.length<tt.length)return -1;if(t.length>tt.length)return 1;if(0===t.length)return 0;let ta=X.compare(t,tt);return X.isEqualReversed(t,tt)?0:ta}OLDcompare(t,tt){if(t.length<tt.length)return -1;if(t.length>tt.length)return 1;if(0===t.length)return 0;let ta=X.increasingDirection(t),th=X.increasingDirection(tt),tu=ta>0?0:t.length-1,tc=th>0?0:t.length-1;for(let tg=0;tg<t.length;tg++){let tg=t[tu].compareTo(tt[tc]);if(0!==tg)return tg;tu+=ta,tc+=th}return 0}getClass(){return W}get interfaces_(){return[l]}};function j(){}function K(){}function Z(t){this.message=t||""}function Q(){}function J(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}W.constructor_=function(){},X.ForwardComparator=H,X.BidirectionalComparator=W,X.constructor_=function(){},X.coordArrayType=[].fill(null),j.prototype.get=function(){},j.prototype.put=function(){},j.prototype.size=function(){},j.prototype.values=function(){},j.prototype.entrySet=function(){},K.prototype=new j,Z.prototype=Error(),Z.prototype.name="OperationNotSupported",Q.prototype=new f,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(let tt=0,ta=this.array_.length;tt<ta;tt++)if(this.array_[tt]===t)return!0;return!1},J.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(let tt=t.iterator();tt.hasNext();)this.add(tt.next());return!0},J.prototype.remove=function(t){throw new Z},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){let t=[];for(let tt=0,ta=this.array_.length;tt<ta;tt++)t.push(this.array_[tt]);return t},J.prototype.iterator=function(){return new $(this)};let $=function(t){this.hashSet_=t,this.position_=0};function et(t){return null==t?0:t.color}function nt(t){return null==t?null:t.parent}function st(t,tt){null!==t&&(t.color=tt)}function it(t){return null==t?null:t.left}function rt(t){return null==t?null:t.right}function ot(){this.root_=null,this.size_=0}$.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new y;return this.hashSet_.array_[this.position_++]},$.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},$.prototype.remove=function(){throw new Z},ot.prototype=new K,ot.prototype.get=function(t){for(var tt=this.root_;null!==tt;){var ta=t.compareTo(tt.key);if(ta<0)tt=tt.left;else{if(!(ta>0))return tt.value;tt=tt.right}}return null},ot.prototype.put=function(t,tt){if(null===this.root_)return this.root_={key:t,value:tt,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;var ta,th,tu=this.root_;do if(ta=tu,(th=t.compareTo(tu.key))<0)tu=tu.left;else{if(!(th>0)){var tc=tu.value;return tu.value=tt,tc}tu=tu.right}while(null!==tu);var tg={key:t,left:null,right:null,value:tt,parent:ta,color:0,getValue(){return this.value},getKey(){return this.key}};return th<0?ta.left=tg:ta.right=tg,this.fixAfterInsertion(tg),this.size_++,null},ot.prototype.fixAfterInsertion=function(t){let tt;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)nt(t)===it(nt(nt(t)))?1===et(tt=rt(nt(nt(t))))?(st(nt(t),0),st(tt,0),st(nt(nt(t)),1),t=nt(nt(t))):(t===rt(nt(t))&&(t=nt(t),this.rotateLeft(t)),st(nt(t),0),st(nt(nt(t)),1),this.rotateRight(nt(nt(t)))):1===et(tt=it(nt(nt(t))))?(st(nt(t),0),st(tt,0),st(nt(nt(t)),1),t=nt(nt(t))):(t===it(nt(t))&&(t=nt(t),this.rotateRight(t)),st(nt(t),0),st(nt(nt(t)),1),this.rotateLeft(nt(nt(t))));this.root_.color=0},ot.prototype.values=function(){var t=new x,tt=this.getFirstEntry();if(null!==tt)for(t.add(tt.value);null!==(tt=ot.successor(tt));)t.add(tt.value);return t},ot.prototype.entrySet=function(){var t=new J,tt=this.getFirstEntry();if(null!==tt)for(t.add(tt);null!==(tt=ot.successor(tt));)t.add(tt);return t},ot.prototype.rotateLeft=function(t){if(null!=t){var tt=t.right;t.right=tt.left,null!=tt.left&&(tt.left.parent=t),tt.parent=t.parent,null==t.parent?this.root_=tt:t.parent.left===t?t.parent.left=tt:t.parent.right=tt,tt.left=t,t.parent=tt}},ot.prototype.rotateRight=function(t){if(null!=t){var tt=t.left;t.left=tt.right,null!=tt.right&&(tt.right.parent=t),tt.parent=t.parent,null==t.parent?this.root_=tt:t.parent.right===t?t.parent.right=tt:t.parent.left=tt,tt.right=t,t.parent=tt}},ot.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},ot.successor=function(t){let tt;if(null===t)return null;if(null!==t.right){for(tt=t.right;null!==tt.left;)tt=tt.left;return tt}tt=t.parent;for(var ta=t;null!==tt&&ta===tt.right;)ta=tt,tt=tt.parent;return tt},ot.prototype.size=function(){return this.size_},ot.prototype.containsKey=function(t){for(var tt=this.root_;null!==tt;){var ta=t.compareTo(tt.key);if(ta<0)tt=tt.left;else{if(!(ta>0))return!0;tt=tt.right}}return!1};let lt=class lt{constructor(){lt.constructor_.apply(this,arguments)}getClass(){return lt}get interfaces_(){return[]}};function at(){}function ct(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}lt.constructor_=function(){},at.prototype=new Q,ct.prototype=new at,ct.prototype.contains=function(t){for(let tt=0,ta=this.array_.length;tt<ta;tt++)if(0===this.array_[tt].compareTo(t))return!0;return!1},ct.prototype.add=function(t){if(this.contains(t))return!1;for(let tt=0,ta=this.array_.length;tt<ta;tt++)if(1===this.array_[tt].compareTo(t))return this.array_.splice(tt,0,t),!0;return this.array_.push(t),!0},ct.prototype.addAll=function(t){for(let tt=t.iterator();tt.hasNext();)this.add(tt.next());return!0},ct.prototype.remove=function(t){throw new Z},ct.prototype.size=function(){return this.array_.length},ct.prototype.isEmpty=function(){return 0===this.array_.length},ct.prototype.toArray=function(){let t=[];for(let tt=0,ta=this.array_.length;tt<ta;tt++)t.push(this.array_[tt]);return t},ct.prototype.iterator=function(){return new ht(this)};let ht=function(t){this.treeSet_=t,this.position_=0};function ut(){}ht.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new y;return this.treeSet_.array_[this.position_++]},ht.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},ht.prototype.remove=function(){throw new Z},ut.sort=function(){let t,tt,ta,th;let tu=arguments[0];if(1==arguments.length)th=function(t,tt){return t.compareTo(tt)},tu.sort(th);else if(2==arguments.length)ta=arguments[1],th=function(t,tt){return ta.compare(t,tt)},tu.sort(th);else if(3==arguments.length){(tt=tu.slice(arguments[1],arguments[2])).sort();let ta=tu.slice(0,arguments[1]).concat(tt,tu.slice(arguments[2],tu.length));for(tu.splice(0,tu.length),t=0;t<ta.length;t++)tu.push(ta[t])}else if(4==arguments.length){tt=tu.slice(arguments[1],arguments[2]),ta=arguments[3],th=function(t,tt){return ta.compare(t,tt)},tt.sort(th);let tc=tu.slice(0,arguments[1]).concat(tt,tu.slice(arguments[2],tu.length));for(tu.splice(0,tu.length),t=0;t<tc.length;t++)tu.push(tc[t])}},ut.asList=function(t){let tt=new x;for(let ta=0,th=t.length;ta<th;ta++)tt.add(t[ta]);return tt};let gt=class gt{constructor(){gt.constructor_.apply(this,arguments)}static toDimensionSymbol(t){switch(t){case gt.FALSE:return gt.SYM_FALSE;case gt.TRUE:return gt.SYM_TRUE;case gt.DONTCARE:return gt.SYM_DONTCARE;case gt.P:return gt.SYM_P;case gt.L:return gt.SYM_L;case gt.A:return gt.SYM_A}throw new n("Unknown dimension value: "+t)}static toDimensionValue(t){switch(T.toUpperCase(t)){case gt.SYM_FALSE:return gt.FALSE;case gt.SYM_TRUE:return gt.TRUE;case gt.SYM_DONTCARE:return gt.DONTCARE;case gt.SYM_P:return gt.P;case gt.SYM_L:return gt.L;case gt.SYM_A:return gt.A}throw new n("Unknown dimension symbol: "+t)}getClass(){return gt}get interfaces_(){return[]}};gt.constructor_=function(){},gt.P=0,gt.L=1,gt.A=2,gt.FALSE=-1,gt.TRUE=-2,gt.DONTCARE=-3,gt.SYM_FALSE="F",gt.SYM_TRUE="T",gt.SYM_DONTCARE="*",gt.SYM_P="0",gt.SYM_L="1",gt.SYM_A="2";let dt=class dt{constructor(){dt.constructor_.apply(this,arguments)}filter(t){}getClass(){return dt}get interfaces_(){return[]}};dt.constructor_=function(){};let _t=class _t{constructor(){_t.constructor_.apply(this,arguments)}filter(t,tt){}isDone(){}isGeometryChanged(){}getClass(){return _t}get interfaces_(){return[]}};_t.constructor_=function(){};let ft=class ft extends q{constructor(){super(),ft.constructor_.apply(this,arguments)}computeEnvelopeInternal(){let t=new N;for(let tt=0;tt<this._geometries.length;tt++)t.expandToInclude(this._geometries[tt].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){let t=Array(this.getNumPoints()).fill(null),tt=-1;for(let ta=0;ta<this._geometries.length;ta++){let th=this._geometries[ta].getCoordinates();for(let ta=0;ta<th.length;ta++)t[++tt]=th[ta]}return t}getArea(){let t=0;for(let tt=0;tt<this._geometries.length;tt++)t+=this._geometries[tt].getArea();return t}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];if(!this.isEquivalentClass(t)||this._geometries.length!==t._geometries.length)return!1;for(let ta=0;ta<this._geometries.length;ta++)if(!this._geometries[ta].equalsExact(t._geometries[ta],tt))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();ut.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=gt.FALSE;for(let tt=0;tt<this._geometries.length;tt++)t=Math.max(t,this._geometries[tt].getBoundaryDimension());return t}getTypeCode(){return q.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=gt.FALSE;for(let tt=0;tt<this._geometries.length;tt++)t=Math.max(t,this._geometries[tt].getDimension());return t}getLength(){let t=0;for(let tt=0;tt<this._geometries.length;tt++)t+=this._geometries[tt].getLength();return t}getNumPoints(){let t=0;for(let tt=0;tt<this._geometries.length;tt++)t+=this._geometries[tt].getNumPoints();return t}getNumGeometries(){return this._geometries.length}reverse(){let t=this._geometries.length,tt=Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)tt[t]=this._geometries[t].reverse();return this.getFactory().createGeometryCollection(tt)}compareToSameClass(){if(1==arguments.length){let t=arguments[0],tt=new ct(ut.asList(this._geometries)),ta=new ct(ut.asList(t._geometries));return this.compare(tt,ta)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=this.getNumGeometries(),th=t.getNumGeometries(),tu=0;for(;tu<ta&&tu<th;){let ta=this.getGeometryN(tu),th=t.getGeometryN(tu),tc=ta.compareToSameClass(th,tt);if(0!==tc)return tc;tu++}return tu<ta?1:tu<th?-1:0}}apply(){if(_(arguments[0],B)){let t=arguments[0];for(let tt=0;tt<this._geometries.length;tt++)this._geometries[tt].apply(t)}else if(_(arguments[0],_t)){let t=arguments[0];if(0===this._geometries.length)return null;for(let tt=0;tt<this._geometries.length&&(this._geometries[tt].apply(t),!t.isDone());tt++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],dt)){let t=arguments[0];t.filter(this);for(let tt=0;tt<this._geometries.length;tt++)this._geometries[tt].apply(t)}else if(_(arguments[0],G)){let t=arguments[0];t.filter(this);for(let tt=0;tt<this._geometries.length;tt++)this._geometries[tt].apply(t)}}getBoundary(){return this.checkNotGeometryCollection(this),u.shouldNeverReachHere(),null}getGeometryType(){return q.TYPENAME_GEOMETRYCOLLECTION}copy(){let t=Array(this._geometries.length).fill(null);for(let tt=0;tt<t.length;tt++)t[tt]=this._geometries[tt].copy();return new ft(t,this._factory)}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}getClass(){return ft}get interfaces_(){return[]}};ft.constructor_=function(){if(this._geometries=null,0==arguments.length);else if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(q.constructor_.call(this,tt),null===t&&(t=[]),q.hasNullElements(t))throw new n("geometries must not contain null elements");this._geometries=t}},ft.serialVersionUID=-0xb0f8434e07a82800;let pt=class pt extends ft{constructor(){super(),pt.constructor_.apply(this,arguments)}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,tt)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?gt.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return q.TYPECODE_MULTILINESTRING}getDimension(){return 1}reverse(){let t=this._geometries.length,tt=Array(t).fill(null);for(let ta=0;ta<this._geometries.length;ta++)tt[t-1-ta]=this._geometries[ta].reverse();return this.getFactory().createMultiLineString(tt)}getBoundary(){return new mt(this).getBoundary()}getGeometryType(){return q.TYPENAME_MULTILINESTRING}copy(){let t=Array(this._geometries.length).fill(null);for(let tt=0;tt<t.length;tt++)t[tt]=this._geometries[tt].copy();return new pt(t,this._factory)}getClass(){return pt}get interfaces_(){return[lt]}};pt.constructor_=function(){let t=arguments[0],tt=arguments[1];ft.constructor_.call(this,t,tt)},pt.serialVersionUID=0x7155d2ab4afa8000;let mt=class mt{constructor(){mt.constructor_.apply(this,arguments)}static getBoundary(){if(1==arguments.length){let t=arguments[0];return new mt(t).getBoundary()}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new mt(t,tt).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();let tt=this.computeBoundaryCoordinates(t);return 1===tt.length?this._geomFact.createPoint(tt[0]):this._geomFact.createMultiPointFromCoords(tt)}getBoundary(){return this._geom instanceof Rt?this.boundaryLineString(this._geom):this._geom instanceof pt?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){return this._geom.isEmpty()?this.getEmptyMultiPoint():t.isClosed()?this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint():this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){let tt=new x;this._endpointMap=new ot;for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);0!==ta.getNumPoints()&&(this.addEndpoint(ta.getCoordinateN(0)),this.addEndpoint(ta.getCoordinateN(ta.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){let ta=t.next(),th=ta.getValue().count;this._bnRule.isInBoundary(th)&&tt.add(ta.getKey())}return X.toCoordinateArray(tt)}addEndpoint(t){let tt=this._endpointMap.get(t);null===tt&&(tt=new yt,this._endpointMap.put(t,tt)),tt.count++}getClass(){return mt}get interfaces_(){return[]}};mt.constructor_=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1==arguments.length){let t=arguments[0];mt.constructor_.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=tt}};let yt=class yt{constructor(){yt.constructor_.apply(this,arguments)}getClass(){return yt}get interfaces_(){return[]}};yt.constructor_=function(){this.count=null};let xt=class xt{constructor(){xt.constructor_.apply(this,arguments)}static ofLine(t){let tt=t.size();if(tt<=1)return 0;let ta=0,th=new g;t.getCoordinate(0,th);let tu=th.x,tc=th.y;for(let tg=1;tg<tt;tg++){t.getCoordinate(tg,th);let tt=th.x,t_=th.y,td=tt-tu,tp=t_-tc;ta+=Math.sqrt(td*td+tp*tp),tu=tt,tc=t_}return ta}getClass(){return xt}get interfaces_(){return[]}};function Et(){}function It(){}function Nt(){}function Ct(){}function St(){}xt.constructor_=function(){};let wt=class wt{constructor(){wt.constructor_.apply(this,arguments)}static chars(t,tt){let ta=Array(tt).fill(null);for(let th=0;th<tt;th++)ta[th]=t;return new String(ta)}static getStackTrace(){if(1==arguments.length){let t=arguments[0],tt=new Nt,ta=new Et(tt);return t.printStackTrace(ta),tt.toString()}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta="",th=new St(new It(wt.getStackTrace(t)));for(let t=0;t<tt;t++)try{ta+=th.readLine()+wt.NEWLINE}catch(t){if(!(t instanceof Ct))throw t;u.shouldNeverReachHere()}return ta}}static split(t,tt){let ta=tt.length,th=new x,tu=""+t,tc=tu.indexOf(tt);for(;tc>=0;){let t=tu.substring(0,tc);th.add(t),tc=(tu=tu.substring(tc+ta)).indexOf(tt)}tu.length>0&&th.add(tu);let tg=Array(th.size()).fill(null);for(let t=0;t<tg.length;t++)tg[t]=th.get(t);return tg}static toString(){if(1==arguments.length&&"number"==typeof arguments[0]){let t=arguments[0];return wt.SIMPLE_ORDINATE_FORMAT.format(t)}}static spaces(t){return wt.chars(" ",t)}getClass(){return wt}get interfaces_(){return[]}};function Lt(t){this.str=t}wt.constructor_=function(){},wt.NEWLINE=O.getProperty("line.separator"),wt.SIMPLE_ORDINATE_FORMAT=new function(){}("0.#"),Lt.prototype.append=function(t){this.str+=t},Lt.prototype.setCharAt=function(t,tt){this.str=this.str.substr(0,t)+tt+this.str.substr(t+1)},Lt.prototype.toString=function(t){return this.str};let Tt=class Tt{constructor(){Tt.constructor_.apply(this,arguments)}static copyCoord(t,tt,ta,th){let tu=Math.min(t.getDimension(),ta.getDimension());for(let tc=0;tc<tu;tc++)ta.setOrdinate(th,tc,t.getOrdinate(tt,tc))}static isRing(t){let tt=t.size();return 0===tt||!(tt<=3)&&t.getOrdinate(0,A.X)===t.getOrdinate(tt-1,A.X)&&t.getOrdinate(0,A.Y)===t.getOrdinate(tt-1,A.Y)}static isEqual(t,tt){let ta=t.size();if(ta!==tt.size())return!1;let th=Math.min(t.getDimension(),tt.getDimension());for(let tu=0;tu<ta;tu++)for(let ta=0;ta<th;ta++){let th=t.getOrdinate(tu,ta),tc=tt.getOrdinate(tu,ta);if(t.getOrdinate(tu,ta)!==tt.getOrdinate(tu,ta)&&(!i.isNaN(th)||!i.isNaN(tc)))return!1}return!0}static extend(t,tt,ta){let th=t.create(ta,tt.getDimension()),tu=tt.size();if(Tt.copy(tt,0,th,0,tu),tu>0)for(let t=tu;t<ta;t++)Tt.copy(tt,tu-1,th,t,1);return th}static reverse(t){let tt=t.size()-1,ta=Math.trunc(tt/2);for(let th=0;th<=ta;th++)Tt.swap(t,th,tt-th)}static swap(t,tt,ta){if(tt===ta)return null;for(let th=0;th<t.getDimension();th++){let tu=t.getOrdinate(tt,th);t.setOrdinate(tt,th,t.getOrdinate(ta,th)),t.setOrdinate(ta,th,tu)}}static copy(t,tt,ta,th,tu){for(let tc=0;tc<tu;tc++)Tt.copyCoord(t,tt+tc,ta,th+tc)}static toString(){if(1==arguments.length&&_(arguments[0],A)){let t=arguments[0],tt=t.size();if(0===tt)return"()";let ta=t.getDimension(),th=new Lt;th.append("(");for(let tu=0;tu<tt;tu++){tu>0&&th.append(" ");for(let tt=0;tt<ta;tt++)tt>0&&th.append(","),th.append(wt.toString(t.getOrdinate(tu,tt)))}return th.append(")"),th.toString()}}static ensureValidRing(t,tt){let ta=tt.size();return 0===ta?tt:ta<=3?Tt.createClosedRing(t,tt,4):tt.getOrdinate(0,A.X)===tt.getOrdinate(ta-1,A.X)&&tt.getOrdinate(0,A.Y)===tt.getOrdinate(ta-1,A.Y)?tt:Tt.createClosedRing(t,tt,ta+1)}static createClosedRing(t,tt,ta){let th=t.create(ta,tt.getDimension()),tu=tt.size();Tt.copy(tt,0,th,0,tu);for(let t=tu;t<ta;t++)Tt.copy(tt,0,th,t,1);return th}getClass(){return Tt}get interfaces_(){return[]}};Tt.constructor_=function(){};let Rt=class Rt extends q{constructor(){super(),Rt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this.isEmpty()?new N:this._points.expandEnvelope(new N)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];if(!this.isEquivalentClass(t)||this._points.size()!==t._points.size())return!1;for(let ta=0;ta<this._points.size();ta++)if(!this.equal(this._points.getCoordinate(ta),t._points.getCoordinate(ta),tt))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){let tt=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(tt))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(tt))>0){let t=this._points.copy();Tt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?gt.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return q.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return xt.ofLine(this._points)}getNumPoints(){return this._points.size()}reverse(){let t=this._points.copy();return Tt.reverse(t),this.getFactory().createLineString(t)}compareToSameClass(){if(1==arguments.length){let t=arguments[0],tt=0,ta=0;for(;tt<this._points.size()&&ta<t._points.size();){let th=this._points.getCoordinate(tt).compareTo(t._points.getCoordinate(ta));if(0!==th)return th;tt++,ta++}return tt<this._points.size()?1:ta<t._points.size()?-1:0}if(2==arguments.length){let t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(_(arguments[0],B)){let t=arguments[0];for(let tt=0;tt<this._points.size();tt++)t.filter(this._points.getCoordinate(tt))}else if(_(arguments[0],_t)){let t=arguments[0];if(0===this._points.size())return null;for(let tt=0;tt<this._points.size()&&(t.filter(this._points,tt),!t.isDone());tt++);t.isGeometryChanged()&&this.geometryChanged()}else _(arguments[0],dt)?arguments[0].filter(this):_(arguments[0],G)&&arguments[0].filter(this)}getBoundary(){return new mt(this).getBoundary()}isEquivalentClass(t){return t instanceof Rt}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return q.TYPENAME_LINESTRING}copy(){return new Rt(this._points.copy(),this._factory)}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new n("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let tt=0;tt<this._points.size();tt++)if(this._points.getCoordinate(tt).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}getClass(){return Rt}get interfaces_(){return[lt]}};Rt.constructor_=function(){if(this._points=null,0==arguments.length);else if(2==arguments.length){let t=arguments[0],tt=arguments[1];q.constructor_.call(this,tt),this.init(t)}},Rt.serialVersionUID=0x2b2b51ba435c8e00;let Pt=class Pt{constructor(){Pt.constructor_.apply(this,arguments)}getClass(){return Pt}get interfaces_(){return[]}};Pt.constructor_=function(){};let vt=class vt extends q{constructor(){super(),vt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){if(this.isEmpty())return new N;let t=new N;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),tt))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return gt.FALSE}getTypeCode(){return q.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}reverse(){return this.copy()}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1==arguments.length){let t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2==arguments.length){let t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(_(arguments[0],B)){let t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(_(arguments[0],_t)){let t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else _(arguments[0],dt)?arguments[0].filter(this):_(arguments[0],G)&&arguments[0].filter(this)}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_POINT}copy(){return new vt(this._coordinates.copy(),this._factory)}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),u.isTrue(1>=t.size()),this._coordinates=t}isSimple(){return!0}getClass(){return vt}get interfaces_(){return[Pt]}};vt.constructor_=function(){this._coordinates=null;let t=arguments[0],tt=arguments[1];q.constructor_.call(this,tt),this.init(t)},vt.serialVersionUID=0x44077bad161cbc00;let Ot=class Ot{constructor(){Ot.constructor_.apply(this,arguments)}static ofRing(){if(arguments[0]instanceof Array){let t=arguments[0];return Math.abs(Ot.ofRingSigned(t))}if(_(arguments[0],A)){let t=arguments[0];return Math.abs(Ot.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){let t=arguments[0];if(t.length<3)return 0;let tt=0,ta=t[0].x;for(let th=1;th<t.length-1;th++){let tu=t[th].x-ta,tc=t[th+1].y;tt+=tu*(t[th-1].y-tc)}return tt/2}if(_(arguments[0],A)){let t=arguments[0],tt=t.size();if(tt<3)return 0;let ta=new g,th=new g,tu=new g;t.getCoordinate(0,th),t.getCoordinate(1,tu);let tc=th.x;tu.x-=tc;let tg=0;for(let t_=1;t_<tt-1;t_++)ta.y=th.y,th.x=tu.x,th.y=tu.y,t.getCoordinate(t_+1,tu),tu.x-=tc,tg+=th.x*(ta.y-tu.y);return tg/2}}getClass(){return Ot}get interfaces_(){return[]}};Ot.constructor_=function(){};let bt=class bt{constructor(){bt.constructor_.apply(this,arguments)}getClass(){return bt}get interfaces_(){return[]}};bt.constructor_=function(){};let Mt=class Mt extends q{constructor(){super(),Mt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];let t=Array(this.getNumPoints()).fill(null),tt=-1,ta=this._shell.getCoordinates();for(let th=0;th<ta.length;th++)t[++tt]=ta[th];for(let ta=0;ta<this._holes.length;ta++){let th=this._holes[ta].getCoordinates();for(let ta=0;ta<th.length;ta++)t[++tt]=th[ta]}return t}getArea(){let t;t=0+Ot.ofRing(this._shell.getCoordinateSequence());for(let tt=0;tt<this._holes.length;tt++)t-=Ot.ofRing(this._holes[tt].getCoordinateSequence());return t}isRectangle(){if(0!==this.getNumInteriorRing()||null===this._shell||5!==this._shell.getNumPoints())return!1;let t=this._shell.getCoordinateSequence(),tt=this.getEnvelopeInternal();for(let ta=0;ta<5;ta++){let th=t.getX(ta);if(th!==tt.getMinX()&&th!==tt.getMaxX())return!1;let tu=t.getY(ta);if(tu!==tt.getMinY()&&tu!==tt.getMaxY())return!1}let ta=t.getX(0),th=t.getY(0);for(let tt=1;tt<=4;tt++){let tu=t.getX(tt),tc=t.getY(tt);if(tu!==ta==(tc!==th))return!1;ta=tu,th=tc}return!0}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];if(!this.isEquivalentClass(t))return!1;let ta=this._shell,th=t._shell;if(!ta.equalsExact(th,tt)||this._holes.length!==t._holes.length)return!1;for(let ta=0;ta<this._holes.length;ta++)if(!this._holes[ta].equalsExact(t._holes[ta],tt))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0==arguments.length){this.normalize(this._shell,!0);for(let t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);ut.sort(this._holes)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(t.isEmpty())return null;let ta=Array(t.getCoordinates().length-1).fill(null);O.arraycopy(t.getCoordinates(),0,ta,0,ta.length);let th=X.minCoordinate(t.getCoordinates());X.scroll(ta,th),O.arraycopy(ta,0,t.getCoordinates(),0,ta.length),t.getCoordinates()[ta.length]=ta[0],v.isCCW(t.getCoordinates())===tt&&X.reverse(t.getCoordinates())}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t;t=0+this._shell.getLength();for(let tt=0;tt<this._holes.length;tt++)t+=this._holes[tt].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let tt=0;tt<this._holes.length;tt++)t+=this._holes[tt].getNumPoints();return t}reverse(){let t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=Array(this._holes.length).fill(null);for(let tt=0;tt<this._holes.length;tt++)t._holes[tt]=this._holes[tt].copy().reverse();return t}convexHull(){return this.getExteriorRing().convexHull()}compareToSameClass(){if(1==arguments.length){let t=arguments[0],tt=this._shell,ta=t._shell;return tt.compareToSameClass(ta)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=this._shell,th=t._shell,tu=ta.compareToSameClass(th,tt);if(0!==tu)return tu;let tc=this.getNumInteriorRing(),tg=t.getNumInteriorRing(),t_=0;for(;t_<tc&&t_<tg;){let ta=this.getInteriorRingN(t_),th=t.getInteriorRingN(t_),tu=ta.compareToSameClass(th,tt);if(0!==tu)return tu;t_++}return t_<tc?1:t_<tg?-1:0}}apply(){if(_(arguments[0],B)){let t=arguments[0];this._shell.apply(t);for(let tt=0;tt<this._holes.length;tt++)this._holes[tt].apply(t)}else if(_(arguments[0],_t)){let t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let tt=0;tt<this._holes.length&&(this._holes[tt].apply(t),!t.isDone());tt++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],dt))arguments[0].filter(this);else if(_(arguments[0],G)){let t=arguments[0];t.filter(this),this._shell.apply(t);for(let tt=0;tt<this._holes.length;tt++)this._holes[tt].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();let t=Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let tt=0;tt<this._holes.length;tt++)t[tt+1]=this._holes[tt];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return q.TYPENAME_POLYGON}copy(){let t=this._shell.copy(),tt=Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)tt[t]=this._holes[t].copy();return new Mt(t,tt,this._factory)}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}getClass(){return Mt}get interfaces_(){return[bt]}};Mt.constructor_=function(){this._shell=null,this._holes=null;let t=arguments[0],tt=arguments[1],ta=arguments[2];if(q.constructor_.call(this,ta),null===t&&(t=this.getFactory().createLinearRing()),null===tt&&(tt=[]),q.hasNullElements(tt))throw new n("holes must not contain null elements");if(t.isEmpty()&&q.hasNonEmptyElements(tt))throw new n("shell is empty but holes are not");this._shell=t,this._holes=tt},Mt.serialVersionUID=-0xcf80010272368e00;let Dt=class Dt extends ft{constructor(){super(),Dt.constructor_.apply(this,arguments)}isValid(){return!0}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,tt)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1==arguments.length&&Number.isInteger(arguments[0])){let t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return gt.FALSE}getTypeCode(){return q.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_MULTIPOINT}copy(){let t=Array(this._geometries.length).fill(null);for(let tt=0;tt<t.length;tt++)t[tt]=this._geometries[tt].copy();return new Dt(t,this._factory)}getClass(){return Dt}get interfaces_(){return[Pt]}};Dt.constructor_=function(){let t=arguments[0],tt=arguments[1];ft.constructor_.call(this,t,tt)},Dt.serialVersionUID=-0x904e12be9d1f0400;let At=class At extends Rt{constructor(){super(),At.constructor_.apply(this,arguments)}getBoundaryDimension(){return gt.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}getTypeCode(){return q.TYPECODE_LINEARRING}reverse(){let t=this._points.copy();return Tt.reverse(t),this.getFactory().createLinearRing(t)}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new n("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<At.MINIMUM_VALID_SIZE)throw new n("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return q.TYPENAME_LINEARRING}copy(){return new At(this._points.copy(),this._factory)}getClass(){return At}get interfaces_(){return[]}};At.constructor_=function(){if(arguments[0]instanceof Array&&arguments[1]instanceof Wt){let t=arguments[0],tt=arguments[1];At.constructor_.call(this,tt.getCoordinateSequenceFactory().create(t),tt)}else if(_(arguments[0],A)&&arguments[1]instanceof Wt){let t=arguments[0],tt=arguments[1];Rt.constructor_.call(this,t,tt),this.validateConstruction()}},At.MINIMUM_VALID_SIZE=4,At.serialVersionUID=-0xc4dd61d9dc985a00;let Ft=class Ft extends ft{constructor(){super(),Ft.constructor_.apply(this,arguments)}equalsExact(){if(2==arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){let t=arguments[0],tt=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,tt)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_MULTIPOLYGON}getDimension(){return 2}reverse(){let t=this._geometries.length,tt=Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)tt[t]=this._geometries[t].reverse();return this.getFactory().createMultiPolygon(tt)}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();let t=new x;for(let tt=0;tt<this._geometries.length;tt++){let ta=this._geometries[tt].getBoundary();for(let tt=0;tt<ta.getNumGeometries();tt++)t.add(ta.getGeometryN(tt))}let tt=Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(tt))}getGeometryType(){return q.TYPENAME_MULTIPOLYGON}copy(){let t=Array(this._geometries.length).fill(null);for(let tt=0;tt<t.length;tt++)t[tt]=this._geometries[tt].copy();return new Ft(t,this._factory)}getClass(){return Ft}get interfaces_(){return[bt]}};Ft.constructor_=function(){let t=arguments[0],tt=arguments[1];ft.constructor_.call(this,t,tt)},Ft.serialVersionUID=-551033529766975900;let Gt=class Gt{constructor(){Gt.constructor_.apply(this,arguments)}setCopyUserData(t){this._isUserDataCopied=t}edit(t,tt){if(null===t)return null;let ta=this.editInternal(t,tt);return this._isUserDataCopied&&ta.setUserData(t.getUserData()),ta}editInternal(t,tt){return null===this._factory&&(this._factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,tt):t instanceof Mt?this.editPolygon(t,tt):t instanceof vt?tt.edit(t,this._factory):t instanceof Rt?tt.edit(t,this._factory):(u.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)}editGeometryCollection(t,tt){let ta=tt.edit(t,this._factory),th=new x;for(let t=0;t<ta.getNumGeometries();t++){let tu=this.edit(ta.getGeometryN(t),tt);null===tu||tu.isEmpty()||th.add(tu)}return ta.getClass()===Dt?this._factory.createMultiPoint(th.toArray([])):ta.getClass()===pt?this._factory.createMultiLineString(th.toArray([])):ta.getClass()===Ft?this._factory.createMultiPolygon(th.toArray([])):this._factory.createGeometryCollection(th.toArray([]))}editPolygon(t,tt){let ta=tt.edit(t,this._factory);if(null===ta&&(ta=this._factory.createPolygon()),ta.isEmpty())return ta;let th=this.edit(ta.getExteriorRing(),tt);if(null===th||th.isEmpty())return this._factory.createPolygon();let tu=new x;for(let t=0;t<ta.getNumInteriorRing();t++){let th=this.edit(ta.getInteriorRingN(t),tt);null===th||th.isEmpty()||tu.add(th)}return this._factory.createPolygon(th,tu.toArray([]))}getClass(){return Gt}get interfaces_(){return[]}};function qt(){}Gt.GeometryEditorOperation=qt;let Bt=class Bt{constructor(){Bt.constructor_.apply(this,arguments)}edit(t,tt){return t}getClass(){return Bt}get interfaces_(){return[qt]}};Bt.constructor_=function(){};let Vt=class Vt{constructor(){Vt.constructor_.apply(this,arguments)}edit(t,tt){let ta=this.edit(t.getCoordinates(),t);return t instanceof At?null===ta?tt.createLinearRing():tt.createLinearRing(ta):t instanceof Rt?null===ta?tt.createLineString():tt.createLineString(ta):t instanceof vt?null===ta||0===ta.length?tt.createPoint():tt.createPoint(ta[0]):t}getClass(){return Vt}get interfaces_(){return[qt]}};Vt.constructor_=function(){};let zt=class zt{constructor(){zt.constructor_.apply(this,arguments)}edit(t,tt){return t instanceof At?tt.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Rt?tt.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof vt?tt.createPoint(this.edit(t.getCoordinateSequence(),t)):t}getClass(){return zt}get interfaces_(){return[qt]}};zt.constructor_=function(){},Gt.NoOpGeometryOperation=Bt,Gt.CoordinateOperation=Vt,Gt.CoordinateSequenceOperation=zt,Gt.constructor_=function(){if(this._factory=null,this._isUserDataCopied=!1,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this._factory=t}};let Yt=class Yt{constructor(){Yt.constructor_.apply(this,arguments)}setOrdinate(t,tt,ta){switch(tt){case A.X:this._coordinates[t].x=ta;break;case A.Y:this._coordinates[t].y=ta;break;case A.Z:this._coordinates[t].z=ta;break;default:throw new n("invalid ordinateIndex")}}size(){return this._coordinates.length}getOrdinate(t,tt){switch(tt){case A.X:return this._coordinates[t].x;case A.Y:return this._coordinates[t].y;case A.Z:return this._coordinates[t].z}return i.NaN}getCoordinate(){if(1==arguments.length){let t=arguments[0];return this._coordinates[t]}if(2==arguments.length){let t=arguments[0],tt=arguments[1];tt.x=this._coordinates[t].x,tt.y=this._coordinates[t].y,tt.z=this._coordinates[t].z}}getCoordinateCopy(t){return new g(this._coordinates[t])}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}expandEnvelope(t){for(let tt=0;tt<this._coordinates.length;tt++)t.expandToInclude(this._coordinates[tt]);return t}copy(){let t=Array(this.size()).fill(null);for(let tt=0;tt<this._coordinates.length;tt++)t[tt]=this._coordinates[tt].copy();return new Yt(t,this._dimension)}toString(){if(this._coordinates.length>0){let t=new Lt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let tt=1;tt<this._coordinates.length;tt++)t.append(", "),t.append(this._coordinates[tt]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getClass(){return Yt}get interfaces_(){return[A,a]}};Yt.constructor_=function(){if(this._dimension=3,this._coordinates=null,1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];Yt.constructor_.call(this,t,3)}else if(Number.isInteger(arguments[0])){let t=arguments[0];this._coordinates=Array(t).fill(null);for(let tt=0;tt<t;tt++)this._coordinates[tt]=new g}else if(_(arguments[0],A)){let t=arguments[0];if(null===t)return this._coordinates=[].fill(null),null;this._dimension=t.getDimension(),this._coordinates=Array(t.size()).fill(null);for(let tt=0;tt<this._coordinates.length;tt++)this._coordinates[tt]=t.getCoordinateCopy(tt)}}else if(2==arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1];this._coordinates=t,this._dimension=tt,null===t&&(this._coordinates=[].fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1];this._coordinates=Array(t).fill(null),this._dimension=tt;for(let tt=0;tt<t;tt++)this._coordinates[tt]=new g}}},Yt.serialVersionUID=-915438501601840600;let Ut=class Ut{constructor(){Ut.constructor_.apply(this,arguments)}static instance(){return Ut.instanceObject}readResolve(){return Ut.instance()}create(){if(1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];return new Yt(t)}if(_(arguments[0],A)){let t=arguments[0];return new Yt(t)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];return tt>3&&(tt=3),tt<2?new Yt(t):new Yt(t,tt)}}getClass(){return Ut}get interfaces_(){return[F,a]}};function kt(){this.map_=new Map}Ut.constructor_=function(){},Ut.serialVersionUID=-0xc71b60593090d200,Ut.instanceObject=new Ut,kt.prototype=new j,kt.prototype.get=function(t){return this.map_.get(t)||null},kt.prototype.put=function(t,tt){return this.map_.set(t,tt),tt},kt.prototype.values=function(){let t=new x,tt=this.map_.values(),ta=tt.next();for(;!ta.done;)t.add(ta.value),ta=tt.next();return t},kt.prototype.entrySet=function(){let t=new J;return this.map_.entries().forEach(tt=>t.add(tt)),t},kt.prototype.size=function(){return this.map_.size()};let Xt=class Xt{constructor(){Xt.constructor_.apply(this,arguments)}static mostPrecise(t,tt){return t.compareTo(tt)>=0?t:tt}equals(t){return t instanceof Xt&&this._modelType===t._modelType&&this._scale===t._scale}compareTo(t){let tt=this.getMaximumSignificantDigits(),ta=t.getMaximumSignificantDigits();return new L(tt).compareTo(new L(ta))}getScale(){return this._scale}isFloating(){return this._modelType===Xt.FLOATING||this._modelType===Xt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===Xt.FLOATING?t="Floating":this._modelType===Xt.FLOATING_SINGLE?t="Floating-Single":this._modelType===Xt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){let t=arguments[0];return i.isNaN(t)||this._modelType===Xt.FLOATING_SINGLE?t:this._modelType===Xt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof g){let t=arguments[0];if(this._modelType===Xt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===Xt.FLOATING?t=16:this._modelType===Xt.FLOATING_SINGLE?t=6:this._modelType===Xt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getClass(){return Xt}get interfaces_(){return[a,r]}};let Ht=class Ht{constructor(){Ht.constructor_.apply(this,arguments)}readResolve(){return Ht.nameToTypeMap.get(this._name)}toString(){return this._name}getClass(){return Ht}get interfaces_(){return[a]}};Ht.constructor_=function(){this._name=null;let t=arguments[0];this._name=t,Ht.nameToTypeMap.put(t,this)},Ht.serialVersionUID=-552860263173159e4,Ht.nameToTypeMap=new kt,Xt.Type=Ht,Xt.constructor_=function(){if(this._modelType=null,this._scale=null,0==arguments.length)this._modelType=Xt.FLOATING;else if(1==arguments.length){if(arguments[0]instanceof Ht){let t=arguments[0];this._modelType=t,t===Xt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){let t=arguments[0];this._modelType=Xt.FIXED,this.setScale(t)}else if(arguments[0]instanceof Xt){let t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}},Xt.serialVersionUID=0x6bee6404e9a25c00,Xt.FIXED=new Ht("FIXED"),Xt.FLOATING=new Ht("FLOATING"),Xt.FLOATING_SINGLE=new Ht("FLOATING SINGLE"),Xt.maximumPreciseValue=9007199254740992;let Wt=class Wt{constructor(){Wt.constructor_.apply(this,arguments)}static toMultiPolygonArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static toGeometryArray(t){if(null===t)return null;let tt=Array(t.size()).fill(null);return t.toArray(tt)}static getDefaultCoordinateSequenceFactory(){return Ut.instance()}static toMultiLineStringArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static toLineStringArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static toMultiPointArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static toLinearRingArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static toPointArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static toPolygonArray(t){let tt=Array(t.size()).fill(null);return t.toArray(tt)}static createPointFromInternalCoord(t,tt){return tt.getPrecisionModel().makePrecise(t),tt.getFactory().createPoint(t)}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0==arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){let t=arguments[0];return new Rt(t,this)}}}createMultiLineString(){if(0==arguments.length)return new pt(null,this);if(1==arguments.length){let t=arguments[0];return new pt(t,this)}}buildGeometry(t){let tt=null,ta=!1,th=!1;for(let tu=t.iterator();tu.hasNext();){let t=tu.next(),tc=t.getClass();null===tt&&(tt=tc),tc!==tt&&(ta=!0),t instanceof ft&&(th=!0)}if(null===tt)return this.createGeometryCollection();if(ta||th)return this.createGeometryCollection(Wt.toGeometryArray(t));let tu=t.iterator().next();if(t.size()>1){if(tu instanceof Mt)return this.createMultiPolygon(Wt.toPolygonArray(t));if(tu instanceof Rt)return this.createMultiLineString(Wt.toLineStringArray(t));if(tu instanceof vt)return this.createMultiPoint(Wt.toPointArray(t));u.shouldNeverReachHere("Unhandled class: "+tu.getClass().getName())}return tu}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0==arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1==arguments.length){if(arguments[0]instanceof g){let t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(_(arguments[0],A)){let t=arguments[0];return new vt(t,this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0==arguments.length)return this.createPolygon(null,null);if(1==arguments.length){if(_(arguments[0],A)){let t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){let t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof At){let t=arguments[0];return this.createPolygon(t,null)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new Mt(t,tt,this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0==arguments.length)return new ft(null,this);if(1==arguments.length){let t=arguments[0];return new ft(t,this)}}createGeometry(t){return new Gt(this).edit(t,new jt(this._coordinateSequenceFactory))}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0==arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){let t=arguments[0];return new At(t,this)}}}createMultiPolygon(){if(0==arguments.length)return new Ft(null,this);if(1==arguments.length){let t=arguments[0];return new Ft(t,this)}}createMultiPoint(){if(0==arguments.length)return new Dt(null,this);if(1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];return new Dt(t,this)}if(_(arguments[0],A)){let t=arguments[0];if(null===t)return this.createMultiPoint([].fill(null));let tt=Array(t.size()).fill(null);for(let ta=0;ta<t.size();ta++){let th=this.getCoordinateSequenceFactory().create(1,t.getDimension());Tt.copy(t,ta,th,0,1),tt[ta]=this.createPoint(th)}return this.createMultiPoint(tt)}}}getClass(){return Wt}get interfaces_(){return[a]}};let jt=class jt extends Gt.CoordinateSequenceOperation{constructor(){super(),jt.constructor_.apply(this,arguments)}edit(){if(2==arguments.length&&arguments[1]instanceof q&&_(arguments[0],A)){let t=arguments[0];return this.coordinateSequenceFactory.create(t)}return super.edit.apply(this,arguments)}getClass(){return jt}get interfaces_(){return[]}};jt.constructor_=function(){this.coordinateSequenceFactory=null;let t=arguments[0];this.coordinateSequenceFactory=t},Wt.CloneOp=jt,Wt.constructor_=function(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0==arguments.length)Wt.constructor_.call(this,new Xt,0);else if(1==arguments.length){if(_(arguments[0],F)){let t=arguments[0];Wt.constructor_.call(this,new Xt,0,t)}else if(arguments[0]instanceof Xt){let t=arguments[0];Wt.constructor_.call(this,t,0,Wt.getDefaultCoordinateSequenceFactory())}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];Wt.constructor_.call(this,t,tt,Wt.getDefaultCoordinateSequenceFactory())}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=ta,this._SRID=tt}},Wt.serialVersionUID=-0xa158a0dfae114c00;let tt={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};let Zt=class Zt{constructor(t){this.geometryFactory=t||new Wt,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){t=t.replace(/[\n\r]/g," ");var ta,tu,tc,tg=tt.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((tg=tt.emptyTypeStr.exec(t))[2]=void 0),tg&&(tu=tg[1].toLowerCase(),tc=tg[2],th[tu]&&(ta=th[tu].call(this,tc))),void 0===ta)throw Error("Could not parse WKT "+t);return ta}write(t){return this.extractGeometry(t)}extractGeometry(t){var tt=t.getGeometryType().toLowerCase();if(!ta[tt])return null;var th=tt.toUpperCase();return t.isEmpty()?th+" EMPTY":th+"("+ta[tt].call(this,t)+")"}};let ta={coordinate(t){return this.precisionModel.makePrecise(t),t.x+" "+t.y},point(t){return ta.coordinate.call(this,t._coordinates._coordinates[0])},multipoint(t){var tt=[];for(let th=0,tu=t._geometries.length;th<tu;++th)tt.push("("+ta.point.call(this,t._geometries[th])+")");return tt.join(",")},linestring(t){var tt=[];for(let th=0,tu=t._points._coordinates.length;th<tu;++th)tt.push(ta.coordinate.call(this,t._points._coordinates[th]));return tt.join(",")},linearring(t){var tt=[];for(let th=0,tu=t._points._coordinates.length;th<tu;++th)tt.push(ta.coordinate.call(this,t._points._coordinates[th]));return tt.join(",")},multilinestring(t){var tt=[];for(let th=0,tu=t._geometries.length;th<tu;++th)tt.push("("+ta.linestring.call(this,t._geometries[th])+")");return tt.join(",")},polygon(t){var tt=[];tt.push("("+ta.linestring.call(this,t._shell)+")");for(let th=0,tu=t._holes.length;th<tu;++th)tt.push("("+ta.linestring.call(this,t._holes[th])+")");return tt.join(",")},multipolygon(t){var tt=[];for(let th=0,tu=t._geometries.length;th<tu;++th)tt.push("("+ta.polygon.call(this,t._geometries[th])+")");return tt.join(",")},geometrycollection(t){var tt=[];for(let ta=0,th=t._geometries.length;ta<th;++ta)tt.push(this.extractGeometry(t._geometries[ta]));return tt.join(",")}},th={coord(t){var ta=t.trim().split(tt.spaces),th=new g(Number.parseFloat(ta[0]),Number.parseFloat(ta[1]));return this.precisionModel.makePrecise(th),th},point(t){return void 0===t?this.geometryFactory.createPoint():this.geometryFactory.createPoint(th.coord.call(this,t))},multipoint(t){if(void 0===t)return this.geometryFactory.createMultiPoint();var ta,tu=t.trim().split(","),tc=[];for(let t=0,tg=tu.length;t<tg;++t)ta=tu[t].replace(tt.trimParens,"$1"),tc.push(th.point.call(this,ta));return this.geometryFactory.createMultiPoint(tc)},linestring(t){if(void 0===t)return this.geometryFactory.createLineString();var tt=t.trim().split(","),ta=[];for(let t=0,tu=tt.length;t<tu;++t)ta.push(th.coord.call(this,tt[t]));return this.geometryFactory.createLineString(ta)},linearring(t){if(void 0===t)return this.geometryFactory.createLinearRing();var tt=t.trim().split(","),ta=[];for(let t=0,tu=tt.length;t<tu;++t)ta.push(th.coord.call(this,tt[t]));return this.geometryFactory.createLinearRing(ta)},multilinestring(t){if(void 0===t)return this.geometryFactory.createMultiLineString();var ta,tu=t.trim().split(tt.parenComma),tc=[];for(let t=0,tg=tu.length;t<tg;++t)ta=tu[t].replace(tt.trimParens,"$1"),tc.push(th.linestring.call(this,ta));return this.geometryFactory.createMultiLineString(tc)},polygon(t){if(void 0===t)return this.geometryFactory.createPolygon();var ta,tu,tc,tg,t_=t.trim().split(tt.parenComma),td=[];for(let t=0,tp=t_.length;t<tp;++t)ta=t_[t].replace(tt.trimParens,"$1"),tu=th.linestring.call(this,ta),tc=this.geometryFactory.createLinearRing(tu._points),0===t?tg=tc:td.push(tc);return this.geometryFactory.createPolygon(tg,td)},multipolygon(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();var ta,tu=t.trim().split(tt.doubleParenComma),tc=[];for(let t=0,tg=tu.length;t<tg;++t)ta=tu[t].replace(tt.trimParens,"$1"),tc.push(th.polygon.call(this,ta));return this.geometryFactory.createMultiPolygon(tc)},geometrycollection(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();var tt=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),ta=[];for(let t=0,th=tt.length;t<th;++t)ta.push(this.read(tt[t]));return this.geometryFactory.createGeometryCollection(ta)}};let $t=class $t{constructor(t){this.parser=new Zt(t)}write(t){return this.parser.write(t)}static toLineString(t,tt){if(2!=arguments.length)throw Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+tt.x+" "+tt.y+" )"}};let te=class te{constructor(){te.constructor_.apply(this,arguments)}static computeEdgeDistance(t,tt,ta){let th=Math.abs(ta.x-tt.x),tu=Math.abs(ta.y-tt.y),tc=-1;if(t.equals(tt))tc=0;else if(t.equals(ta))tc=th>tu?th:tu;else{let ta=Math.abs(t.x-tt.x),tg=Math.abs(t.y-tt.y);0!==(tc=th>tu?ta:tg)||t.equals(tt)||(tc=Math.max(ta,tg))}return u.isTrue(!(0===tc&&!t.equals(tt)),"Bad distance calculation"),tc}static nonRobustComputeEdgeDistance(t,tt,ta){let th=t.x-tt.x,tu=t.y-tt.y,tc=Math.sqrt(th*th+tu*tu);return u.isTrue(!(0===tc&&!t.equals(tt)),"Invalid distance calculation"),tc}getIndexAlongSegment(t,tt){return this.computeIntLineIndex(),this._intLineIndex[t][tt]}getTopologySummary(){let t=new Lt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,tt,ta,th){this._inputLines[0][0]=t,this._inputLines[0][1]=tt,this._inputLines[1][0]=ta,this._inputLines[1][1]=th,this._result=this.computeIntersect(t,tt,ta,th)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0==arguments.length)null===this._intLineIndex&&(this._intLineIndex=[,,].fill().map(()=>[,,]),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1==arguments.length){let t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0==arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1==arguments.length){let t=arguments[0];for(let tt=0;tt<this._result;tt++)if(!this._intPt[tt].equals2D(this._inputLines[t][0])&&!this._intPt[tt].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==te.NO_INTERSECTION}getEdgeDistance(t,tt){return te.computeEdgeDistance(this._intPt[tt],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===te.COLLINEAR_INTERSECTION}toString(){return $t.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+$t.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,tt){return this._inputLines[t][tt]}isIntersection(t){for(let tt=0;tt<this._result;tt++)if(this._intPt[tt].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,tt){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][tt]]}getClass(){return te}get interfaces_(){return[]}};te.constructor_=function(){this._result=null,this._inputLines=[,,].fill().map(()=>[,,]),this._intPt=[,,].fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new g,this._intPt[1]=new g,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},te.DONT_INTERSECT=0,te.DO_INTERSECT=1,te.COLLINEAR=2,te.NO_INTERSECTION=0,te.POINT_INTERSECTION=1,te.COLLINEAR_INTERSECTION=2;let ee=class ee extends te{constructor(){super(),ee.constructor_.apply(this,arguments)}static nearestEndpoint(t,tt,ta,th){let tu=t,tc=D.pointToSegment(t,ta,th),tg=D.pointToSegment(tt,ta,th);return tg<tc&&(tc=tg,tu=tt),(tg=D.pointToSegment(ta,t,tt))<tc&&(tc=tg,tu=ta),(tg=D.pointToSegment(th,t,tt))<tc&&(tc=tg,tu=th),tu}isInSegmentEnvelopes(t){let tt=new N(this._inputLines[0][0],this._inputLines[0][1]),ta=new N(this._inputLines[1][0],this._inputLines[1][1]);return tt.contains(t)&&ta.contains(t)}computeIntersection(){if(3!=arguments.length)return super.computeIntersection.apply(this,arguments);{let t=arguments[0],tt=arguments[1],ta=arguments[2];if(this._isProper=!1,N.intersects(tt,ta,t)&&0===v.index(tt,ta,t)&&0===v.index(ta,tt,t))return this._isProper=!0,(t.equals(tt)||t.equals(ta))&&(this._isProper=!1),this._result=te.POINT_INTERSECTION,null;this._result=te.NO_INTERSECTION}}normalizeToMinimum(t,tt,ta,th,tu){tu.x=this.smallestInAbsValue(t.x,tt.x,ta.x,th.x),tu.y=this.smallestInAbsValue(t.y,tt.y,ta.y,th.y),t.x-=tu.x,t.y-=tu.y,tt.x-=tu.x,tt.y-=tu.y,ta.x-=tu.x,ta.y-=tu.y,th.x-=tu.x,th.y-=tu.y}safeHCoordinateIntersection(t,tt,ta,th){let tu=null;try{tu=b.intersection(t,tt,ta,th)}catch(tc){if(!(tc instanceof S))throw tc;tu=ee.nearestEndpoint(t,tt,ta,th)}return tu}intersection(t,tt,ta,th){let tu=this.intersectionWithNormalization(t,tt,ta,th);return this.isInSegmentEnvelopes(tu)||(tu=new g(ee.nearestEndpoint(t,tt,ta,th))),null!==this._precisionModel&&this._precisionModel.makePrecise(tu),tu}smallestInAbsValue(t,tt,ta,th){let tu=t,tc=Math.abs(tu);return Math.abs(tt)<tc&&(tu=tt,tc=Math.abs(tt)),Math.abs(ta)<tc&&(tu=ta,tc=Math.abs(ta)),Math.abs(th)<tc&&(tu=th),tu}checkDD(t,tt,ta,th,tu){let tc=P.intersection(t,tt,ta,th),tg=this.isInSegmentEnvelopes(tc);O.out.println("DD in env = "+tg+"  --------------------- "+tc),tu.distance(tc)>1e-4&&O.out.println("Distance = "+tu.distance(tc))}intersectionWithNormalization(t,tt,ta,th){let tu=new g(t),tc=new g(tt),tg=new g(ta),t_=new g(th),td=new g;this.normalizeToEnvCentre(tu,tc,tg,t_,td);let tp=this.safeHCoordinateIntersection(tu,tc,tg,t_);return tp.x+=td.x,tp.y+=td.y,tp}computeCollinearIntersection(t,tt,ta,th){let tu=N.intersects(t,tt,ta),tc=N.intersects(t,tt,th),tg=N.intersects(ta,th,t),t_=N.intersects(ta,th,tt);return tu&&tc?(this._intPt[0]=ta,this._intPt[1]=th,te.COLLINEAR_INTERSECTION):tg&&t_?(this._intPt[0]=t,this._intPt[1]=tt,te.COLLINEAR_INTERSECTION):tu&&tg?(this._intPt[0]=ta,this._intPt[1]=t,!ta.equals(t)||tc||t_?te.COLLINEAR_INTERSECTION:te.POINT_INTERSECTION):tu&&t_?(this._intPt[0]=ta,this._intPt[1]=tt,!ta.equals(tt)||tc||tg?te.COLLINEAR_INTERSECTION:te.POINT_INTERSECTION):tc&&tg?(this._intPt[0]=th,this._intPt[1]=t,!th.equals(t)||tu||t_?te.COLLINEAR_INTERSECTION:te.POINT_INTERSECTION):tc&&t_?(this._intPt[0]=th,this._intPt[1]=tt,!th.equals(tt)||tu||tg?te.COLLINEAR_INTERSECTION:te.POINT_INTERSECTION):te.NO_INTERSECTION}normalizeToEnvCentre(t,tt,ta,th,tu){let tc=t.x<tt.x?t.x:tt.x,tg=t.y<tt.y?t.y:tt.y,t_=t.x>tt.x?t.x:tt.x,td=t.y>tt.y?t.y:tt.y,tp=ta.x<th.x?ta.x:th.x,tf=ta.y<th.y?ta.y:th.y,tm=ta.x>th.x?ta.x:th.x,ty=ta.y>th.y?ta.y:th.y;tu.x=((tc>tp?tc:tp)+(t_<tm?t_:tm))/2,tu.y=((tg>tf?tg:tf)+(td<ty?td:ty))/2,t.x-=tu.x,t.y-=tu.y,tt.x-=tu.x,tt.y-=tu.y,ta.x-=tu.x,ta.y-=tu.y,th.x-=tu.x,th.y-=tu.y}computeIntersect(t,tt,ta,th){if(this._isProper=!1,!N.intersects(t,tt,ta,th))return te.NO_INTERSECTION;let tu=v.index(t,tt,ta),tc=v.index(t,tt,th);if(tu>0&&tc>0||tu<0&&tc<0)return te.NO_INTERSECTION;let tg=v.index(ta,th,t),t_=v.index(ta,th,tt);return tg>0&&t_>0||tg<0&&t_<0?te.NO_INTERSECTION:0===tu&&0===tc&&0===tg&&0===t_?this.computeCollinearIntersection(t,tt,ta,th):(0===tu||0===tc||0===tg||0===t_?(this._isProper=!1,t.equals2D(ta)||t.equals2D(th)?this._intPt[0]=t:tt.equals2D(ta)||tt.equals2D(th)?this._intPt[0]=tt:0===tu?this._intPt[0]=new g(ta):0===tc?this._intPt[0]=new g(th):0===tg?this._intPt[0]=new g(t):0===t_&&(this._intPt[0]=new g(tt))):(this._isProper=!0,this._intPt[0]=this.intersection(t,tt,ta,th)),te.POINT_INTERSECTION)}getClass(){return ee}get interfaces_(){return[]}};ee.constructor_=function(){};let ne=class ne{constructor(){ne.constructor_.apply(this,arguments)}static midPoint(t,tt){return new g((t.x+tt.x)/2,(t.y+tt.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof ne){let t=arguments[0],tt=v.index(this.p0,this.p1,t.p0),ta=v.index(this.p0,this.p1,t.p1);return tt>=0&&ta>=0?Math.max(tt,ta):tt<=0&&ta<=0?Math.max(tt,ta):0}if(arguments[0]instanceof g){let t=arguments[0];return v.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){return t instanceof ne&&this.p0.equals(t.p0)&&this.p1.equals(t.p1)}intersection(t){let tt=new ee;return tt.computeIntersection(this.p0,this.p1,t.p0,t.p1),tt.hasIntersection()?tt.getIntersection(0):null}project(){if(arguments[0]instanceof g){let t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);let tt=this.projectionFactor(t),ta=new g;return ta.x=this.p0.x+tt*(this.p1.x-this.p0.x),ta.y=this.p0.y+tt*(this.p1.y-this.p0.y),ta}if(arguments[0]instanceof ne){let t=arguments[0],tt=this.projectionFactor(t.p0),ta=this.projectionFactor(t.p1);if(tt>=1&&ta>=1||tt<=0&&ta<=0)return null;let th=this.project(t.p0);tt<0&&(th=this.p0),tt>1&&(th=this.p1);let tu=this.project(t.p1);return ta<0&&(tu=this.p0),ta>1&&(tu=this.p1),new ne(th,tu)}}normalize(){0>this.p1.compareTo(this.p0)&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return D.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return ne.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;let tt=this.p1.x-this.p0.x,ta=this.p1.y-this.p0.y,th=tt*tt+ta*ta;return th<=0?i.NaN:((t.x-this.p0.x)*tt+(t.y-this.p0.y)*ta)/th}closestPoints(t){let tt=this.intersection(t);if(null!==tt)return[tt,tt];let ta=[,,].fill(null),th=i.MAX_VALUE,tu=null,tc=this.closestPoint(t.p0);th=tc.distance(t.p0),ta[0]=tc,ta[1]=t.p0;let tg=this.closestPoint(t.p1);(tu=tg.distance(t.p1))<th&&(th=tu,ta[0]=tg,ta[1]=t.p1);let t_=t.closestPoint(this.p0);(tu=t_.distance(this.p0))<th&&(th=tu,ta[0]=this.p0,ta[1]=t_);let td=t.closestPoint(this.p1);return(tu=td.distance(this.p1))<th&&(th=tu,ta[0]=this.p1,ta[1]=td),ta}closestPoint(t){let tt=this.projectionFactor(t);return tt>0&&tt<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){let tt=this.p0.compareTo(t.p0);return 0!==tt?tt:this.p1.compareTo(t.p1)}reverse(){let t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){try{return b.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof S))throw t}return null}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,tt){let ta=this.p0.x+t*(this.p1.x-this.p0.x),th=this.p0.y+t*(this.p1.y-this.p0.y),tu=this.p1.x-this.p0.x,tc=this.p1.y-this.p0.y,tg=Math.sqrt(tu*tu+tc*tc),t_=0,td=0;if(0!==tt){if(tg<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");t_=tt*tu/tg,td=tt*tc/tg}return new g(ta-td,th+t_)}setCoordinates(){if(1==arguments.length){let t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=tt.x,this.p1.y=tt.y}}segmentFraction(t){let tt=this.projectionFactor(t);return tt<0?tt=0:(tt>1||i.isNaN(tt))&&(tt=1),tt}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}distance(){if(arguments[0]instanceof ne){let t=arguments[0];return D.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){let t=arguments[0];return D.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){let tt=new g;return tt.x=this.p0.x+t*(this.p1.x-this.p0.x),tt.y=this.p0.y+t*(this.p1.y-this.p0.y),tt}hashCode(){let t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);let tt=Math.trunc(t)^Math.trunc(t>>32),ta=java.lang.Double.doubleToLongBits(this.p1.x);return tt^(Math.trunc(ta^=31*java.lang.Double.doubleToLongBits(this.p1.y))^Math.trunc(ta>>32))}getClass(){return ne}get interfaces_(){return[r,a]}};ne.constructor_=function(){if(this.p0=null,this.p1=null,0==arguments.length)ne.constructor_.call(this,new g,new g);else if(1==arguments.length){let t=arguments[0];ne.constructor_.call(this,t.p0,t.p1)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.p0=t,this.p1=tt}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];ne.constructor_.call(this,new g(t,tt),new g(ta,th))}},ne.serialVersionUID=0x2d2172135f411c00;let se=class se{constructor(){se.constructor_.apply(this,arguments)}static toLocationSymbol(t){switch(t){case se.EXTERIOR:return"e";case se.BOUNDARY:return"b";case se.INTERIOR:return"i";case se.NONE:return"-"}throw new n("Unknown location value: "+t)}getClass(){return se}get interfaces_(){return[]}};se.constructor_=function(){},se.INTERIOR=0,se.BOUNDARY=1,se.EXTERIOR=2,se.NONE=-1;let ie=class ie{constructor(){ie.constructor_.apply(this,arguments)}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];return tt===gt.SYM_DONTCARE||tt===gt.SYM_TRUE&&(t>=0||t===gt.TRUE)||tt===gt.SYM_FALSE&&t===gt.FALSE||tt===gt.SYM_P&&t===gt.P||tt===gt.SYM_L&&t===gt.L||tt===gt.SYM_A&&t===gt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];return new ie(t).matches(tt)}}static isTrue(t){return t>=0||t===gt.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])||ie.isTrue(this._matrix[se.INTERIOR][se.BOUNDARY])||ie.isTrue(this._matrix[se.BOUNDARY][se.INTERIOR])||ie.isTrue(this._matrix[se.BOUNDARY][se.BOUNDARY]))&&this._matrix[se.EXTERIOR][se.INTERIOR]===gt.FALSE&&this._matrix[se.EXTERIOR][se.BOUNDARY]===gt.FALSE}isCoveredBy(){return(ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])||ie.isTrue(this._matrix[se.INTERIOR][se.BOUNDARY])||ie.isTrue(this._matrix[se.BOUNDARY][se.INTERIOR])||ie.isTrue(this._matrix[se.BOUNDARY][se.BOUNDARY]))&&this._matrix[se.INTERIOR][se.EXTERIOR]===gt.FALSE&&this._matrix[se.BOUNDARY][se.EXTERIOR]===gt.FALSE}set(){if(1==arguments.length){let t=arguments[0];for(let tt=0;tt<t.length;tt++){let ta=Math.trunc(tt/3),th=tt%3;this._matrix[ta][th]=gt.toDimensionValue(t.charAt(tt))}}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._matrix[t][tt]=ta}}isContains(){return ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])&&this._matrix[se.EXTERIOR][se.INTERIOR]===gt.FALSE&&this._matrix[se.EXTERIOR][se.BOUNDARY]===gt.FALSE}setAtLeast(){if(1==arguments.length){let t=arguments[0];for(let tt=0;tt<t.length;tt++){let ta=Math.trunc(tt/3),th=tt%3;this.setAtLeast(ta,th,gt.toDimensionValue(t.charAt(tt)))}}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._matrix[t][tt]<ta&&(this._matrix[t][tt]=ta)}}setAtLeastIfValid(t,tt,ta){t>=0&&tt>=0&&this.setAtLeast(t,tt,ta)}isWithin(){return ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])&&this._matrix[se.INTERIOR][se.EXTERIOR]===gt.FALSE&&this._matrix[se.BOUNDARY][se.EXTERIOR]===gt.FALSE}isTouches(t,tt){return t>tt?this.isTouches(tt,t):(t===gt.A&&tt===gt.A||t===gt.L&&tt===gt.L||t===gt.L&&tt===gt.A||t===gt.P&&tt===gt.A||t===gt.P&&tt===gt.L)&&this._matrix[se.INTERIOR][se.INTERIOR]===gt.FALSE&&(ie.isTrue(this._matrix[se.INTERIOR][se.BOUNDARY])||ie.isTrue(this._matrix[se.BOUNDARY][se.INTERIOR])||ie.isTrue(this._matrix[se.BOUNDARY][se.BOUNDARY]))}isOverlaps(t,tt){return t===gt.P&&tt===gt.P||t===gt.A&&tt===gt.A?ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])&&ie.isTrue(this._matrix[se.INTERIOR][se.EXTERIOR])&&ie.isTrue(this._matrix[se.EXTERIOR][se.INTERIOR]):t===gt.L&&tt===gt.L&&1===this._matrix[se.INTERIOR][se.INTERIOR]&&ie.isTrue(this._matrix[se.INTERIOR][se.EXTERIOR])&&ie.isTrue(this._matrix[se.EXTERIOR][se.INTERIOR])}isEquals(t,tt){return t===tt&&ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])&&this._matrix[se.INTERIOR][se.EXTERIOR]===gt.FALSE&&this._matrix[se.BOUNDARY][se.EXTERIOR]===gt.FALSE&&this._matrix[se.EXTERIOR][se.INTERIOR]===gt.FALSE&&this._matrix[se.EXTERIOR][se.BOUNDARY]===gt.FALSE}toString(){let t=new Lt("123456789");for(let tt=0;tt<3;tt++)for(let ta=0;ta<3;ta++)t.setCharAt(3*tt+ta,gt.toDimensionSymbol(this._matrix[tt][ta]));return t.toString()}setAll(t){for(let tt=0;tt<3;tt++)for(let ta=0;ta<3;ta++)this._matrix[tt][ta]=t}get(t,tt){return this._matrix[t][tt]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new n("Should be length 9: "+t);for(let tt=0;tt<3;tt++)for(let ta=0;ta<3;ta++)if(!ie.matches(this._matrix[tt][ta],t.charAt(3*tt+ta)))return!1;return!0}add(t){for(let tt=0;tt<3;tt++)for(let ta=0;ta<3;ta++)this.setAtLeast(tt,ta,t.get(tt,ta))}isDisjoint(){return this._matrix[se.INTERIOR][se.INTERIOR]===gt.FALSE&&this._matrix[se.INTERIOR][se.BOUNDARY]===gt.FALSE&&this._matrix[se.BOUNDARY][se.INTERIOR]===gt.FALSE&&this._matrix[se.BOUNDARY][se.BOUNDARY]===gt.FALSE}isCrosses(t,tt){return t===gt.P&&tt===gt.L||t===gt.P&&tt===gt.A||t===gt.L&&tt===gt.A?ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])&&ie.isTrue(this._matrix[se.INTERIOR][se.EXTERIOR]):t===gt.L&&tt===gt.P||t===gt.A&&tt===gt.P||t===gt.A&&tt===gt.L?ie.isTrue(this._matrix[se.INTERIOR][se.INTERIOR])&&ie.isTrue(this._matrix[se.EXTERIOR][se.INTERIOR]):t===gt.L&&tt===gt.L&&0===this._matrix[se.INTERIOR][se.INTERIOR]}getClass(){return ie}get interfaces_(){return[o]}};ie.constructor_=function(){if(this._matrix=null,0==arguments.length)this._matrix=[,,,].fill().map(()=>[,,,]),this.setAll(gt.FALSE);else if(1==arguments.length){if("string"==typeof arguments[0]){let t=arguments[0];ie.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof ie){let t=arguments[0];ie.constructor_.call(this),this._matrix[se.INTERIOR][se.INTERIOR]=t._matrix[se.INTERIOR][se.INTERIOR],this._matrix[se.INTERIOR][se.BOUNDARY]=t._matrix[se.INTERIOR][se.BOUNDARY],this._matrix[se.INTERIOR][se.EXTERIOR]=t._matrix[se.INTERIOR][se.EXTERIOR],this._matrix[se.BOUNDARY][se.INTERIOR]=t._matrix[se.BOUNDARY][se.INTERIOR],this._matrix[se.BOUNDARY][se.BOUNDARY]=t._matrix[se.BOUNDARY][se.BOUNDARY],this._matrix[se.BOUNDARY][se.EXTERIOR]=t._matrix[se.BOUNDARY][se.EXTERIOR],this._matrix[se.EXTERIOR][se.INTERIOR]=t._matrix[se.EXTERIOR][se.INTERIOR],this._matrix[se.EXTERIOR][se.BOUNDARY]=t._matrix[se.EXTERIOR][se.BOUNDARY],this._matrix[se.EXTERIOR][se.EXTERIOR]=t._matrix[se.EXTERIOR][se.EXTERIOR]}}};let re=class re{constructor(){re.constructor_.apply(this,arguments)}static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=re.PI_TIMES_2;for(;t<=-Math.PI;)t+=re.PI_TIMES_2;return t}static angle(){if(1==arguments.length){let t=arguments[0];return Math.atan2(t.y,t.x)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=tt.x-t.x,th=tt.y-t.y;return Math.atan2(th,ta)}}static isAcute(t,tt,ta){let th=t.x-tt.x,tu=t.y-tt.y;return th*(ta.x-tt.x)+tu*(ta.y-tt.y)>0}static isObtuse(t,tt,ta){let th=t.x-tt.x,tu=t.y-tt.y;return th*(ta.x-tt.x)+tu*(ta.y-tt.y)<0}static interiorAngle(t,tt,ta){let th=re.angle(tt,t),tu=re.angle(tt,ta);return Math.abs(tu-th)}static normalizePositive(t){if(t<0){for(;t<0;)t+=re.PI_TIMES_2;t>=re.PI_TIMES_2&&(t=0)}else{for(;t>=re.PI_TIMES_2;)t-=re.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,tt,ta){let th=re.angle(tt,t),tu=re.angle(tt,ta);return re.diff(th,tu)}static diff(t,tt){let ta=null;return(ta=t<tt?tt-t:t-tt)>Math.PI&&(ta=2*Math.PI-ta),ta}static toRadians(t){return t*Math.PI/180}static getTurn(t,tt){let ta=Math.sin(tt-t);return ta>0?re.COUNTERCLOCKWISE:ta<0?re.CLOCKWISE:re.NONE}static angleBetweenOriented(t,tt,ta){let th=re.angle(tt,t),tu=re.angle(tt,ta)-th;return tu<=-Math.PI?tu+re.PI_TIMES_2:tu>Math.PI?tu-re.PI_TIMES_2:tu}getClass(){return re}get interfaces_(){return[]}};re.constructor_=function(){},re.PI_TIMES_2=2*Math.PI,re.PI_OVER_2=Math.PI/2,re.PI_OVER_4=Math.PI/4,re.COUNTERCLOCKWISE=v.COUNTERCLOCKWISE,re.CLOCKWISE=v.CLOCKWISE,re.NONE=v.COLLINEAR;let oe=class oe{constructor(){oe.constructor_.apply(this,arguments)}static area(t,tt,ta){return Math.abs(((ta.x-t.x)*(tt.y-t.y)-(tt.x-t.x)*(ta.y-t.y))/2)}static signedArea(t,tt,ta){return((ta.x-t.x)*(tt.y-t.y)-(tt.x-t.x)*(ta.y-t.y))/2}static det(t,tt,ta,th){return t*th-tt*ta}static interpolateZ(t,tt,ta,th){let tu=tt.x,tc=tt.y,tg=ta.x-tu,t_=th.x-tu,td=ta.y-tc,tp=th.y-tc,tf=tg*tp-t_*td,tm=t.x-tu,ty=t.y-tc;return tt.z+(tp*tm-t_*ty)/tf*(ta.z-tt.z)+(-td*tm+tg*ty)/tf*(th.z-tt.z)}static longestSideLength(t,tt,ta){let th=t.distance(tt),tu=tt.distance(ta),tc=ta.distance(t),tg=th;return tu>tg&&(tg=tu),tc>tg&&(tg=tc),tg}static isAcute(t,tt,ta){return!!re.isAcute(t,tt,ta)&&!!re.isAcute(tt,ta,t)&&!!re.isAcute(ta,t,tt)}static circumcentre(t,tt,ta){let th=ta.x,tu=ta.y,tc=t.x-th,tg=t.y-tu,t_=tt.x-th,td=tt.y-tu,tp=2*oe.det(tc,tg,t_,td),tf=oe.det(tg,tc*tc+tg*tg,td,t_*t_+td*td),tm=oe.det(tc,tc*tc+tg*tg,t_,t_*t_+td*td);return new g(th-tf/tp,tu+tm/tp)}static perpendicularBisector(t,tt){let ta=tt.x-t.x,th=tt.y-t.y,tu=new b(t.x+ta/2,t.y+th/2,1),tc=new b(t.x-th+ta/2,t.y+ta+th/2,1);return new b(tu,tc)}static angleBisector(t,tt,ta){let th=tt.distance(t),tu=th/(th+tt.distance(ta)),tc=ta.x-t.x,tg=ta.y-t.y;return new g(t.x+tu*tc,t.y+tu*tg)}static area3D(t,tt,ta){let th=tt.x-t.x,tu=tt.y-t.y,tc=tt.z-t.z,tg=ta.x-t.x,t_=ta.y-t.y,td=ta.z-t.z,tp=tu*td-tc*t_,tf=tc*tg-th*td,tm=th*t_-tu*tg;return Math.sqrt(tp*tp+tf*tf+tm*tm)/2}static centroid(t,tt,ta){let th=(t.x+tt.x+ta.x)/3,tu=(t.y+tt.y+ta.y)/3;return new g(th,tu)}static inCentre(t,tt,ta){let th=tt.distance(ta),tu=t.distance(ta),tc=t.distance(tt),tg=th+tu+tc,t_=(th*t.x+tu*tt.x+tc*ta.x)/tg,td=(th*t.y+tu*tt.y+tc*ta.y)/tg;return new g(t_,td)}area(){return oe.area(this.p0,this.p1,this.p2)}signedArea(){return oe.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new n("Supplied point is null.");return oe.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return oe.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return oe.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return oe.circumcentre(this.p0,this.p1,this.p2)}area3D(){return oe.area3D(this.p0,this.p1,this.p2)}centroid(){return oe.centroid(this.p0,this.p1,this.p2)}inCentre(){return oe.inCentre(this.p0,this.p1,this.p2)}getClass(){return oe}get interfaces_(){return[]}};oe.constructor_=function(){this.p0=null,this.p1=null,this.p2=null;let t=arguments[0],tt=arguments[1],ta=arguments[2];this.p0=t,this.p1=tt,this.p2=ta};let le=class le extends C{constructor(){super(),le.constructor_.apply(this,arguments)}getClass(){return le}get interfaces_(){return[]}};le.constructor_=function(){if(0==arguments.length)C.constructor_.call(this);else if(1==arguments.length){let t=arguments[0];C.constructor_.call(this,t)}};let ae=class ae{constructor(){ae.constructor_.apply(this,arguments)}static translationInstance(t,tt){let ta=new ae;return ta.setToTranslation(t,tt),ta}static shearInstance(t,tt){let ta=new ae;return ta.setToShear(t,tt),ta}static reflectionInstance(){if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new ae;return ta.setToReflection(t,tt),ta}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=new ae;return tu.setToReflection(t,tt,ta,th),tu}}static rotationInstance(){if(1==arguments.length){let t=arguments[0];return ae.rotationInstance(Math.sin(t),Math.cos(t))}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new ae;return ta.setToRotation(t,tt),ta}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return ae.rotationInstance(Math.sin(t),Math.cos(t),tt,ta)}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=new ae;return tu.setToRotation(t,tt,ta,th),tu}}static scaleInstance(){if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new ae;return ta.setToScale(t,tt),ta}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=new ae;return tu.translate(-ta,-th),tu.scale(t,tt),tu.translate(ta,th),tu}}setToReflectionBasic(t,tt,ta,th){if(t===ta&&tt===th)throw new n("Reflection line points must be distinct");let tu=ta-t,tc=th-tt,tg=Math.sqrt(tu*tu+tc*tc),t_=tc/tg,td=tu/tg,tp=2*t_*td,tf=td*td-t_*t_;return this._m00=tf,this._m01=tp,this._m02=0,this._m10=tp,this._m11=-tf,this._m12=0,this}getInverse(){let t=this.getDeterminant();if(0===t)throw new le("Transformation is non-invertible");let tt=this._m11/t,ta=-this._m10/t,th=-this._m01/t,tu=this._m00/t,tc=(this._m01*this._m12-this._m02*this._m11)/t,tg=(-this._m00*this._m12+this._m10*this._m02)/t;return new ae(tt,th,tc,ta,tu,tg)}compose(t){let tt=t._m00*this._m00+t._m01*this._m10,ta=t._m00*this._m01+t._m01*this._m11,th=t._m00*this._m02+t._m01*this._m12+t._m02,tu=t._m10*this._m00+t._m11*this._m10,tc=t._m10*this._m01+t._m11*this._m11,tg=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=tt,this._m01=ta,this._m02=th,this._m10=tu,this._m11=tc,this._m12=tg,this}equals(t){return null!==t&&t instanceof ae&&this._m00===t._m00&&this._m01===t._m01&&this._m02===t._m02&&this._m10===t._m10&&this._m11===t._m11&&this._m12===t._m12}setToScale(t,tt){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=tt,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,tt){return this.compose(ae.scaleInstance(t,tt)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1==arguments.length){let t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];return this._m00=t,this._m01=tt,this._m02=ta,this._m10=th,this._m11=tu,this._m12=tc,this}}setToRotation(){if(1==arguments.length){let t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this._m00=tt,this._m01=-t,this._m02=0,this._m10=t,this._m11=tt,this._m12=0,this}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),tt,ta),this}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];return this._m00=tt,this._m01=-t,this._m02=ta-ta*tt+th*t,this._m10=t,this._m11=tt,this._m12=th-ta*t-th*tt,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,tt){this.transform(t,tt)}rotate(){if(1==arguments.length){let t=arguments[0];return this.compose(ae.rotationInstance(t)),this}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this.compose(ae.rotationInstance(t,tt)),this}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return this.compose(ae.rotationInstance(t,tt,ta)),this}if(4==arguments.length){let t=arguments[0],tt=arguments[1];return this.compose(ae.rotationInstance(t,tt)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){let tt=this._m00*t._m00+this._m01*t._m10,ta=this._m00*t._m01+this._m01*t._m11,th=this._m00*t._m02+this._m01*t._m12+this._m02,tu=this._m10*t._m00+this._m11*t._m10,tc=this._m10*t._m01+this._m11*t._m11,tg=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=tt,this._m01=ta,this._m02=th,this._m10=tu,this._m11=tc,this._m12=tg,this}setToShear(t,tt){return this._m00=1,this._m01=t,this._m02=0,this._m10=tt,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){return null}translate(t,tt){return this.compose(ae.translationInstance(t,tt)),this}setToReflection(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(0===t&&0===tt)throw new n("Reflection vector must be non-zero");if(t===tt)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;let ta=Math.sqrt(t*t+tt*tt),th=tt/ta,tu=t/ta;return this.rotate(-th,tu),this.scale(1,-1),this.rotate(th,tu),this}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];if(t===ta&&tt===th)throw new n("Reflection line points must be distinct");this.setToTranslation(-t,-tt);let tu=ta-t,tc=th-tt,tg=Math.sqrt(tu*tu+tc*tc),t_=tc/tg,td=tu/tg;return this.rotate(-t_,td),this.scale(1,-1),this.rotate(t_,td),this.translate(t,tt),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,tt){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=tt,this}shear(t,tt){return this.compose(ae.shearInstance(t,tt)),this}transform(){if(1==arguments.length){let t=arguments[0].copy();return t.apply(this),t}if(2==arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=this._m00*t.x+this._m01*t.y+this._m02,th=this._m10*t.x+this._m11*t.y+this._m12;return tt.x=ta,tt.y=th,tt}if(_(arguments[0],A)&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1],ta=this._m00*t.getOrdinate(tt,0)+this._m01*t.getOrdinate(tt,1)+this._m02,th=this._m10*t.getOrdinate(tt,0)+this._m11*t.getOrdinate(tt,1)+this._m12;t.setOrdinate(tt,0,ta),t.setOrdinate(tt,1,th)}}}reflect(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this.compose(ae.reflectionInstance(t,tt)),this}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];return this.compose(ae.reflectionInstance(t,tt,ta,th)),this}}getClass(){return ae}get interfaces_(){return[o,_t]}};ae.constructor_=function(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0==arguments.length)this.setToIdentity();else if(1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof ae){let t=arguments[0];this.setTransformation(t)}}else if(6==arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];this.setTransformation(t,tt,ta,th,tu,tc)}};let ce=class ce{constructor(){ce.constructor_.apply(this,arguments)}static solve(t,tt){let ta=tt.length;if(t.length!==ta||t[0].length!==ta)throw new n("Matrix A is incorrectly sized");for(let th=0;th<ta;th++){let tu=th;for(let tt=th+1;tt<ta;tt++)Math.abs(t[tt][th])>Math.abs(t[tu][th])&&(tu=tt);if(0===t[tu][th])return null;ce.swapRows(t,th,tu),ce.swapRows(tt,th,tu);for(let tu=th+1;tu<ta;tu++){let tc=t[tu][th]/t[th][th];for(let tt=ta-1;tt>=th;tt--)t[tu][tt]-=t[th][tt]*tc;tt[tu]-=tt[th]*tc}}let th=Array(ta).fill(null);for(let tu=ta-1;tu>=0;tu--){let tc=0;for(let tt=tu+1;tt<ta;tt++)tc+=t[tu][tt]*th[tt];th[tu]=(tt[tu]-tc)/t[tu][tu]}return th}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(tt===ta)return null;for(let th=0;th<t[0].length;th++){let tu=t[tt][th];t[tt][th]=t[ta][th],t[ta][th]=tu}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(tt===ta)return null;let th=t[tt];t[tt]=t[ta],t[ta]=th}}getClass(){return ce}get interfaces_(){return[]}};ce.constructor_=function(){};let he=class he{constructor(){he.constructor_.apply(this,arguments)}solve(t){let tt=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return ce.solve(tt,t)}compute(){let t=[this._dest0.x,this._dest1.x,this._dest2.x],tt=this.solve(t);if(null===tt)return!1;this._m00=tt[0],this._m01=tt[1],this._m02=tt[2];let ta=[this._dest0.y,this._dest1.y,this._dest2.y],th=this.solve(ta);return null!==th&&(this._m10=th[0],this._m11=th[1],this._m12=th[2],!0)}getTransformation(){return this.compute()?new ae(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}getClass(){return he}get interfaces_(){return[]}};he.constructor_=function(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];this._src0=t,this._src1=tt,this._src2=ta,this._dest0=th,this._dest1=tu,this._dest2=tc};let ue=class ue{constructor(){ue.constructor_.apply(this,arguments)}static createFromBaseLines(t,tt,ta,th){let tu=new g(t.x+th.x-ta.x,t.y+th.y-ta.y),tc=re.angleBetweenOriented(tt,t,tu),tg=tt.distance(t),t_=th.distance(ta);if(0===tg)return new ae;let td=t_/tg,tp=ae.translationInstance(-t.x,-t.y);return tp.rotate(tc),tp.scale(td,td),tp.translate(ta.x,ta.y),tp}static createFromControlVectors(){if(2==arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=tt.x-t.x,th=tt.y-t.y;return ae.translationInstance(ta,th)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){let t=arguments[0],tt=arguments[1];if(t.length!==tt.length)throw new n("Src and Dest arrays are not the same length");if(t.length<=0)throw new n("Too few control points");if(t.length>3)throw new n("Too many control points");return 1===t.length?ue.createFromControlVectors(t[0],tt[0]):2===t.length?ue.createFromControlVectors(t[0],t[1],tt[0],tt[1]):ue.createFromControlVectors(t[0],t[1],t[2],tt[0],tt[1],tt[2])}}else{if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=new g(th.x-ta.x,th.y-ta.y),tc=re.angleBetweenOriented(tt,t,tu),tg=tt.distance(t),t_=th.distance(ta);if(0===tg)return null;let td=t_/tg,tp=ae.translationInstance(-t.x,-t.y);return tp.rotate(tc),tp.scale(td,td),tp.translate(ta.x,ta.y),tp}if(6==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];return new he(t,tt,ta,th,tu,tc).getTransformation()}}}getClass(){return ue}get interfaces_(){return[]}};ue.constructor_=function(){};let ge=class ge{constructor(){ge.constructor_.apply(this,arguments)}static getCoordinates(t){let tt=new x;return t.apply(new ge(tt)),tt}filter(t){(t instanceof Rt||t instanceof vt)&&this._coords.add(t.getCoordinate())}getClass(){return ge}get interfaces_(){return[G]}};ge.constructor_=function(){this._coords=null;let t=arguments[0];this._coords=t};let de=class de{constructor(){de.constructor_.apply(this,arguments)}static map(t,tt){return new de(tt).map(t)}map(t){let tt=new x;for(let ta=0;ta<t.getNumGeometries();ta++){let th=this._mapOp.map(t.getGeometryN(ta));th.isEmpty()||tt.add(th)}return t.getFactory().createGeometryCollection(Wt.toGeometryArray(tt))}getClass(){return de}get interfaces_(){return[]}};de.constructor_=function(){this._mapOp=null;let t=arguments[0];this._mapOp=t};let _e=class _e{constructor(){_e.constructor_.apply(this,arguments)}static combine(){if(1==arguments.length){let t=arguments[0];return new _e(t).combine()}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new _e(_e.createList(t,tt)).combine()}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return new _e(_e.createList(t,tt,ta)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new x;return ta.add(t),ta.add(tt),ta}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=new x;return th.add(t),th.add(tt),th.add(ta),th}}extractElements(t,tt){if(null===t)return null;for(let ta=0;ta<t.getNumGeometries();ta++){let th=t.getGeometryN(ta);this._skipEmpty&&th.isEmpty()||tt.add(th)}}combine(){let t=new x;for(let tt=this._inputGeoms.iterator();tt.hasNext();){let ta=tt.next();this.extractElements(ta,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}getClass(){return _e}get interfaces_(){return[]}};_e.constructor_=function(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;let t=arguments[0];this._geomFactory=_e.extractFactory(t),this._inputGeoms=t};let fe=class fe{constructor(){fe.constructor_.apply(this,arguments)}static isOfType(t,tt){return t.getGeometryType()===tt||tt===q.TYPENAME_LINESTRING&&t.getGeometryType()===q.TYPENAME_LINEARRING}static extract(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return fe.extract(t,tt,new x)}if(3==arguments.length){if(_(arguments[2],m)&&arguments[0]instanceof q&&"string"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2];return t.getGeometryType()===tt?ta.add(t):t instanceof ft&&t.apply(new fe(tt,ta)),ta}if(_(arguments[2],m)&&arguments[0]instanceof q&&arguments[1]instanceof Class){let t=arguments[0],tt=arguments[1],ta=arguments[2];return fe.extract(t,fe.toGeometryType(tt),ta)}}}filter(t){(null===this._geometryType||fe.isOfType(t,this._geometryType))&&this._comps.add(t)}getClass(){return fe}get interfaces_(){return[dt]}};fe.constructor_=function(){this._geometryType=null,this._comps=null;let t=arguments[0],tt=arguments[1];this._geometryType=t,this._comps=tt};let pe=class pe{constructor(){pe.constructor_.apply(this,arguments)}map(t){}getClass(){return pe}get interfaces_(){return[]}};pe.constructor_=function(){};let me=class me{constructor(){me.constructor_.apply(this,arguments)}static map(){if(arguments[0]instanceof q&&_(arguments[1],pe)){let t=arguments[0],tt=arguments[1],ta=new x;for(let th=0;th<t.getNumGeometries();th++){let tu=tt.map(t.getGeometryN(th));null!==tu&&ta.add(tu)}return t.getFactory().buildGeometry(ta)}if(_(arguments[0],f)&&_(arguments[1],pe)){let t=arguments[0],tt=arguments[1],ta=new x;for(let th=t.iterator();th.hasNext();){let t=th.next(),tu=tt.map(t);null!==tu&&ta.add(tu)}return ta}}getClass(){return me}get interfaces_(){return[]}};me.constructor_=function(){};let ye=class ye{constructor(){ye.constructor_.apply(this,arguments)}transformPoint(t,tt){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,tt){let ta=!0,th=this.transformLinearRing(t.getExteriorRing(),t);null!==th&&th instanceof At&&!th.isEmpty()||(ta=!1);let tu=new x;for(let tt=0;tt<t.getNumInteriorRing();tt++){let th=this.transformLinearRing(t.getInteriorRingN(tt),t);null===th||th.isEmpty()||(th instanceof At||(ta=!1),tu.add(th))}if(ta)return this._factory.createPolygon(th,tu.toArray([]));{let t=new x;return null!==th&&t.add(th),t.addAll(tu),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,tt){let ta=new x;for(let tt=0;tt<t.getNumGeometries();tt++){let th=this.transformLineString(t.getGeometryN(tt),t);null!==th&&(th.isEmpty()||ta.add(th))}return this._factory.buildGeometry(ta)}transformCoordinates(t,tt){return this.copy(t)}transformLineString(t,tt){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,tt){let ta=new x;for(let tt=0;tt<t.getNumGeometries();tt++){let th=this.transformPoint(t.getGeometryN(tt),t);null!==th&&(th.isEmpty()||ta.add(th))}return this._factory.buildGeometry(ta)}transformMultiPolygon(t,tt){let ta=new x;for(let tt=0;tt<t.getNumGeometries();tt++){let th=this.transformPolygon(t.getGeometryN(tt),t);null!==th&&(th.isEmpty()||ta.add(th))}return this._factory.buildGeometry(ta)}copy(t){return t.copy()}transformGeometryCollection(t,tt){let ta=new x;for(let tt=0;tt<t.getNumGeometries();tt++){let th=this.transform(t.getGeometryN(tt));null!==th&&(this._pruneEmptyGeometry&&th.isEmpty()||ta.add(th))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Wt.toGeometryArray(ta)):this._factory.buildGeometry(ta)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof vt)return this.transformPoint(t,null);if(t instanceof Dt)return this.transformMultiPoint(t,null);if(t instanceof At)return this.transformLinearRing(t,null);if(t instanceof Rt)return this.transformLineString(t,null);if(t instanceof pt)return this.transformMultiLineString(t,null);if(t instanceof Mt)return this.transformPolygon(t,null);if(t instanceof Ft)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new n("Unknown Geometry subtype: "+t.getClass().getName())}transformLinearRing(t,tt){let ta=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===ta)return this._factory.createLinearRing(null);let th=ta.size();return th>0&&th<4&&!this._preserveType?this._factory.createLineString(ta):this._factory.createLinearRing(ta)}getClass(){return ye}get interfaces_(){return[]}};ye.constructor_=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};let xe=class xe{constructor(){xe.constructor_.apply(this,arguments)}static getGeometry(t){return t.getFactory().buildGeometry(xe.getLines(t))}static getLines(){if(1==arguments.length){let t=arguments[0];return xe.getLines(t,new x)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return t instanceof Rt?tt.add(t):t instanceof ft&&t.apply(new xe(tt)),tt}}filter(t){t instanceof Rt&&this._comps.add(t)}getClass(){return xe}get interfaces_(){return[dt]}};xe.constructor_=function(){this._comps=null;let t=arguments[0];this._comps=t};let Ee=class Ee{constructor(){Ee.constructor_.apply(this,arguments)}static getGeometry(){if(1==arguments.length){let t=arguments[0];return t.getFactory().buildGeometry(Ee.getLines(t))}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return t.getFactory().buildGeometry(Ee.getLines(t,tt))}}static getLines(){if(1==arguments.length){let t=arguments[0];return Ee.getLines(t,!1)}if(2==arguments.length){if(_(arguments[0],f)&&_(arguments[1],f)){let t=arguments[0],tt=arguments[1];for(let ta=t.iterator();ta.hasNext();){let t=ta.next();Ee.getLines(t,tt)}return tt}if(arguments[0]instanceof q&&"boolean"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=new x;return t.apply(new Ee(ta,tt)),ta}if(arguments[0]instanceof q&&_(arguments[1],f)){let t=arguments[0],tt=arguments[1];return t instanceof Rt?tt.add(t):t.apply(new Ee(tt)),tt}}else if(3==arguments.length){if("boolean"==typeof arguments[2]&&_(arguments[0],f)&&_(arguments[1],f)){let t=arguments[0],tt=arguments[1],ta=arguments[2];for(let th=t.iterator();th.hasNext();){let t=th.next();Ee.getLines(t,tt,ta)}return tt}if("boolean"==typeof arguments[2]&&arguments[0]instanceof q&&_(arguments[1],f)){let t=arguments[0],tt=arguments[1],ta=arguments[2];return t.apply(new Ee(tt,ta)),tt}}}filter(t){if(this._isForcedToLineString&&t instanceof At){let tt=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(tt),null}t instanceof Rt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}getClass(){return Ee}get interfaces_(){return[G]}};Ee.constructor_=function(){if(this._lines=null,this._isForcedToLineString=!1,1==arguments.length){let t=arguments[0];this._lines=t}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._lines=t,this._isForcedToLineString=tt}};let tu={reverseOrder:function(){return{compare:(t,tt)=>tt.compareTo(t)}},min:function(t){return tu.sort(t),t.get(0)},sort:function(t,tt){let ta=t.toArray();tt?ut.sort(ta,tt):ut.sort(ta);let th=t.iterator();for(let t=0,tt=ta.length;t<tt;t++)th.next(),th.set(ta[t])},singletonList:function(t){let tt=new x;return tt.add(t),tt}};let Ne=class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static getPoints(){if(1==arguments.length){let t=arguments[0];return t instanceof vt?tu.singletonList(t):Ne.getPoints(t,new x)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return t instanceof vt?tt.add(t):t instanceof ft&&t.apply(new Ne(tt)),tt}}filter(t){t instanceof vt&&this._pts.add(t)}getClass(){return Ne}get interfaces_(){return[dt]}};Ne.constructor_=function(){this._pts=null;let t=arguments[0];this._pts=t};let Ce=class Ce{constructor(){Ce.constructor_.apply(this,arguments)}static getPolygons(){if(1==arguments.length){let t=arguments[0];return Ce.getPolygons(t,new x)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return t instanceof Mt?tt.add(t):t instanceof ft&&t.apply(new Ce(tt)),tt}}filter(t){t instanceof Mt&&this._comps.add(t)}getClass(){return Ce}get interfaces_(){return[dt]}};Ce.constructor_=function(){this._comps=null;let t=arguments[0];this._comps=t};let Se=class Se{constructor(){Se.constructor_.apply(this,arguments)}applyTo(t){for(let tt=0;tt<t.getNumGeometries()&&!this._isDone;tt++){let ta=t.getGeometryN(tt);if(ta instanceof ft)this.applyTo(ta);else if(this.visit(ta),this.isDone())return this._isDone=!0,null}}getClass(){return Se}get interfaces_(){return[]}};Se.constructor_=function(){this._isDone=!1};let we=class we{constructor(){we.constructor_.apply(this,arguments)}createSupercircle(t){let tt=1/t,ta=this._dim.getMinSize()/2,th=this._dim.getCentre(),tu=Math.pow(ta,t),tc=Math.pow(tu/2,tt),tg=Math.trunc(this._nPts/8),t_=Array(8*tg+1).fill(null),td=tc/tg;for(let tc=0;tc<=tg;tc++){let tp=0,tf=ta;if(0!==tc){tp=td*tc;let ta=Math.pow(tp,t);tf=Math.pow(tu-ta,tt)}t_[tc]=this.coordTrans(tp,tf,th),t_[2*tg-tc]=this.coordTrans(tf,tp,th),t_[2*tg+tc]=this.coordTrans(tf,-tp,th),t_[4*tg-tc]=this.coordTrans(tp,-tf,th),t_[4*tg+tc]=this.coordTrans(-tp,-tf,th),t_[6*tg-tc]=this.coordTrans(-tf,-tp,th),t_[6*tg+tc]=this.coordTrans(-tf,tp,th),t_[8*tg-tc]=this.coordTrans(-tp,tf,th)}t_[t_.length-1]=new g(t_[0]);let tp=this._geomFact.createLinearRing(t_),tf=this._geomFact.createPolygon(tp);return this.rotate(tf)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){let t=this._dim.getEnvelope(),tt=t.getWidth()/2,ta=t.getHeight()/2,th=t.getMinX()+tt,tu=t.getMinY()+ta,tc=Array(this._nPts+1).fill(null),tg=0;for(let t=0;t<this._nPts;t++){let t_=t*(2*Math.PI/this._nPts),td=tt*Math.cos(t_)+th,tp=ta*Math.sin(t_)+tu;tc[tg++]=this.coord(td,tp)}tc[tg]=new g(tc[0]);let t_=this._geomFact.createLinearRing(tc),td=this._geomFact.createPolygon(t_);return this.rotate(td)}coordTrans(t,tt,ta){return this.coord(t+ta.x,tt+ta.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,tt){let ta=this._dim.getEnvelope(),th=ta.getWidth()/2,tu=ta.getHeight()/2,tc=ta.getMinX()+th,tg=ta.getMinY()+tu,t_=tt;(t_<=0||t_>2*Math.PI)&&(t_=2*Math.PI);let td=t_/(this._nPts-1),tp=Array(this._nPts).fill(null),tf=0;for(let tt=0;tt<this._nPts;tt++){let ta=t+tt*td,t_=th*Math.cos(ta)+tc,tm=tu*Math.sin(ta)+tg;tp[tf++]=this.coord(t_,tm)}let tm=this._geomFact.createLineString(tp);return this.rotate(tm)}rotate(t){if(0!==this._rotationAngle){let tt=ae.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(tt)}return t}coord(t,tt){let ta=new g(t,tt);return this._precModel.makePrecise(ta),ta}createArcPolygon(t,tt){let ta=this._dim.getEnvelope(),th=ta.getWidth()/2,tu=ta.getHeight()/2,tc=ta.getMinX()+th,tg=ta.getMinY()+tu,t_=tt;(t_<=0||t_>2*Math.PI)&&(t_=2*Math.PI);let td=t_/(this._nPts-1),tp=Array(this._nPts+2).fill(null),tf=0;tp[tf++]=this.coord(tc,tg);for(let tt=0;tt<this._nPts;tt++){let ta=t+td*tt,t_=th*Math.cos(ta)+tc,tm=tu*Math.sin(ta)+tg;tp[tf++]=this.coord(t_,tm)}tp[tf++]=this.coord(tc,tg);let tm=this._geomFact.createLinearRing(tp),ty=this._geomFact.createPolygon(tm);return this.rotate(ty)}createRectangle(){let t=null,tt=0,ta=Math.trunc(this._nPts/4);ta<1&&(ta=1);let th=this._dim.getEnvelope().getWidth()/ta,tu=this._dim.getEnvelope().getHeight()/ta,tc=Array(4*ta+1).fill(null),tg=this._dim.getEnvelope();for(t=0;t<ta;t++){let ta=tg.getMinX()+t*th,tu=tg.getMinY();tc[tt++]=this.coord(ta,tu)}for(t=0;t<ta;t++){let ta=tg.getMaxX(),th=tg.getMinY()+t*tu;tc[tt++]=this.coord(ta,th)}for(t=0;t<ta;t++){let ta=tg.getMaxX()-t*th,tu=tg.getMaxY();tc[tt++]=this.coord(ta,tu)}for(t=0;t<ta;t++){let ta=tg.getMinX(),th=tg.getMaxY()-t*tu;tc[tt++]=this.coord(ta,th)}tc[tt++]=new g(tc[0]);let t_=this._geomFact.createLinearRing(tc),td=this._geomFact.createPolygon(t_);return this.rotate(td)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}getClass(){return we}get interfaces_(){return[]}};let Le=class Le{constructor(){Le.constructor_.apply(this,arguments)}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new g(t.getMinX(),t.getMinY()),this.centre=new g(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new N(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new N(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new N(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new g(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}getClass(){return Le}get interfaces_(){return[]}};Le.constructor_=function(){this.base=null,this.centre=null,this.width=null,this.height=null},we.Dimensions=Le,we.constructor_=function(){if(this._geomFact=null,this._precModel=null,this._dim=new Le,this._nPts=100,this._rotationAngle=0,0==arguments.length)we.constructor_.call(this,new Wt);else if(1==arguments.length){let t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}};let Te=class Te extends we{constructor(){super(),Te.constructor_.apply(this,arguments)}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){let t=this._dim.getEnvelope(),tt=t.getWidth()/2,ta=this._armLengthRatio;ta<0&&(ta=0),ta>1&&(ta=1);let th=ta*tt,tu=(1-ta)*tt,tc=t.getMinX()+tt,tg=t.getMinY()+tt,t_=Array(this._nPts+1).fill(null),td=0;for(let t=0;t<this._nPts;t++){let tt=t/this._nPts*this._numArms,ta=tt-Math.floor(tt),tp=2*Math.PI*ta,tf=tu+th*((Math.cos(tp)+1)/2),tm=t*(2*Math.PI/this._nPts),ty=tf*Math.cos(tm)+tc,tx=tf*Math.sin(tm)+tg;t_[td++]=this.coord(ty,tx)}t_[td]=new g(t_[0]);let tp=this._geomFact.createLinearRing(t_);return this._geomFact.createPolygon(tp)}getClass(){return Te}get interfaces_(){return[]}};Te.constructor_=function(){if(this._numArms=8,this._armLengthRatio=.5,0==arguments.length)we.constructor_.call(this);else if(1==arguments.length){let t=arguments[0];we.constructor_.call(this,t)}};var tc=Object.freeze({__proto__:null,Coordinate:g,CoordinateList:I,Envelope:N,LineSegment:ne,GeometryFactory:Wt,Geometry:q,Point:vt,LineString:Rt,LinearRing:At,Polygon:Mt,GeometryCollection:ft,MultiPoint:Dt,MultiLineString:pt,MultiPolygon:Ft,Dimension:gt,IntersectionMatrix:ie,PrecisionModel:Xt,Location:se,Triangle:oe,util:Object.freeze({__proto__:null,AffineTransformation:ae,AffineTransformationBuilder:he,AffineTransformationFactory:ue,ComponentCoordinateExtracter:ge,GeometryCollectionMapper:de,GeometryCombiner:_e,GeometryEditor:Gt,GeometryExtracter:fe,GeometryMapper:me,GeometryTransformer:ye,LineStringExtracter:xe,LinearComponentExtracter:Ee,MapOp:pe,PointExtracter:Ne,PolygonExtracter:Ce,ShortCircuitedGeometryVisitor:Se,SineStarFactory:Te})});let ve=class ve{constructor(){ve.constructor_.apply(this,arguments)}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1==arguments.length){let t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(this._isNull)return this.initialize(t,tt),null;let ta=t.distance(tt);ta<this._distance&&this.initialize(t,tt,ta)}}initialize(){if(0==arguments.length)this._isNull=!0;else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(tt),this._distance=t.distance(tt),this._isNull=!1}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(tt),this._distance=ta,this._isNull=!1}}toString(){return $t.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1==arguments.length){let t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(this._isNull)return this.initialize(t,tt),null;let ta=t.distance(tt);ta>this._distance&&this.initialize(t,tt,ta)}}getClass(){return ve}get interfaces_(){return[]}};ve.constructor_=function(){this._pt=[new g,new g],this._distance=i.NaN,this._isNull=!0};let Oe=class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static computeDistance(){if(arguments[2]instanceof ve&&arguments[0]instanceof Rt&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=new ne,tu=t.getCoordinates();for(let t=0;t<tu.length-1;t++){th.setCoordinates(tu[t],tu[t+1]);let tc=th.closestPoint(tt);ta.setMinimum(tc,tt)}}else if(arguments[2]instanceof ve&&arguments[0]instanceof Mt&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=arguments[2];Oe.computeDistance(t.getExteriorRing(),tt,ta);for(let th=0;th<t.getNumInteriorRing();th++)Oe.computeDistance(t.getInteriorRingN(th),tt,ta)}else if(arguments[2]instanceof ve&&arguments[0]instanceof q&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(t instanceof Rt)Oe.computeDistance(t,tt,ta);else if(t instanceof Mt)Oe.computeDistance(t,tt,ta);else if(t instanceof ft)for(let th=0;th<t.getNumGeometries();th++){let tu=t.getGeometryN(th);Oe.computeDistance(tu,tt,ta)}else ta.setMinimum(t.getCoordinate(),tt)}else if(arguments[2]instanceof ve&&arguments[0]instanceof ne&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=t.closestPoint(tt);ta.setMinimum(th,tt)}}getClass(){return Oe}get interfaces_(){return[]}};Oe.constructor_=function(){};let be=class be{constructor(){be.constructor_.apply(this,arguments)}static distance(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new be(t,tt).distance()}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=new be(t,tt);return th.setDensifyFraction(ta),th.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new n("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,tt){this.computeOrientedDistance(t,tt,this._ptDist),this.computeOrientedDistance(tt,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,tt,ta){let th=new Me(tt);if(t.apply(th),ta.setMaximum(th.getMaxPointDistance()),this._densifyFrac>0){let th=new De(tt,this._densifyFrac);t.apply(th),ta.setMaximum(th.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}getClass(){return be}get interfaces_(){return[]}};let Me=class Me{constructor(){Me.constructor_.apply(this,arguments)}filter(t){this._minPtDist.initialize(),Oe.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}getClass(){return Me}get interfaces_(){return[B]}};Me.constructor_=function(){this._maxPtDist=new ve,this._minPtDist=new ve,this._euclideanDist=new Oe,this._geom=null;let t=arguments[0];this._geom=t};let De=class De{constructor(){De.constructor_.apply(this,arguments)}filter(t,tt){if(0===tt)return null;let ta=t.getCoordinate(tt-1),th=t.getCoordinate(tt),tu=(th.x-ta.x)/this._numSubSegs,tc=(th.y-ta.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){let tt=ta.x+t*tu,th=ta.y+t*tc,tg=new g(tt,th);this._minPtDist.initialize(),Oe.computeDistance(this._geom,tg,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}getClass(){return De}get interfaces_(){return[_t]}};De.constructor_=function(){this._maxPtDist=new ve,this._minPtDist=new ve,this._geom=null,this._numSubSegs=0;let t=arguments[0],tt=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/tt))},be.MaxPointDistanceFilter=Me,be.MaxDensifiedByFractionDistanceFilter=De,be.constructor_=function(){this._g0=null,this._g1=null,this._ptDist=new ve,this._densifyFrac=0;let t=arguments[0],tt=arguments[1];this._g0=t,this._g1=tt};var tg=Object.freeze({__proto__:null,DiscreteHausdorffDistance:be,DistanceToPoint:Oe,PointPairDistance:ve});let Fe=class Fe{constructor(){Fe.constructor_.apply(this,arguments)}visitItem(t){}getClass(){return Fe}get interfaces_(){return[]}};Fe.constructor_=function(){};let Ge=class Ge{constructor(){Ge.constructor_.apply(this,arguments)}locate(t){}getClass(){return Ge}get interfaces_(){return[]}};Ge.constructor_=function(){};let qe=class qe{constructor(){qe.constructor_.apply(this,arguments)}getMin(){return this._min}intersects(t,tt){return!(this._min>tt||this._max<t)}getMax(){return this._max}toString(){return $t.toLineString(new g(this._min,0),new g(this._max,0))}getClass(){return qe}get interfaces_(){return[]}};let Be=class Be{constructor(){Be.constructor_.apply(this,arguments)}compare(t,tt){let ta=(t._min+t._max)/2,th=(tt._min+tt._max)/2;return ta<th?-1:ta>th?1:0}getClass(){return Be}get interfaces_(){return[l]}};Be.constructor_=function(){},qe.NodeComparator=Be,qe.constructor_=function(){this._min=i.POSITIVE_INFINITY,this._max=i.NEGATIVE_INFINITY};let Ve=class Ve extends qe{constructor(){super(),Ve.constructor_.apply(this,arguments)}query(t,tt,ta){if(!this.intersects(t,tt))return null;ta.visitItem(this._item)}getClass(){return Ve}get interfaces_(){return[]}};Ve.constructor_=function(){this._item=null;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._min=t,this._max=tt,this._item=ta};let ze=class ze extends qe{constructor(){super(),ze.constructor_.apply(this,arguments)}buildExtent(t,tt){this._min=Math.min(t._min,tt._min),this._max=Math.max(t._max,tt._max)}query(t,tt,ta){if(!this.intersects(t,tt))return null;null!==this._node1&&this._node1.query(t,tt,ta),null!==this._node2&&this._node2.query(t,tt,ta)}getClass(){return ze}get interfaces_(){return[]}};ze.constructor_=function(){this._node1=null,this._node2=null;let t=arguments[0],tt=arguments[1];this._node1=t,this._node2=tt,this.buildExtent(this._node1,this._node2)};let Ye=class Ye{constructor(){Ye.constructor_.apply(this,arguments)}buildTree(){tu.sort(this._leaves,new qe.NodeComparator);let t=this._leaves,tt=null,ta=new x;for(;;){if(this.buildLevel(t,ta),1===ta.size())return ta.get(0);tt=t,t=ta,ta=tt}}insert(t,tt,ta){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Ve(t,tt,ta))}query(t,tt,ta){this.init(),this._root.query(t,tt,ta)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){O.out.println($t.toLineString(new g(t._min,this._level),new g(t._max,this._level)))}init(){if(null!==this._root)return null;this.buildRoot()}buildLevel(t,tt){this._level++,tt.clear();for(let ta=0;ta<t.size();ta+=2){let th=t.get(ta);if(null===(ta+1<t.size()?t.get(ta):null))tt.add(th);else{let th=new ze(t.get(ta),t.get(ta+1));tt.add(th)}}}getClass(){return Ye}get interfaces_(){return[]}};Ye.constructor_=function(){this._leaves=new x,this._root=null,this._level=0};let Ue=class Ue{constructor(){Ue.constructor_.apply(this,arguments)}visitItem(t){this._items.add(t)}getItems(){return this._items}getClass(){return Ue}get interfaces_(){return[Fe]}};Ue.constructor_=function(){this._items=new x};let ke=class ke{constructor(){ke.constructor_.apply(this,arguments)}static locatePointInRing(){if(arguments[0]instanceof g&&_(arguments[1],A)){let t=arguments[0],tt=arguments[1],ta=new ke(t),th=new g,tu=new g;for(let t=1;t<tt.size()&&(tt.getCoordinate(t,th),tt.getCoordinate(t-1,tu),ta.countSegment(th,tu),!ta.isOnSegment());t++);return ta.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){let t=arguments[0],tt=arguments[1],ta=new ke(t);for(let t=1;t<tt.length;t++){let th=tt[t],tu=tt[t-1];if(ta.countSegment(th,tu),ta.isOnSegment())break}return ta.getLocation()}}countSegment(t,tt){if(t.x<this._p.x&&tt.x<this._p.x)return null;if(this._p.x===tt.x&&this._p.y===tt.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&tt.y===this._p.y){let ta=t.x,th=tt.x;return ta>th&&(ta=tt.x,th=t.x),this._p.x>=ta&&this._p.x<=th&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&tt.y<=this._p.y||tt.y>this._p.y&&t.y<=this._p.y){let ta=v.index(t,tt,this._p);if(ta===v.COLLINEAR)return this._isPointOnSegment=!0,null;tt.y<t.y&&(ta=-ta),ta===v.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==se.EXTERIOR}getLocation(){return this._isPointOnSegment?se.BOUNDARY:this._crossingCount%2==1?se.INTERIOR:se.EXTERIOR}isOnSegment(){return this._isPointOnSegment}getClass(){return ke}get interfaces_(){return[]}};ke.constructor_=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;let t=arguments[0];this._p=t};let Xe=class Xe{constructor(){Xe.constructor_.apply(this,arguments)}locate(t){let tt=new ke(t),ta=new He(tt);return this._index.query(t.y,t.y,ta),tt.getLocation()}getClass(){return Xe}get interfaces_(){return[Ge]}};let He=class He{constructor(){He.constructor_.apply(this,arguments)}visitItem(t){this._counter.countSegment(t.getCoordinate(0),t.getCoordinate(1))}getClass(){return He}get interfaces_(){return[Fe]}};He.constructor_=function(){this._counter=null;let t=arguments[0];this._counter=t};let We=class We{constructor(){We.constructor_.apply(this,arguments)}init(t){for(let tt=Ee.getLines(t).iterator();tt.hasNext();){let t=tt.next().getCoordinates();this.addLine(t)}}addLine(t){for(let tt=1;tt<t.length;tt++){let ta=new ne(t[tt-1],t[tt]),th=Math.min(ta.p0.y,ta.p1.y),tu=Math.max(ta.p0.y,ta.p1.y);this._index.insert(th,tu,ta)}}query(){if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new Ue;return this._index.query(t,tt,ta),ta.getItems()}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._index.query(t,tt,ta)}}getClass(){return We}get interfaces_(){return[]}};We.constructor_=function(){this._index=new Ye;let t=arguments[0];this.init(t)},Xe.SegmentVisitor=He,Xe.IntervalIndexedGeometry=We,Xe.constructor_=function(){this._index=null;let t=arguments[0];if(!(_(t,bt)||t instanceof At))throw new n("Argument must be Polygonal or LinearRing");this._index=new We(t)};let je=class je{constructor(){je.constructor_.apply(this,arguments)}static isOnLine(){if(arguments[0]instanceof g&&_(arguments[1],A)){let t=arguments[0],tt=arguments[1],ta=new ee,th=new g,tu=new g,tc=tt.size();for(let tg=1;tg<tc;tg++)if(tt.getCoordinate(tg-1,th),tt.getCoordinate(tg,tu),ta.computeIntersection(t,th,tu),ta.hasIntersection())return!0;return!1}if(arguments[0]instanceof g&&arguments[1]instanceof Array){let t=arguments[0],tt=arguments[1],ta=new ee;for(let th=1;th<tt.length;th++){let tu=tt[th-1],tc=tt[th];if(ta.computeIntersection(t,tu,tc),ta.hasIntersection())return!0}return!1}}static locateInRing(t,tt){return ke.locatePointInRing(t,tt)}static isInRing(t,tt){return je.locateInRing(t,tt)!==se.EXTERIOR}getClass(){return je}get interfaces_(){return[]}};function Ke(){}je.constructor_=function(){},Ke.prototype.hasNext=function(){},Ke.prototype.next=function(){},Ke.prototype.remove=function(){};let Ze=class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static isAtomic(t){return!(t instanceof ft)}next(){if(this._atStart)return this._atStart=!1,Ze.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new y;let t=this._parent.getGeometryN(this._index++);return t instanceof ft?(this._subcollectionIterator=new Ze(t),this._subcollectionIterator.next()):t}remove(){throw new UnsupportedOperationException(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}getClass(){return Ze}get interfaces_(){return[Ke]}};Ze.constructor_=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;let t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()};let Qe=class Qe{constructor(){Qe.constructor_.apply(this,arguments)}static locatePointInPolygon(t,tt){if(tt.isEmpty())return se.EXTERIOR;let ta=tt.getExteriorRing(),th=Qe.locatePointInRing(t,ta);if(th!==se.INTERIOR)return th;for(let ta=0;ta<tt.getNumInteriorRing();ta++){let th=tt.getInteriorRingN(ta),tu=Qe.locatePointInRing(t,th);if(tu===se.BOUNDARY)return se.BOUNDARY;if(tu===se.INTERIOR)return se.EXTERIOR}return se.INTERIOR}static locatePointInRing(t,tt){return tt.getEnvelopeInternal().intersects(t)?je.locateInRing(t,tt.getCoordinates()):se.EXTERIOR}static containsPointInPolygon(t,tt){return se.EXTERIOR!==Qe.locatePointInPolygon(t,tt)}static locateInGeometry(t,tt){if(tt instanceof Mt)return Qe.locatePointInPolygon(t,tt);if(tt instanceof ft){let ta=new Ze(tt);for(;ta.hasNext();){let th=ta.next();if(th!==tt){let tt=Qe.locateInGeometry(t,th);if(tt!==se.EXTERIOR)return tt}}}return se.EXTERIOR}static locate(t,tt){return tt.isEmpty()?se.EXTERIOR:Qe.locateInGeometry(t,tt)}locate(t){return Qe.locate(t,this._geom)}getClass(){return Qe}get interfaces_(){return[Ge]}};Qe.constructor_=function(){this._geom=null;let t=arguments[0];this._geom=t};var t_=Object.freeze({__proto__:null,IndexedPointInAreaLocator:Xe,PointOnGeometryLocator:Ge,SimplePointInAreaLocator:Qe});let $e=class $e{constructor(){$e.constructor_.apply(this,arguments)}measure(t,tt){}getClass(){return $e}get interfaces_(){return[]}};$e.constructor_=function(){};let tn=class tn{constructor(){tn.constructor_.apply(this,arguments)}measure(t,tt){return t.intersection(tt).getArea()/t.union(tt).getArea()}getClass(){return tn}get interfaces_(){return[$e]}};tn.constructor_=function(){};let en=class en{constructor(){en.constructor_.apply(this,arguments)}static diagonalSize(t){if(t.isNull())return 0;let tt=t.getWidth(),ta=t.getHeight();return Math.sqrt(tt*tt+ta*ta)}measure(t,tt){let ta=be.distance(t,tt,en.DENSIFY_FRACTION),th=new N(t.getEnvelopeInternal());return th.expandToInclude(tt.getEnvelopeInternal()),1-ta/en.diagonalSize(th)}getClass(){return en}get interfaces_(){return[$e]}};en.constructor_=function(){},en.DENSIFY_FRACTION=.25;let nn=class nn{constructor(){nn.constructor_.apply(this,arguments)}static combine(t,tt){return Math.min(t,tt)}getClass(){return nn}get interfaces_(){return[]}};nn.constructor_=function(){};var td=Object.freeze({__proto__:null,AreaSimilarityMeasure:tn,HausdorffSimilarityMeasure:en,SimilarityMeasure:$e,SimilarityMeasureCombiner:nn});let rn=class rn{constructor(){rn.constructor_.apply(this,arguments)}static area2(t,tt,ta){return(tt.x-t.x)*(ta.y-t.y)-(ta.x-t.x)*(tt.y-t.y)}static centroid3(t,tt,ta,th){return th.x=t.x+tt.x+ta.x,th.y=t.y+tt.y+ta.y,null}static getCentroid(t){return new rn(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let tt=0;for(let ta=0;ta<t.length-1;ta++){let th=t[ta].distance(t[ta+1]);if(0===th)continue;tt+=th;let tu=(t[ta].x+t[ta+1].x)/2;this._lineCentSum.x+=th*tu;let tc=(t[ta].y+t[ta+1].y)/2;this._lineCentSum.y+=th*tc}this._totalLength+=tt,0===tt&&t.length>0&&this.addPoint(t[0])}addHole(t){let tt=v.isCCW(t);for(let ta=0;ta<t.length-1;ta++)this.addTriangle(this._areaBasePt,t[ta],t[ta+1],tt);this.addLineSegments(t)}getCentroid(){let t=new g;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);let tt=!v.isCCW(t);for(let ta=0;ta<t.length-1;ta++)this.addTriangle(this._areaBasePt,t[ta],t[ta+1],tt);this.addLineSegments(t)}addTriangle(t,tt,ta,th){let tu=th?1:-1;rn.centroid3(t,tt,ta,this._triangleCent3);let tc=rn.area2(t,tt,ta);this._cg3.x+=tu*tc*this._triangleCent3.x,this._cg3.y+=tu*tc*this._triangleCent3.y,this._areasum2+=tu*tc}add(){if(arguments[0]instanceof Mt){let t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let tt=0;tt<t.getNumInteriorRing();tt++)this.addHole(t.getInteriorRingN(tt).getCoordinates())}else if(arguments[0]instanceof q){let t=arguments[0];if(t.isEmpty())return null;if(t instanceof vt)this.addPoint(t.getCoordinate());else if(t instanceof Rt)this.addLineSegments(t.getCoordinates());else if(t instanceof Mt)this.add(t);else if(t instanceof ft)for(let tt=0;tt<t.getNumGeometries();tt++)this.add(t.getGeometryN(tt))}}getClass(){return rn}get interfaces_(){return[]}};function on(t){this.message=t||""}function ln(){this.array_=[]}rn.constructor_=function(){this._areaBasePt=null,this._triangleCent3=new g,this._areasum2=0,this._cg3=new g,this._lineCentSum=new g,this._totalLength=0,this._ptCount=0,this._ptCentSum=new g;let t=arguments[0];this._areaBasePt=null,this.add(t)},on.prototype=Error(),on.prototype.name="EmptyStackException",ln.prototype=new m,ln.prototype.add=function(t){return this.array_.push(t),!0},ln.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},ln.prototype.push=function(t){return this.array_.push(t),t},ln.prototype.pop=function(t){if(0===this.array_.length)throw new on;return this.array_.pop()},ln.prototype.peek=function(){if(0===this.array_.length)throw new on;return this.array_[this.array_.length-1]},ln.prototype.empty=function(){return 0===this.array_.length},ln.prototype.isEmpty=function(){return this.empty()},ln.prototype.search=function(t){return this.array_.indexOf(t)},ln.prototype.size=function(){return this.array_.length},ln.prototype.toArray=function(){for(var t=[],tt=0,ta=this.array_.length;tt<ta;tt++)t.push(this.array_[tt]);return t};let an=class an{constructor(){an.constructor_.apply(this,arguments)}static filterCoordinates(t){let tt=new an;for(let ta=0;ta<t.length;ta++)tt.filter(t[ta]);return tt.getCoordinates()}filter(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))}getCoordinates(){let t=Array(this.list.size()).fill(null);return this.list.toArray(t)}getClass(){return an}get interfaces_(){return[B]}};an.constructor_=function(){this.treeSet=new ct,this.list=new x};let cn=class cn{constructor(){cn.constructor_.apply(this,arguments)}static extractCoordinates(t){let tt=new an;return t.apply(tt),tt.getCoordinates()}preSort(t){let tt=null;for(let ta=1;ta<t.length;ta++)(t[ta].y<t[0].y||t[ta].y===t[0].y&&t[ta].x<t[0].x)&&(tt=t[0],t[0]=t[ta],t[ta]=tt);return ut.sort(t,1,t.length,new hn(t[0])),t}computeOctRing(t){let tt=this.computeOctPts(t),ta=new I;return ta.add(tt,!1),3>ta.size()?null:(ta.closeRing(),ta.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);let tt=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(tt)}cleanRing(t){u.equals(t[0],t[t.length-1]);let tt=new x,ta=null;for(let th=0;th<=t.length-2;th++){let tu=t[th],tc=t[th+1];tu.equals(tc)||null!==ta&&this.isBetween(ta,tu,tc)||(tt.add(tu),ta=tu)}tt.add(t[t.length-1]);let th=Array(tt.size()).fill(null);return tt.toArray(th)}isBetween(t,tt,ta){return 0===v.index(t,tt,ta)&&(t.x!==ta.x&&(t.x<=tt.x&&tt.x<=ta.x||ta.x<=tt.x&&tt.x<=t.x)||t.y!==ta.y&&(t.y<=tt.y&&tt.y<=ta.y||ta.y<=tt.y&&tt.y<=t.y))}reduce(t){let tt=this.computeOctRing(t);if(null===tt)return t;let ta=new ct;for(let t=0;t<tt.length;t++)ta.add(tt[t]);for(let th=0;th<t.length;th++)je.isInRing(t[th],tt)||ta.add(t[th]);let th=X.toCoordinateArray(ta);return th.length<3?this.padArray3(th):th}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));let tt=this.preSort(t),ta=this.grahamScan(tt),th=this.toCoordinateArray(ta);return this.lineOrPolygon(th)}padArray3(t){let tt=[,,,].fill(null);for(let ta=0;ta<tt.length;ta++)ta<t.length?tt[ta]=t[ta]:tt[ta]=t[0];return tt}computeOctPts(t){let tt=Array(8).fill(null);for(let ta=0;ta<tt.length;ta++)tt[ta]=t[0];for(let ta=1;ta<t.length;ta++)t[ta].x<tt[0].x&&(tt[0]=t[ta]),t[ta].x-t[ta].y<tt[1].x-tt[1].y&&(tt[1]=t[ta]),t[ta].y>tt[2].y&&(tt[2]=t[ta]),t[ta].x+t[ta].y>tt[3].x+tt[3].y&&(tt[3]=t[ta]),t[ta].x>tt[4].x&&(tt[4]=t[ta]),t[ta].x-t[ta].y>tt[5].x-tt[5].y&&(tt[5]=t[ta]),t[ta].y<tt[6].y&&(tt[6]=t[ta]),t[ta].x+t[ta].y<tt[7].x+tt[7].y&&(tt[7]=t[ta]);return tt}toCoordinateArray(t){let tt=Array(t.size()).fill(null);for(let ta=0;ta<t.size();ta++){let th=t.get(ta);tt[ta]=th}return tt}grahamScan(t){let tt=null,ta=new ln;ta.push(t[0]),ta.push(t[1]),ta.push(t[2]);for(let th=3;th<t.length;th++){for(tt=ta.pop();!ta.empty()&&v.index(ta.peek(),tt,t[th])>0;)tt=ta.pop();ta.push(tt),ta.push(t[th])}return ta.push(t[0]),ta}getClass(){return cn}get interfaces_(){return[]}};let hn=class hn{constructor(){hn.constructor_.apply(this,arguments)}static polarCompare(t,tt,ta){let th=tt.x-t.x,tu=tt.y-t.y,tc=ta.x-t.x,tg=ta.y-t.y,t_=v.index(t,tt,ta);if(t_===v.COUNTERCLOCKWISE)return 1;if(t_===v.CLOCKWISE)return -1;let td=th*th+tu*tu,tp=tc*tc+tg*tg;return td<tp?-1:td>tp?1:0}compare(t,tt){return hn.polarCompare(this._origin,t,tt)}getClass(){return hn}get interfaces_(){return[l]}};hn.constructor_=function(){this._origin=null;let t=arguments[0];this._origin=t},cn.RadialComparator=hn,cn.constructor_=function(){if(this._geomFactory=null,this._inputPts=null,1==arguments.length){let t=arguments[0];cn.constructor_.call(this,cn.extractCoordinates(t),t.getFactory())}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._inputPts=an.filterCoordinates(t),this._geomFactory=tt}};let un=class un{constructor(){un.constructor_.apply(this,arguments)}static centre(t){return new g(un.avg(t.getMinX(),t.getMaxX()),un.avg(t.getMinY(),t.getMaxY()))}static avg(t,tt){return(t+tt)/2}addPolygon(t){if(t.isEmpty())return null;let tt=null,ta=null,th=this.horizontalBisector(t);if(0===th.getLength())ta=0,tt=th.getCoordinate();else{let tu=th.intersection(t),tc=this.widestGeometry(tu);ta=tc.getEnvelopeInternal().getWidth(),tt=un.centre(tc.getEnvelopeInternal())}(null===this._interiorPoint||ta>this._maxWidth)&&(this._interiorPoint=tt,this._maxWidth=ta)}getInteriorPoint(){return this._interiorPoint}widestGeometry(){if(arguments[0]instanceof ft){let t=arguments[0];if(t.isEmpty())return t;let tt=t.getGeometryN(0);for(let ta=1;ta<t.getNumGeometries();ta++)t.getGeometryN(ta).getEnvelopeInternal().getWidth()>tt.getEnvelopeInternal().getWidth()&&(tt=t.getGeometryN(ta));return tt}if(arguments[0]instanceof q){let t=arguments[0];return t instanceof ft?this.widestGeometry(t):t}}horizontalBisector(t){let tt=t.getEnvelopeInternal(),ta=gn.getBisectorY(t);return this._factory.createLineString([new g(tt.getMinX(),ta),new g(tt.getMaxX(),ta)])}add(t){if(t instanceof Mt)this.addPolygon(t);else if(t instanceof ft)for(let tt=0;tt<t.getNumGeometries();tt++)this.add(t.getGeometryN(tt))}getClass(){return un}get interfaces_(){return[]}};let gn=class gn{constructor(){gn.constructor_.apply(this,arguments)}static getBisectorY(t){return new gn(t).getBisectorY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getBisectorY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return un.avg(this._hiY,this._loY)}process(t){let tt=t.getCoordinateSequence();for(let t=0;t<tt.size();t++){let ta=tt.getY(t);this.updateInterval(ta)}}getClass(){return gn}get interfaces_(){return[]}};gn.constructor_=function(){this._poly=null,this._centreY=null,this._hiY=i.MAX_VALUE,this._loY=-i.MAX_VALUE;let t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=un.avg(this._loY,this._hiY)},un.SafeBisectorFinder=gn,un.constructor_=function(){this._factory=null,this._interiorPoint=null,this._maxWidth=0;let t=arguments[0];this._factory=t.getFactory(),this.add(t)};let dn=class dn{constructor(){dn.constructor_.apply(this,arguments)}addEndpoints(){if(arguments[0]instanceof q){let t=arguments[0];if(t instanceof Rt)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(let tt=0;tt<t.getNumGeometries();tt++)this.addEndpoints(t.getGeometryN(tt))}else if(arguments[0]instanceof Array){let t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof q){let t=arguments[0];if(t instanceof Rt)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(let tt=0;tt<t.getNumGeometries();tt++)this.addInterior(t.getGeometryN(tt))}else if(arguments[0]instanceof Array){let t=arguments[0];for(let tt=1;tt<t.length-1;tt++)this.add(t[tt])}}add(t){let tt=t.distance(this._centroid);tt<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=tt)}getClass(){return dn}get interfaces_(){return[]}};dn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;let t=arguments[0];t.isEmpty()?this._centroid=new g:this._centroid=rn.getCentroid(t),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)};let _n=class _n{constructor(){_n.constructor_.apply(this,arguments)}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof q){let t=arguments[0];if(t instanceof vt)this.add(t.getCoordinate());else if(t instanceof ft)for(let tt=0;tt<t.getNumGeometries();tt++)this.add(t.getGeometryN(tt))}else if(arguments[0]instanceof g){let t=arguments[0],tt=t.distance(this._centroid);tt<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=tt)}}getClass(){return _n}get interfaces_(){return[]}};_n.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;let t=arguments[0];this._centroid=t.getCentroid().getCoordinate(),this.add(t)};let fn=class fn{constructor(){fn.constructor_.apply(this,arguments)}locateInPolygonRing(t,tt){return tt.getEnvelopeInternal().intersects(t)?je.locateInRing(t,tt.getCoordinates()):se.EXTERIOR}intersects(t,tt){return this.locate(t,tt)!==se.EXTERIOR}updateLocationInfo(t){t===se.INTERIOR&&(this._isIn=!0),t===se.BOUNDARY&&this._numBoundaries++}computeLocation(t,tt){if(tt instanceof vt&&this.updateLocationInfo(this.locateOnPoint(t,tt)),tt instanceof Rt)this.updateLocationInfo(this.locateOnLineString(t,tt));else if(tt instanceof Mt)this.updateLocationInfo(this.locateInPolygon(t,tt));else if(tt instanceof pt)for(let ta=0;ta<tt.getNumGeometries();ta++){let th=tt.getGeometryN(ta);this.updateLocationInfo(this.locateOnLineString(t,th))}else if(tt instanceof Ft)for(let ta=0;ta<tt.getNumGeometries();ta++){let th=tt.getGeometryN(ta);this.updateLocationInfo(this.locateInPolygon(t,th))}else if(tt instanceof ft){let ta=new Ze(tt);for(;ta.hasNext();){let th=ta.next();th!==tt&&this.computeLocation(t,th)}}}locateOnPoint(t,tt){return tt.getCoordinate().equals2D(t)?se.INTERIOR:se.EXTERIOR}locateOnLineString(t,tt){if(!tt.getEnvelopeInternal().intersects(t))return se.EXTERIOR;let ta=tt.getCoordinateSequence();return!tt.isClosed()&&(t.equals(ta.getCoordinate(0))||t.equals(ta.getCoordinate(ta.size()-1)))?se.BOUNDARY:je.isOnLine(t,ta)?se.INTERIOR:se.EXTERIOR}locateInPolygon(t,tt){if(tt.isEmpty())return se.EXTERIOR;let ta=tt.getExteriorRing(),th=this.locateInPolygonRing(t,ta);if(th===se.EXTERIOR)return se.EXTERIOR;if(th===se.BOUNDARY)return se.BOUNDARY;for(let ta=0;ta<tt.getNumInteriorRing();ta++){let th=tt.getInteriorRingN(ta),tu=this.locateInPolygonRing(t,th);if(tu===se.INTERIOR)return se.EXTERIOR;if(tu===se.BOUNDARY)return se.BOUNDARY}return se.INTERIOR}locate(t,tt){return tt.isEmpty()?se.EXTERIOR:tt instanceof Rt?this.locateOnLineString(t,tt):tt instanceof Mt?this.locateInPolygon(t,tt):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,tt),this._boundaryRule.isInBoundary(this._numBoundaries)?se.BOUNDARY:this._numBoundaries>0||this._isIn?se.INTERIOR:se.EXTERIOR)}getClass(){return fn}get interfaces_(){return[]}};fn.constructor_=function(){if(this._boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0==arguments.length);else if(1==arguments.length){let t=arguments[0];if(null===t)throw new n("Rule must be non-null");this._boundaryRule=t}};let pn=class pn{constructor(){pn.constructor_.apply(this,arguments)}static pointWitMinAngleWithX(t,tt){let ta=i.MAX_VALUE,th=null;for(let tu=0;tu<t.length;tu++){let tc=t[tu];if(tc===tt)continue;let tg=tc.x-tt.x,t_=tc.y-tt.y;t_<0&&(t_=-t_);let td=t_/Math.sqrt(tg*tg+t_*t_);td<ta&&(ta=td,th=tc)}return th}static lowestPoint(t){let tt=t[0];for(let ta=1;ta<t.length;ta++)t[ta].y<tt.y&&(tt=t[ta]);return tt}static pointWithMinAngleWithSegment(t,tt,ta){let th=i.MAX_VALUE,tu=null;for(let tc=0;tc<t.length;tc++){let tg=t[tc];if(tg===tt||tg===ta)continue;let t_=re.angleBetween(tt,tg,ta);t_<th&&(th=t_,tu=tg)}return tu}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}let t=this._extremalPts[0],tt=this._extremalPts[1];return this._input.getFactory().createLineString([t,tt])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=[].fill(null),null;if(1===this._input.getNumPoints()){let t=this._input.getCoordinates();return this._extremalPts=[new g(t[0])],null}let t=this._input.convexHull().getCoordinates(),tt=t;if(t[0].equals2D(t[t.length-1])&&(tt=Array(t.length-1).fill(null),X.copyDeep(t,0,tt,0,t.length-1)),tt.length<=2)return this._extremalPts=X.copyDeep(tt),null;let ta=pn.lowestPoint(tt),th=pn.pointWitMinAngleWithX(tt,ta);for(let t=0;t<tt.length;t++){let t=pn.pointWithMinAngleWithSegment(tt,ta,th);if(re.isObtuse(ta,t,th))return this._extremalPts=[new g(ta),new g(th)],null;if(re.isObtuse(t,ta,th))ta=t;else{if(!re.isObtuse(t,th,ta))return this._extremalPts=[new g(ta),new g(th),new g(t)],null;th=t}}u.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getFarthestPoints(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}let t=this._extremalPts[0],tt=this._extremalPts[this._extremalPts.length-1];return this._input.getFactory().createLineString([t,tt])}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();let t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new g((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=oe.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}getClass(){return pn}get interfaces_(){return[]}};pn.constructor_=function(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;let t=arguments[0];this._input=t};let mn=class mn{constructor(){mn.constructor_.apply(this,arguments)}static nextIndex(t,tt){return++tt>=t.length&&(tt=0),tt}static computeC(t,tt,ta){return t*ta.y-tt*ta.x}static getMinimumDiameter(t){return new mn(t).getDiameter()}static getMinimumRectangle(t){return new mn(t).getMinimumRectangle()}static computeSegmentForLine(t,tt,ta){let th=null,tu=null;return Math.abs(tt)>Math.abs(t)?(th=new g(0,ta/tt),tu=new g(1,ta/tt-t/tt)):(th=new g(ta/t,0),tu=new g(ta/t-tt/t,1)),new ne(th,tu)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();let t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof Mt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=i.MAX_VALUE;let tt=1,ta=new ne;for(let th=0;th<t.length-1;th++)ta.p0=t[th],ta.p1=t[th+1],tt=this.findMaxPerpDistance(t,ta,tt)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{let t=new cn(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,tt,ta){let th=tt.distancePerpendicular(t[ta]),tu=th,tc=ta,tg=tc;for(;tu>=th;)th=tu,tc=tg,tg=mn.nextIndex(t,tc),tu=tt.distancePerpendicular(t[tg]);return th<this._minWidth&&(this._minPtIndex=tc,this._minWidth=th,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new ne(tt)),tc}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());let t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,tt=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y,ta=i.MAX_VALUE,th=-i.MAX_VALUE,tu=i.MAX_VALUE,tc=-i.MAX_VALUE;for(let tg=0;tg<this._convexHullPts.length;tg++){let t_=mn.computeC(t,tt,this._convexHullPts[tg]);t_>th&&(th=t_),t_<ta&&(ta=t_);let td=mn.computeC(-tt,t,this._convexHullPts[tg]);td>tc&&(tc=td),td<tu&&(tu=td)}let tg=mn.computeSegmentForLine(-t,-tt,tc),t_=mn.computeSegmentForLine(-t,-tt,tu),td=mn.computeSegmentForLine(-tt,t,th),tp=mn.computeSegmentForLine(-tt,t,ta),tf=td.lineIntersection(tg),tm=tp.lineIntersection(tg),ty=tp.lineIntersection(t_),tx=td.lineIntersection(t_),tE=this._inputGeom.getFactory().createLinearRing([tf,tm,ty,tx,tf]);return this._inputGeom.getFactory().createPolygon(tE)}getClass(){return mn}get interfaces_(){return[]}};mn.constructor_=function(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new ne,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1==arguments.length){let t=arguments[0];mn.constructor_.call(this,t,!1)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._inputGeom=t,this._isConvex=tt}};var tp=Object.freeze({__proto__:null,distance:tg,locate:t_,match:td,Angle:re,Area:Ot,Centroid:rn,ConvexHull:cn,Distance:D,InteriorPointArea:un,InteriorPointLine:dn,InteriorPointPoint:_n,Length:xt,Orientation:v,PointLocation:je,PointLocator:fn,RobustLineIntersector:ee,MinimumBoundingCircle:pn,MinimumDiameter:mn});let xn=class xn{constructor(){xn.constructor_.apply(this,arguments)}static densifyPoints(t,tt,ta){let th=new ne,tu=new I;for(let tc=0;tc<t.length-1;tc++){th.p0=t[tc],th.p1=t[tc+1],tu.add(th.p0,!1);let tg=th.getLength(),t_=Math.trunc(tg/tt)+1;if(t_>1){let t=tg/t_;for(let tt=1;tt<t_;tt++){let tc=tt*t/tg,t_=th.pointAlong(tc);ta.makePrecise(t_),tu.add(t_,!1)}}}return tu.add(t[t.length-1],!1),tu.toCoordinateArray()}static densify(t,tt){let ta=new xn(t);return ta.setDistanceTolerance(tt),ta.getResultGeometry()}getResultGeometry(){return new En(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new n("Tolerance must be positive");this._distanceTolerance=t}getClass(){return xn}get interfaces_(){return[]}};let En=class En extends ye{constructor(){super(),En.constructor_.apply(this,arguments)}transformMultiPolygon(t,tt){let ta=super.transformMultiPolygon.call(this,t,tt);return this.createValidArea(ta)}transformPolygon(t,tt){let ta=super.transformPolygon.call(this,t,tt);return tt instanceof Ft?ta:this.createValidArea(ta)}transformCoordinates(t,tt){let ta=t.toCoordinateArray(),th=xn.densifyPoints(ta,this.distanceTolerance,tt.getPrecisionModel());return tt instanceof Rt&&1===th.length&&(th=[].fill(null)),this._factory.getCoordinateSequenceFactory().create(th)}createValidArea(t){return t.buffer(0)}getClass(){return En}get interfaces_(){return[]}};En.constructor_=function(){this.distanceTolerance=null;let t=arguments[0];this.distanceTolerance=t},xn.DensifyTransformer=En,xn.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null;let t=arguments[0];this._inputGeom=t};var tf=Object.freeze({__proto__:null,Densifier:xn});let Nn=class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static isNorthern(t){return t===Nn.NE||t===Nn.NW}static isOpposite(t,tt){return t!==tt&&2==(t-tt+4)%4}static commonHalfPlane(t,tt){if(t===tt)return t;if(2==(t-tt+4)%4)return -1;let ta=t<tt?t:tt;return 0===ta&&3===(t>tt?t:tt)?3:ta}static isInHalfPlane(t,tt){return tt===Nn.SE?t===Nn.SE||t===Nn.SW:t===tt||t===tt+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];if(0===t&&0===tt)throw new n("Cannot compute the quadrant for point ( "+t+", "+tt+" )");return t>=0?tt>=0?Nn.NE:Nn.SE:tt>=0?Nn.NW:Nn.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1];if(tt.x===t.x&&tt.y===t.y)throw new n("Cannot compute the quadrant for two identical points "+t);return tt.x>=t.x?tt.y>=t.y?Nn.NE:Nn.SE:tt.y>=t.y?Nn.NW:Nn.SW}}getClass(){return Nn}get interfaces_(){return[]}};Nn.constructor_=function(){},Nn.NE=0,Nn.NW=1,Nn.SW=2,Nn.SE=3;let Cn=class Cn{constructor(){Cn.constructor_.apply(this,arguments)}static init(t,tt){if(null!==t._sym||null!==tt._sym||null!==t._next||null!==tt._next)throw new IllegalStateException("Edges are already initialized");return t.init(tt),t}static create(t,tt){let ta=new Cn(t),th=new Cn(tt);return ta.init(th),ta}find(t){let tt=this;do{if(null===tt)break;if(tt.dest().equals2D(t))return tt;tt=tt.oNext()}while(tt!==this);return null}dest(){return this._sym._orig}oNext(){return this._sym._next}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;let tt=this.compareTo(t),ta=this;do{let th=ta.oNext();if(th.compareTo(t)!==tt||th===this)return ta.insertAfter(t),null;ta=th}while(ta!==this);u.shouldNeverReachHere()}insertAfter(t){u.equals(this._orig,t.orig());let tt=this.oNext();this._sym.setNext(t),t.sym().setNext(tt)}degree(){let t=0,tt=this;do t++,tt=tt.oNext();while(tt!==this);return t}equals(){if(2==arguments.length&&arguments[1]instanceof g&&arguments[0]instanceof g){let t=arguments[0],tt=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(tt)}}deltaY(){return this._sym._orig.y-this._orig.y}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){let tt=this.deltaX(),ta=this.deltaY(),th=t.deltaX(),tu=t.deltaY();if(tt===th&&ta===tu)return 0;let tc=Nn.quadrant(tt,ta),tg=Nn.quadrant(th,tu);return tc>tg?1:tc<tg?-1:v.index(t._orig,t.dest(),this.dest())}prevNode(){let t=this;for(;2===t.degree();)if((t=t.prev())===this)return null;return t}compareTo(t){return this.compareAngularDirection(t)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}setNext(t){this._next=t}init(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}deltaX(){return this._sym._orig.x-this._orig.x}getClass(){return Cn}get interfaces_(){return[]}};Cn.constructor_=function(){this._orig=null,this._sym=null,this._next=null;let t=arguments[0];this._orig=t};let Sn=class Sn extends Cn{constructor(){super(),Sn.constructor_.apply(this,arguments)}static setMarkBoth(t,tt){t.setMark(tt),t.sym().setMark(tt)}static isMarked(t){return t.isMarked()}static setMark(t,tt){t.setMark(tt)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}getClass(){return Sn}get interfaces_(){return[]}};Sn.constructor_=function(){this._isMarked=!1;let t=arguments[0];Cn.constructor_.call(this,t)};let wn=class wn{constructor(){wn.constructor_.apply(this,arguments)}static isValidEdge(t,tt){return 0!==tt.compareTo(t)}insert(t,tt,ta){let th=this.create(t,tt);null!==ta?ta.insert(th):this._vertexMap.put(t,th);let tu=this._vertexMap.get(tt);return null!==tu?tu.insert(th.sym()):this._vertexMap.put(tt,th.sym()),th}create(t,tt){let ta=this.createEdge(t),th=this.createEdge(tt);return Cn.init(ta,th),ta}createEdge(t){return new Cn(t)}addEdge(t,tt){if(!wn.isValidEdge(t,tt))return null;let ta=this._vertexMap.get(t),th=null;return(null!==ta&&(th=ta.find(tt)),null!==th)?th:this.insert(t,tt,ta)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,tt){let ta=this._vertexMap.get(t);return null===ta?null:ta.find(tt)}getClass(){return wn}get interfaces_(){return[]}};wn.constructor_=function(){this._vertexMap=new kt};let Ln=class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}setStart(){this._isStart=!0}isStart(){return this._isStart}getClass(){return Ln}get interfaces_(){return[]}};Ln.constructor_=function(){this._isStart=!1;let t=arguments[0];Sn.constructor_.call(this,t)};let Tn=class Tn extends wn{constructor(){super(),Tn.constructor_.apply(this,arguments)}createEdge(t){return new Ln(t)}getClass(){return Tn}get interfaces_(){return[]}};Tn.constructor_=function(){};let Rn=class Rn{constructor(){Rn.constructor_.apply(this,arguments)}static dissolve(t){let tt=new Rn;return tt.add(t),tt.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(0>t.orig().compareTo(this._ringStartEdge.orig())&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let tt=t.prevNode();null===tt&&(tt=t),this.stackEdges(tt),this.buildLines()}buildRing(t){let tt=new I,ta=t;for(tt.add(ta.orig().copy(),!1);2===ta.sym().degree();){let th=ta.next();if(th===t)break;tt.add(th.orig().copy(),!1),ta=th}tt.add(ta.dest().copy(),!1),this.addLine(tt)}buildLine(t){let tt=new I,ta=t;for(this._ringStartEdge=null,Sn.markBoth(ta),tt.add(ta.orig().copy(),!1);2===ta.sym().degree();){this.updateRingStartEdge(ta);let th=ta.next();if(th===t)return this.buildRing(this._ringStartEdge),null;tt.add(th.orig().copy(),!1),ta=th,Sn.markBoth(ta)}tt.add(ta.dest().clone(),!1),this.stackEdges(ta.sym()),this.addLine(tt)}stackEdges(t){let tt=t;do Sn.isMarked(tt)||this._nodeEdgeStack.add(tt),tt=tt.oNext();while(tt!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){let tt=t.next();Sn.isMarked(tt)||this.process(tt)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){let t=this._nodeEdgeStack.pop();Sn.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof q)arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Rt&&this.add(t)}});else if(_(arguments[0],f))for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.add(tt)}else if(arguments[0]instanceof Rt){let t=arguments[0];null===this._factory&&(this._factory=t.getFactory());let tt=t.getCoordinateSequence(),ta=!1;for(let t=1;t<tt.size();t++){let th=this._graph.addEdge(tt.getCoordinate(t-1),tt.getCoordinate(t));null!==th&&(ta||(th.setStart(),ta=!0))}}}getClass(){return Rn}get interfaces_(){return[]}};Rn.constructor_=function(){this._result=null,this._factory=null,this._graph=null,this._lines=new x,this._nodeEdgeStack=new ln,this._ringStartEdge=null,this._graph=new Tn};var tm=Object.freeze({__proto__:null,LineDissolver:Rn});let vn=class vn{constructor(){vn.constructor_.apply(this,arguments)}static opposite(t){return t===vn.LEFT?vn.RIGHT:t===vn.RIGHT?vn.LEFT:t}getClass(){return vn}get interfaces_(){return[]}};vn.constructor_=function(){},vn.ON=0,vn.LEFT=1,vn.RIGHT=2;let On=class On{constructor(){On.constructor_.apply(this,arguments)}computeIntersections(t,tt){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,tt)}getClass(){return On}get interfaces_(){return[]}};On.constructor_=function(){this.mce=null,this.chainIndex=null;let t=arguments[0],tt=arguments[1];this.mce=t,this.chainIndex=tt};let bn=class bn{constructor(){bn.constructor_.apply(this,arguments)}isDelete(){return this._eventType===bn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){return this._xValue<t._xValue?-1:this._xValue>t._xValue?1:this._eventType<t._eventType?-1:this._eventType>t._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===bn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}getClass(){return bn}get interfaces_(){return[r]}};bn.constructor_=function(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2==arguments.length){let t=arguments[0],tt=arguments[1];this._eventType=bn.DELETE,this._xValue=t,this._insertEvent=tt}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._eventType=bn.INSERT,this._label=t,this._xValue=tt,this._obj=ta}},bn.INSERT=1,bn.DELETE=2;let Mn=class Mn{constructor(){Mn.constructor_.apply(this,arguments)}getClass(){return Mn}get interfaces_(){return[]}};Mn.constructor_=function(){};let Dn=class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static isAdjacentSegments(t,tt){return 1===Math.abs(t-tt)}isTrivialIntersection(t,tt,ta,th){if(t===ta&&1===this._li.getIntersectionNum()){if(Dn.isAdjacentSegments(tt,th))return!0;if(t.isClosed()){let ta=t.getNumPoints()-1;if(0===tt&&th===ta||0===th&&tt===ta)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,tt){for(let ta=tt.iterator();ta.hasNext();){let tt=ta.next().getCoordinate();if(t.isIntersection(tt))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,tt){return null!==tt&&(!!this.isBoundaryPointInternal(t,tt[0])||!!this.isBoundaryPointInternal(t,tt[1]))}setBoundaryNodes(t,tt){this._bdyNodes=[,,].fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=tt}addIntersections(t,tt,ta,th){if(t===ta&&tt===th)return null;this.numTests++;let tu=t.getCoordinates()[tt],tc=t.getCoordinates()[tt+1],tg=ta.getCoordinates()[th],t_=ta.getCoordinates()[th+1];this._li.computeIntersection(tu,tc,tg,t_),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),ta.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,tt,ta,th)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,tt,0),ta.addIntersections(this._li,th,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getClass(){return Dn}get interfaces_(){return[]}};Dn.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._li=t,this._includeProper=tt,this._recordIsolated=ta};let An=class An extends Mn{constructor(){super(),An.constructor_.apply(this,arguments)}prepareEvents(){tu.sort(this.events);for(let t=0;t<this.events.size();t++){let tt=this.events.get(t);tt.isDelete()&&tt.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1==arguments.length){let t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let tt=0;tt<this.events.size();tt++){let ta=this.events.get(tt);if(ta.isInsert()&&this.processOverlaps(tt,ta.getDeleteEventIndex(),ta,t),t.isDone())break}}else if(3==arguments.length){if(arguments[2]instanceof Dn&&_(arguments[0],m)&&_(arguments[1],m)){let t=arguments[0],tt=arguments[1],ta=arguments[2];this.addEdges(t,t),this.addEdges(tt,tt),this.computeIntersections(ta)}else if("boolean"==typeof arguments[2]&&_(arguments[0],m)&&arguments[1]instanceof Dn){let t=arguments[0],tt=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(tt)}}}addEdge(t,tt){let ta=t.getMonotoneChainEdge(),th=ta.getStartIndexes();for(let t=0;t<th.length-1;t++){let th=new On(ta,t),tu=new bn(tt,ta.getMinX(t),th);this.events.add(tu),this.events.add(new bn(ta.getMaxX(t),tu))}}processOverlaps(t,tt,ta,th){let tu=ta.getObject();for(let tc=t;tc<tt;tc++){let t=this.events.get(tc);if(t.isInsert()){let tt=t.getObject();ta.isSameLabel(t)||(tu.computeIntersections(tt,th),this.nOverlaps++)}}}addEdges(){if(1==arguments.length)for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.addEdge(tt,tt)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];for(let ta=t.iterator();ta.hasNext();){let t=ta.next();this.addEdge(t,tt)}}}getClass(){return An}get interfaces_(){return[]}};An.constructor_=function(){this.events=new x,this.nOverlaps=null};let Fn=class Fn{constructor(){Fn.constructor_.apply(this,arguments)}setAllLocations(t){for(let tt=0;tt<this.location.length;tt++)this.location[tt]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==se.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let tt=0;tt<this.location.length;tt++)this.location[tt]===se.NONE&&(this.location[tt]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){let t=[,,,].fill(null);t[vn.ON]=this.location[vn.ON],t[vn.LEFT]=se.NONE,t[vn.RIGHT]=se.NONE,this.location=t}for(let tt=0;tt<this.location.length;tt++)this.location[tt]===se.NONE&&tt<t.location.length&&(this.location[tt]=t.location[tt])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;let t=this.location[vn.LEFT];this.location[vn.LEFT]=this.location[vn.RIGHT],this.location[vn.RIGHT]=t}toString(){let t=new w;return this.location.length>1&&t.append(se.toLocationSymbol(this.location[vn.LEFT])),t.append(se.toLocationSymbol(this.location[vn.ON])),this.location.length>1&&t.append(se.toLocationSymbol(this.location[vn.RIGHT])),t.toString()}setLocations(t,tt,ta){this.location[vn.ON]=t,this.location[vn.LEFT]=tt,this.location[vn.RIGHT]=ta}get(t){return t<this.location.length?this.location[t]:se.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===se.NONE)return!0;return!1}setLocation(){if(1==arguments.length){let t=arguments[0];this.setLocation(vn.ON,t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.location[t]=tt}}init(t){this.location=Array(t).fill(null),this.setAllLocations(se.NONE)}isEqualOnSide(t,tt){return this.location[tt]===t.location[tt]}allPositionsEqual(t){for(let tt=0;tt<this.location.length;tt++)if(this.location[tt]!==t)return!1;return!0}getClass(){return Fn}get interfaces_(){return[]}};Fn.constructor_=function(){if(this.location=null,1==arguments.length){if(arguments[0]instanceof Array){let t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){let t=arguments[0];this.init(1),this.location[vn.ON]=t}else if(arguments[0]instanceof Fn){let t=arguments[0];if(this.init(t.location.length),null!==t)for(let tt=0;tt<this.location.length;tt++)this.location[tt]=t.location[tt]}}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this.init(3),this.location[vn.ON]=t,this.location[vn.LEFT]=tt,this.location[vn.RIGHT]=ta}};let Gn=class Gn{constructor(){Gn.constructor_.apply(this,arguments)}static toLineLabel(t){let tt=new Gn(se.NONE);for(let ta=0;ta<2;ta++)tt.setLocation(ta,t.getLocation(ta));return tt}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,tt){this.elt[t].setAllLocations(tt)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1==arguments.length){let t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.elt[t].setAllLocationsIfNull(tt)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let tt=0;tt<2;tt++)null===this.elt[tt]&&null!==t.elt[tt]?this.elt[tt]=new Fn(t.elt[tt]):this.elt[tt].merge(t.elt[tt])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1==arguments.length){let t=arguments[0];return this.elt[t].get(vn.ON)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this.elt[t].get(tt)}}toString(){let t=new w;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0==arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1==arguments.length){let t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.elt[t].setLocation(vn.ON,tt)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this.elt[t].setLocation(tt,ta)}}isEqualOnSide(t,tt){return this.elt[0].isEqualOnSide(t.elt[0],tt)&&this.elt[1].isEqualOnSide(t.elt[1],tt)}allPositionsEqual(t,tt){return this.elt[t].allPositionsEqual(tt)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Fn(this.elt[t].location[0]))}getClass(){return Gn}get interfaces_(){return[]}};Gn.constructor_=function(){if(this.elt=[,,].fill(null),1==arguments.length){if(Number.isInteger(arguments[0])){let t=arguments[0];this.elt[0]=new Fn(t),this.elt[1]=new Fn(t)}else if(arguments[0]instanceof Gn){let t=arguments[0];this.elt[0]=new Fn(t.elt[0]),this.elt[1]=new Fn(t.elt[1])}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.elt[0]=new Fn(se.NONE),this.elt[1]=new Fn(se.NONE),this.elt[t].setLocation(tt)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this.elt[0]=new Fn(t,tt,ta),this.elt[1]=new Fn(t,tt,ta)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this.elt[0]=new Fn(se.NONE,se.NONE,se.NONE),this.elt[1]=new Fn(se.NONE,se.NONE,se.NONE),this.elt[t].setLocations(tt,ta,th)}};let qn=class qn{constructor(){qn.constructor_.apply(this,arguments)}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){return this.compare(t.segmentIndex,t.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,tt){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<tt?-1:this.dist>tt?1:0}getClass(){return qn}get interfaces_(){return[r]}};qn.constructor_=function(){this.coord=null,this.segmentIndex=null,this.dist=null;let t=arguments[0],tt=arguments[1],ta=arguments[2];this.coord=new g(t),this.segmentIndex=tt,this.dist=ta};let Bn=class Bn{constructor(){Bn.constructor_.apply(this,arguments)}print(t){t.println("Intersections:");for(let tt=this.iterator();tt.hasNext();)tt.next().print(t)}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();let tt=this.iterator(),ta=tt.next();for(;tt.hasNext();){let th=tt.next(),tu=this.createSplitEdge(ta,th);t.add(tu),ta=th}}addEndpoints(){let t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,tt){let ta=tt.segmentIndex-t.segmentIndex+2,th=this.edge.pts[tt.segmentIndex],tu=tt.dist>0||!tt.coord.equals2D(th);tu||ta--;let tc=Array(ta).fill(null),tg=0;tc[tg++]=new g(t.coord);for(let ta=t.segmentIndex+1;ta<=tt.segmentIndex;ta++)tc[tg++]=this.edge.pts[ta];return tu&&(tc[tg]=tt.coord),new kn(tc,new Gn(this.edge._label))}add(t,tt,ta){let th=new qn(t,tt,ta),tu=this._nodeMap.get(th);return null!==tu?tu:(this._nodeMap.put(th,th),th)}isIntersection(t){for(let tt=this.iterator();tt.hasNext();)if(tt.next().coord.equals(t))return!0;return!1}getClass(){return Bn}get interfaces_(){return[]}};Bn.constructor_=function(){this._nodeMap=new ot,this.edge=null;let t=arguments[0];this.edge=t};let Vn=class Vn{constructor(){Vn.constructor_.apply(this,arguments)}static toIntArray(t){let tt=Array(t.size()).fill(null);for(let ta=0;ta<tt.length;ta++)tt[ta]=t.get(ta).intValue();return tt}getChainStartIndices(t){let tt=0,ta=new x;ta.add(new L(tt));do{let th=this.findChainEnd(t,tt);ta.add(new L(th)),tt=th}while(tt<t.length-1);return Vn.toIntArray(ta)}findChainEnd(t,tt){let ta=Nn.quadrant(t[tt],t[tt+1]),th=tt+1;for(;th<t.length&&Nn.quadrant(t[th-1],t[th])===ta;)th++;return th-1}getClass(){return Vn}get interfaces_(){return[]}};Vn.constructor_=function(){};let zn=class zn{constructor(){zn.constructor_.apply(this,arguments)}getCoordinates(){return this.pts}getMaxX(t){let tt=this.pts[this.startIndex[t]].x,ta=this.pts[this.startIndex[t+1]].x;return tt>ta?tt:ta}getMinX(t){let tt=this.pts[this.startIndex[t]].x,ta=this.pts[this.startIndex[t+1]].x;return tt<ta?tt:ta}computeIntersectsForChain(){if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],tt,tt.startIndex[ta],tt.startIndex[ta+1],th)}else if(6==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];if(tt-t==1&&tu-th==1)return tc.addIntersections(this.e,t,ta.e,th),null;if(!this.overlaps(t,tt,ta,th,tu))return null;let tg=Math.trunc((t+tt)/2),t_=Math.trunc((th+tu)/2);t<tg&&(th<t_&&this.computeIntersectsForChain(t,tg,ta,th,t_,tc),t_<tu&&this.computeIntersectsForChain(t,tg,ta,t_,tu,tc)),tg<tt&&(th<t_&&this.computeIntersectsForChain(tg,tt,ta,th,t_,tc),t_<tu&&this.computeIntersectsForChain(tg,tt,ta,t_,tu,tc))}}overlaps(t,tt,ta,th,tu){return N.intersects(this.pts[t],this.pts[tt],ta.pts[th],ta.pts[tu])}getStartIndexes(){return this.startIndex}computeIntersects(t,tt){for(let ta=0;ta<this.startIndex.length-1;ta++)for(let th=0;th<t.startIndex.length-1;th++)this.computeIntersectsForChain(ta,t,th,tt)}getClass(){return zn}get interfaces_(){return[]}};zn.constructor_=function(){this.e=null,this.pts=null,this.startIndex=null;let t=arguments[0];this.e=t,this.pts=t.getCoordinates();let tt=new Vn;this.startIndex=tt.getChainStartIndices(this.pts)};let Yn=class Yn{constructor(){Yn.constructor_.apply(this,arguments)}static depthAtLocation(t){return t===se.EXTERIOR?0:t===se.INTERIOR?1:Yn.NULL_VALUE}getDepth(t,tt){return this._depth[t][tt]}setDepth(t,tt,ta){this._depth[t][tt]=ta}isNull(){if(0==arguments.length){for(let t=0;t<2;t++)for(let tt=0;tt<3;tt++)if(this._depth[t][tt]!==Yn.NULL_VALUE)return!1;return!0}if(1==arguments.length){let t=arguments[0];return this._depth[t][1]===Yn.NULL_VALUE}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this._depth[t][tt]===Yn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let tt=this._depth[t][1];this._depth[t][2]<tt&&(tt=this._depth[t][2]),tt<0&&(tt=0);for(let ta=1;ta<3;ta++){let th=0;this._depth[t][ta]>tt&&(th=1),this._depth[t][ta]=th}}}getDelta(t){return this._depth[t][vn.RIGHT]-this._depth[t][vn.LEFT]}getLocation(t,tt){return this._depth[t][tt]<=0?se.EXTERIOR:se.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1==arguments.length){let t=arguments[0];for(let tt=0;tt<2;tt++)for(let ta=1;ta<3;ta++){let th=t.getLocation(tt,ta);th!==se.EXTERIOR&&th!==se.INTERIOR||(this.isNull(tt,ta)?this._depth[tt][ta]=Yn.depthAtLocation(th):this._depth[tt][ta]+=Yn.depthAtLocation(th))}}else if(3==arguments.length){let t=arguments[0],tt=arguments[1];arguments[2]===se.INTERIOR&&this._depth[t][tt]++}}getClass(){return Yn}get interfaces_(){return[]}};Yn.constructor_=function(){this._depth=[,,].fill().map(()=>[,,,]);for(let t=0;t<2;t++)for(let tt=0;tt<3;tt++)this._depth[t][tt]=Yn.NULL_VALUE},Yn.NULL_VALUE=-1;let Un=class Un{constructor(){Un.constructor_.apply(this,arguments)}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){u.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}getClass(){return Un}get interfaces_(){return[]}};Un.constructor_=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this._label=t}};let kn=class kn extends Un{constructor(){super(),kn.constructor_.apply(this,arguments)}static updateIM(){if(!(2==arguments.length&&arguments[1]instanceof ie&&arguments[0]instanceof Gn))return super.updateIM.apply(this,arguments);{let t=arguments[0],tt=arguments[1];tt.setAtLeastIfValid(t.getLocation(0,vn.ON),t.getLocation(1,vn.ON),1),t.isArea()&&(tt.setAtLeastIfValid(t.getLocation(0,vn.LEFT),t.getLocation(1,vn.LEFT),2),tt.setAtLeastIfValid(t.getLocation(0,vn.RIGHT),t.getLocation(1,vn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){let t=[,,].fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new kn(t,Gn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof kn)||this.pts.length!==t.pts.length)return!1;let tt=!0,ta=!0,th=this.pts.length;for(let tu=0;tu<this.pts.length;tu++)if(this.pts[tu].equals2D(t.pts[tu])||(tt=!1),this.pts[tu].equals2D(t.pts[--th])||(ta=!1),!tt&&!ta)return!1;return!0}getCoordinate(){if(0==arguments.length)return this.pts.length>0?this.pts[0]:null;if(1==arguments.length){let t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let tt=0;tt<this.pts.length;tt++)tt>0&&t.print(","),t.print(this.pts[tt].x+" "+this.pts[tt].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){kn.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let tt=this.pts.length-1;tt>=0;tt--)t.print(this.pts[tt]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new zn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new N;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,tt,ta,th){let tu=new g(t.getIntersection(th)),tc=tt,tg=t.getEdgeDistance(ta,th),t_=tc+1;if(t_<this.pts.length){let t=this.pts[t_];tu.equals2D(t)&&(tc=t_,tg=0)}this.eiList.add(tu,tc,tg)}toString(){let t=new Lt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let tt=0;tt<this.pts.length;tt++)tt>0&&t.append(","),t.append(this.pts[tt].x+" "+this.pts[tt].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let tt=0;tt<this.pts.length;tt++)if(!this.pts[tt].equals2D(t.pts[tt]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,tt,ta){for(let th=0;th<t.getIntersectionNum();th++)this.addIntersection(t,tt,ta,th)}getClass(){return kn}get interfaces_(){return[]}};kn.constructor_=function(){if(this.pts=null,this._env=null,this.eiList=new Bn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Yn,this._depthDelta=0,1==arguments.length){let t=arguments[0];kn.constructor_.call(this,t,null)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.pts=t,this._label=tt}};let Xn=class Xn extends Un{constructor(){super(),Xn.constructor_.apply(this,arguments)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();)if(t.next().getEdge().isInResult())return!0;return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,tt){let ta=se.NONE;if(ta=this._label.getLocation(tt),!t.isNull(tt)){let th=t.getLocation(tt);ta!==se.BOUNDARY&&(ta=th)}return ta}setLabel(){if(2!=arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{let t=arguments[0],tt=arguments[1];null===this._label?this._label=new Gn(t,tt):this._label.setLocation(t,tt)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof Xn){let t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Gn){let t=arguments[0];for(let tt=0;tt<2;tt++){let ta=this.computeMergedLocation(t,tt);this._label.getLocation(tt)===se.NONE&&this._label.setLocation(tt,ta)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let tt=se.NONE;null!==this._label&&(tt=this._label.getLocation(t));let ta=null;switch(tt){case se.BOUNDARY:ta=se.INTERIOR;break;case se.INTERIOR:default:ta=se.BOUNDARY}this._label.setLocation(t,ta)}getClass(){return Xn}get interfaces_(){return[]}};Xn.constructor_=function(){this._coord=null,this._edges=null;let t=arguments[0],tt=arguments[1];this._coord=t,this._edges=tt,this._label=new Gn(0,se.NONE)};let Hn=class Hn{constructor(){Hn.constructor_.apply(this,arguments)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof g){let t=arguments[0],tt=this.nodeMap.get(t);return null===tt&&(tt=this.nodeFact.createNode(t),this.nodeMap.put(t,tt)),tt}if(arguments[0]instanceof Xn){let t=arguments[0],tt=this.nodeMap.get(t.getCoordinate());return null===tt?(this.nodeMap.put(t.getCoordinate(),t),t):(tt.mergeLabel(t),tt)}}print(t){for(let tt=this.iterator();tt.hasNext();)tt.next().print(t)}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){let tt=new x;for(let ta=this.iterator();ta.hasNext();){let th=ta.next();th.getLabel().getLocation(t)===se.BOUNDARY&&tt.add(th)}return tt}add(t){let tt=t.getCoordinate();this.addNode(tt).add(t)}getClass(){return Hn}get interfaces_(){return[]}};Hn.constructor_=function(){this.nodeMap=new ot,this.nodeFact=null;let t=arguments[0];this.nodeFact=t};let Wn=class Wn{constructor(){Wn.constructor_.apply(this,arguments)}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){let tt=Math.atan2(this._dy,this._dx),ta=this.getClass().getName(),th=ta.lastIndexOf("."),tu=ta.substring(th+1);t.print("  "+tu+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+tt+"   "+this._label)}compareTo(t){return this.compareDirection(t)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){let t=Math.atan2(this._dy,this._dx),tt=this.getClass().getName(),ta=tt.lastIndexOf(".");return"  "+tt.substring(ta+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,tt){this._p0=t,this._p1=tt,this._dx=tt.x-t.x,this._dy=tt.y-t.y,this._quadrant=Nn.quadrant(this._dx,this._dy),u.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getClass(){return Wn}get interfaces_(){return[r]}};Wn.constructor_=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1==arguments.length){let t=arguments[0];this._edge=t}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];Wn.constructor_.call(this,t,tt,ta,null)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];Wn.constructor_.call(this,t),this.init(tt,ta),this._label=th}};let jn=class jn extends c{constructor(){if(1==arguments.length){let t=arguments[0];super(t),c.call(this,t)}else{if(2!=arguments.length)throw Error();{let t=arguments[0],tt=arguments[1];super(jn.msgWithCoord(t,tt)),this.name="TopologyException",this.pt=new g(tt)}}}getCoordinate(){return this.pt}get interfaces_(){return[]}getClass(){return jn}static msgWithCoord(t,tt){return null!==tt?t+" [ "+tt+" ]":t}};let Kn=class Kn extends Wn{constructor(){super(),Kn.constructor_.apply(this,arguments)}static depthFactor(t,tt){return t===se.EXTERIOR&&tt===se.INTERIOR?1:t===se.INTERIOR&&tt===se.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Gn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,tt){if(-999!==this._depth[t]&&this._depth[t]!==tt)throw new jn("assigned depths do not match",this.getCoordinate());this._depth[t]=tt}isInteriorAreaEdge(){let t=!0;for(let tt=0;tt<2;tt++)this._label.isArea(tt)&&this._label.getLocation(tt,vn.LEFT)===se.INTERIOR&&this._label.getLocation(tt,vn.RIGHT)===se.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[vn.LEFT]+"/"+this._depth[vn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){let t=this._label.isLine(0)||this._label.isLine(1),tt=!this._label.isArea(0)||this._label.allPositionsEqual(0,se.EXTERIOR),ta=!this._label.isArea(1)||this._label.allPositionsEqual(1,se.EXTERIOR);return t&&tt&&ta}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,tt){let ta=this.getEdge().getDepthDelta();this._isForward||(ta=-ta);let th=1;t===vn.LEFT&&(th=-1);let tu=vn.opposite(t),tc=tt+ta*th;this.setDepth(t,tt),this.setDepth(tu,tc)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}getClass(){return Kn}get interfaces_(){return[]}};Kn.constructor_=function(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];let t=arguments[0],tt=arguments[1];if(Wn.constructor_.call(this,t),this._isForward=tt,tt)this.init(t.getCoordinate(0),t.getCoordinate(1));else{let tt=t.getNumPoints()-1;this.init(t.getCoordinate(tt),t.getCoordinate(tt-1))}this.computeDirectedLabel()};let Zn=class Zn{constructor(){Zn.constructor_.apply(this,arguments)}createNode(t){return new Xn(t,null)}getClass(){return Zn}get interfaces_(){return[]}};Zn.constructor_=function(){};let Qn=class Qn{constructor(){Qn.constructor_.apply(this,arguments)}static linkResultDirectedEdges(t){for(let tt=t.iterator();tt.hasNext();)tt.next().getEdges().linkResultDirectedEdges()}printEdges(t){t.println("Edges:");for(let tt=0;tt<this._edges.size();tt++){t.println("edge "+tt+":");let ta=this._edges.get(tt);ta.print(t),ta.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof Xn){let t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof g){let t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();)t.next().getEdges().linkResultDirectedEdges()}debugPrintln(t){O.out.println(t)}isBoundaryNode(t,tt){let ta=this._nodes.find(tt);if(null===ta)return!1;let th=ta.getLabel();return null!==th&&th.getLocation(t)===se.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();)t.next().getEdges().linkAllDirectedEdges()}matchInSameDirection(t,tt,ta,th){return!!t.equals(ta)&&v.index(t,tt,th)===v.COLLINEAR&&Nn.quadrant(t,tt)===Nn.quadrant(ta,th)}getEdgeEnds(){return this._edgeEndList}debugPrint(t){O.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,tt){for(let ta=0;ta<this._edges.size();ta++){let th=this._edges.get(ta),tu=th.getCoordinates();if(this.matchInSameDirection(t,tt,tu[0],tu[1])||this.matchInSameDirection(t,tt,tu[tu.length-1],tu[tu.length-2]))return th}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let tt=this.getEdgeEnds().iterator();tt.hasNext();){let ta=tt.next();if(ta.getEdge()===t)return ta}return null}addEdges(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this._edges.add(t);let ta=new Kn(t,!0),th=new Kn(t,!1);ta.setSym(th),th.setSym(ta),this.add(ta),this.add(th)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,tt){for(let ta=0;ta<this._edges.size();ta++){let th=this._edges.get(ta),tu=th.getCoordinates();if(t.equals(tu[0])&&tt.equals(tu[1]))return th}return null}getClass(){return Qn}get interfaces_(){return[]}};Qn.constructor_=function(){if(this._edges=new x,this._nodes=null,this._edgeEndList=new x,0==arguments.length)this._nodes=new Hn(new Zn);else if(1==arguments.length){let t=arguments[0];this._nodes=new Hn(t)}};let Jn=class Jn extends Qn{constructor(){super(),Jn.constructor_.apply(this,arguments)}static determineBoundary(t,tt){return t.isInBoundary(tt)?se.BOUNDARY:se.INTERIOR}insertBoundaryPoint(t,tt){let ta=this._nodes.addNode(tt).getLabel(),th=1;se.NONE,ta.getLocation(t,vn.ON)===se.BOUNDARY&&th++;let tu=Jn.determineBoundary(this._boundaryNodeRule,th);ta.setLocation(t,tu)}computeSelfNodes(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this.computeSelfNodes(t,tt,!1)}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=new Dn(t,!0,!1);th.setIsDoneIfProperInt(ta);let tu=this.createEdgeSetIntersector(),tc=this._parentGeom instanceof At||this._parentGeom instanceof Mt||this._parentGeom instanceof Ft,tg=tt||!tc;return tu.computeIntersections(this._edges,th,tg),this.addSelfIntersectionNodes(this._argIndex),th}}computeSplitEdges(t){for(let tt=this._edges.iterator();tt.hasNext();)tt.next().eiList.addSplitEdges(t)}computeEdgeIntersections(t,tt,ta){let th=new Dn(tt,ta,!0);return th.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,th),th}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof vt){let t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,se.INTERIOR)}else if(arguments[0]instanceof g){let t=arguments[0];this.insertPoint(this._argIndex,t,se.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),se.EXTERIOR,se.INTERIOR);for(let tt=0;tt<t.getNumInteriorRing();tt++){let ta=t.getInteriorRingN(tt);this.addPolygonRing(ta,se.INTERIOR,se.EXTERIOR)}}addEdge(t){this.insertEdge(t);let tt=t.getCoordinates();this.insertPoint(this._argIndex,tt[0],se.BOUNDARY),this.insertPoint(this._argIndex,tt[tt.length-1],se.BOUNDARY)}addLineString(t){let tt=X.removeRepeatedPoints(t.getCoordinates());if(tt.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=tt[0],null;let ta=new kn(tt,new Gn(this._argIndex,se.INTERIOR));this._lineEdgeMap.put(t,ta),this.insertEdge(ta),u.isTrue(tt.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,tt[0]),this.insertBoundaryPoint(this._argIndex,tt[tt.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){let t=this.getBoundaryNodes(),tt=Array(t.size()).fill(null),ta=0;for(let th=t.iterator();th.hasNext();){let t=th.next();tt[ta++]=t.getCoordinate().copy()}return tt}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,tt,ta){if(this.isBoundaryNode(t,tt))return null;ta===se.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,tt):this.insertPoint(t,tt,ta)}addPolygonRing(t,tt,ta){if(t.isEmpty())return null;let th=X.removeRepeatedPoints(t.getCoordinates());if(th.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=th[0],null;let tu=tt,tc=ta;v.isCCW(th)&&(tu=ta,tc=tt);let tg=new kn(th,new Gn(this._argIndex,se.BOUNDARY,tu,tc));this._lineEdgeMap.put(t,tg),this.insertEdge(tg),this.insertPoint(this._argIndex,th[0],se.BOUNDARY)}insertPoint(t,tt,ta){let th=this._nodes.addNode(tt),tu=th.getLabel();null===tu?th._label=new Gn(t,ta):tu.setLocation(t,ta)}createEdgeSetIntersector(){return new An}addSelfIntersectionNodes(t){for(let tt=this._edges.iterator();tt.hasNext();){let ta=tt.next(),th=ta.getLabel().getLocation(t);for(let tt=ta.eiList.iterator();tt.hasNext();){let ta=tt.next();this.addSelfIntersectionNode(t,ta.coord,th)}}}add(){if(!(1==arguments.length&&arguments[0]instanceof q))return super.add.apply(this,arguments);{let t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ft&&(this._useBoundaryDeterminationRule=!1),t instanceof Mt)this.addPolygon(t);else if(t instanceof Rt)this.addLineString(t);else if(t instanceof vt)this.addPoint(t);else if(t instanceof Dt)this.addCollection(t);else if(t instanceof pt)this.addCollection(t);else if(t instanceof Ft)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}}}addCollection(t){for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);this.add(ta)}}locate(t){return _(this._parentGeom,bt)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Xe(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1==arguments.length&&arguments[0]instanceof Rt){let t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}getClass(){return Jn}get interfaces_(){return[]}};Jn.constructor_=function(){if(this._parentGeom=null,this._lineEdgeMap=new kt,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new fn,2==arguments.length){let t=arguments[0],tt=arguments[1];Jn.constructor_.call(this,t,tt,V.OGC_SFS_BOUNDARY_RULE)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._argIndex=t,this._parentGeom=tt,this._boundaryNodeRule=ta,null!==tt&&this.add(tt)}};var ty=Object.freeze({__proto__:null,GeometryGraph:Jn});let ts=class ts{constructor(){ts.constructor_.apply(this,arguments)}visit(t){}getClass(){return ts}get interfaces_(){return[]}};ts.constructor_=function(){};let es=class es{constructor(){es.constructor_.apply(this,arguments)}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}getClass(){return es}get interfaces_(){return[]}};es.constructor_=function(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2==arguments.length){let t=arguments[0],tt=arguments[1];this._p=new g(t),this._left=null,this._right=null,this._count=1,this._data=tt}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._p=new g(t,tt),this._left=null,this._right=null,this._count=1,this._data=ta}};let ns=class ns{constructor(){ns.constructor_.apply(this,arguments)}static toCoordinates(){if(1==arguments.length){let t=arguments[0];return ns.toCoordinates(t,!1)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new I;for(let th=t.iterator();th.hasNext();){let t=th.next(),tu=tt?t.getCount():1;for(let tt=0;tt<tu;tt++)ta.add(t.getCoordinate(),!0)}return ta.toCoordinateArray()}}insert(){if(1==arguments.length){let t=arguments[0];return this.insert(t,null)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(null===this._root)return this._root=new es(t,tt),this._root;if(this._tolerance>0){let tt=this.findBestMatchNode(t);if(null!==tt)return tt.increment(),tt}return this.insertExact(t,tt)}}query(){if(1==arguments.length){let t=arguments[0],tt=new x;return this.query(t,tt),tt}if(2==arguments.length){if(arguments[0]instanceof N&&_(arguments[1],m)){let t=arguments[0],tt=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[ts]}visit(t){tt.add(t)}})}else if(arguments[0]instanceof N&&_(arguments[1],ts)){let t=arguments[0],tt=arguments[1];this.queryNode(this._root,t,!0,tt)}}}queryNode(t,tt,ta,th){if(null===t)return null;let tu=null,tc=null,tg=null;ta?(tu=tt.getMinX(),tc=tt.getMaxX(),tg=t.getX()):(tu=tt.getMinY(),tc=tt.getMaxY(),tg=t.getY());let t_=tg<=tc;tu<tg&&this.queryNode(t.getLeft(),tt,!ta,th),tt.contains(t.getCoordinate())&&th.visit(t),t_&&this.queryNode(t.getRight(),tt,!ta,th)}findBestMatchNode(t){let tt=new ss(t,this._tolerance);return this.query(tt.queryEnvelope(),tt),tt.getNode()}isEmpty(){return null===this._root}insertExact(t,tt){let ta=this._root,th=this._root,tu=!0,tc=!0;for(;null!==ta;){if(null!==ta&&t.distance(ta.getCoordinate())<=this._tolerance)return ta.increment(),ta;tc=tu?t.x<ta.getX():t.y<ta.getY(),th=ta,ta=tc?ta.getLeft():ta.getRight(),tu=!tu}this._numberOfNodes=this._numberOfNodes+1;let tg=new es(t,tt);return tc?th.setLeft(tg):th.setRight(tg),tg}getClass(){return ns}get interfaces_(){return[]}};let ss=class ss{constructor(){ss.constructor_.apply(this,arguments)}visit(t){let tt=this._p.distance(t.getCoordinate());if(!(tt<=this._tolerance))return null;let ta=!1;(null===this._matchNode||tt<this._matchDist||null!==this._matchNode&&tt===this._matchDist&&1>t.getCoordinate().compareTo(this._matchNode.getCoordinate()))&&(ta=!0),ta&&(this._matchNode=t,this._matchDist=tt)}queryEnvelope(){let t=new N(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}getClass(){return ss}get interfaces_(){return[ts]}};ss.constructor_=function(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;let t=arguments[0],tt=arguments[1];this._p=t,this._tolerance=tt},ns.BestMatchVisitor=ss,ns.constructor_=function(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0==arguments.length)ns.constructor_.call(this,0);else if(1==arguments.length){let t=arguments[0];this._tolerance=t}};var tx=Object.freeze({__proto__:null,KdTree:ns});let rs=class rs{constructor(){rs.constructor_.apply(this,arguments)}static getSubnodeIndex(t,tt,ta){let th=-1;return t.getMinX()>=tt&&(t.getMinY()>=ta&&(th=3),t.getMaxY()<=ta&&(th=1)),t.getMaxX()<=tt&&(t.getMinY()>=ta&&(th=2),t.getMaxY()<=ta&&(th=0)),th}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let tt=0;tt<4;tt++)null!==this._subnode[tt]&&this._subnode[tt].addAllItems(t);return t}getNodeCount(){let t=0;for(let tt=0;tt<4;tt++)null!==this._subnode[tt]&&(t+=this._subnode[tt].size());return t+1}size(){let t=0;for(let tt=0;tt<4;tt++)null!==this._subnode[tt]&&(t+=this._subnode[tt].size());return t+this._items.size()}addAllItemsFromOverlapping(t,tt){if(!this.isSearchMatch(t))return null;tt.addAll(this._items);for(let ta=0;ta<4;ta++)null!==this._subnode[ta]&&this._subnode[ta].addAllItemsFromOverlapping(t,tt)}visitItems(t,tt){for(let t=this._items.iterator();t.hasNext();)tt.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,tt){if(!this.isSearchMatch(t))return!1;let ta=!1;for(let th=0;th<4;th++)if(null!==this._subnode[th]&&(ta=this._subnode[th].remove(t,tt))){this._subnode[th].isPrunable()&&(this._subnode[th]=null);break}return ta||(ta=this._items.remove(tt))}visit(t,tt){if(!this.isSearchMatch(t))return null;this.visitItems(t,tt);for(let ta=0;ta<4;ta++)null!==this._subnode[ta]&&this._subnode[ta].visit(t,tt)}getItems(){return this._items}depth(){let t=0;for(let tt=0;tt<4;tt++)if(null!==this._subnode[tt]){let ta=this._subnode[tt].depth();ta>t&&(t=ta)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let tt=0;tt<4;tt++)if(null!==this._subnode[tt]&&!this._subnode[tt].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}getClass(){return rs}get interfaces_(){return[a]}};function os(){}rs.constructor_=function(){this._items=new x,this._subnode=[,,,,].fill(null)},os.exponent=function(t){return function(t,tt){let ta,th,tu,tc;let tg={32:8,64:11}[t];if(tc||(ta=tt<0||1/tt<0,isFinite(tt)||(tc=({32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}})[t],ta&&(tc.d+=1<<t/4-1),th=Math.pow(2,tg)-1,tu=0)),!tc){for(th=({32:127,64:1023})[t],tu=Math.abs(tt);tu>=2;)th++,tu/=2;for(;tu<1&&th>0;)th--,tu*=2;th<=0&&(tu/=2),32===t&&th>254&&(tc={d:ta?255:127,c:128,b:0,a:0},th=Math.pow(2,tg)-1,tu=0)}return th}(64,t)-1023},os.powerOf2=function(t){return Math.pow(2,t)};let ls=class ls{constructor(){ls.constructor_.apply(this,arguments)}static computeQuadLevel(t){let tt=t.getWidth(),ta=t.getHeight(),th=tt>ta?tt:ta;return os.exponent(th)+1}getLevel(){return this._level}computeKey(){if(1==arguments.length){let t=arguments[0];for(this._level=ls.computeQuadLevel(t),this._env=new N,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=os.powerOf2(t);this._pt.x=Math.floor(tt.getMinX()/ta)*ta,this._pt.y=Math.floor(tt.getMinY()/ta)*ta,this._env.init(this._pt.x,this._pt.x+ta,this._pt.y,this._pt.y+ta)}}getEnvelope(){return this._env}getCentre(){return new g((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}getClass(){return ls}get interfaces_(){return[]}};ls.constructor_=function(){this._pt=new g,this._level=0,this._env=null;let t=arguments[0];this.computeKey(t)};let as=class as extends rs{constructor(){super(),as.constructor_.apply(this,arguments)}static createNode(t){let tt=new ls(t);return new as(tt.getEnvelope(),tt.getLevel())}static createExpanded(t,tt){let ta=new N(tt);null!==t&&ta.expandToInclude(t._env);let th=as.createNode(ta);return null!==t&&th.insertNode(t),th}find(t){let tt=rs.getSubnodeIndex(t,this._centrex,this._centrey);return -1===tt?this:null!==this._subnode[tt]?this._subnode[tt].find(t):this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){let tt=rs.getSubnodeIndex(t,this._centrex,this._centrey);return -1!==tt?this.getSubnode(tt).getNode(t):this}createSubnode(t){let tt=0,ta=0,th=0,tu=0;switch(t){case 0:tt=this._env.getMinX(),ta=this._centrex,th=this._env.getMinY(),tu=this._centrey;break;case 1:tt=this._centrex,ta=this._env.getMaxX(),th=this._env.getMinY(),tu=this._centrey;break;case 2:tt=this._env.getMinX(),ta=this._centrex,th=this._centrey,tu=this._env.getMaxY();break;case 3:tt=this._centrex,ta=this._env.getMaxX(),th=this._centrey,tu=this._env.getMaxY()}let tc=new N(tt,ta,th,tu);return new as(tc,this._level-1)}insertNode(t){u.isTrue(null===this._env||this._env.contains(t._env));let tt=rs.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[tt]=t;else{let ta=this.createSubnode(tt);ta.insertNode(t),this._subnode[tt]=ta}}getClass(){return as}get interfaces_(){return[]}};as.constructor_=function(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;let t=arguments[0],tt=arguments[1];this._env=t,this._level=tt,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2};let cs=class cs{constructor(){cs.constructor_.apply(this,arguments)}static isZeroWidth(t,tt){let ta=tt-t;if(0===ta)return!0;let th=ta/Math.max(Math.abs(t),Math.abs(tt));return os.exponent(th)<=cs.MIN_BINARY_EXPONENT}getClass(){return cs}get interfaces_(){return[]}};cs.constructor_=function(){},cs.MIN_BINARY_EXPONENT=-50;let hs=class hs extends rs{constructor(){super(),hs.constructor_.apply(this,arguments)}insert(t,tt){let ta=rs.getSubnodeIndex(t,hs.origin.x,hs.origin.y);if(-1===ta)return this.add(tt),null;let th=this._subnode[ta];if(null===th||!th.getEnvelope().contains(t)){let tt=as.createExpanded(th,t);this._subnode[ta]=tt}this.insertContained(this._subnode[ta],t,tt)}isSearchMatch(t){return!0}insertContained(t,tt,ta){u.isTrue(t.getEnvelope().contains(tt));let th=cs.isZeroWidth(tt.getMinX(),tt.getMaxX()),tu=cs.isZeroWidth(tt.getMinY(),tt.getMaxY());(th||tu?t.find(tt):t.getNode(tt)).add(ta)}getClass(){return hs}get interfaces_(){return[]}};hs.constructor_=function(){},hs.origin=new g(0,0);let us=class us{constructor(){us.constructor_.apply(this,arguments)}insert(t,tt){}remove(t,tt){}query(){}getClass(){return us}get interfaces_(){return[]}};us.constructor_=function(){};let gs=class gs{constructor(){gs.constructor_.apply(this,arguments)}static ensureExtent(t,tt){let ta=t.getMinX(),th=t.getMaxX(),tu=t.getMinY(),tc=t.getMaxY();return ta!==th&&tu!==tc?t:(ta===th&&(th=(ta-=tt/2)+tt/2),tu===tc&&(tc=(tu-=tt/2)+tt/2),new N(ta,th,tu,tc))}size(){return null!==this._root?this._root.size():0}insert(t,tt){this.collectStats(t);let ta=gs.ensureExtent(t,this._minExtent);this._root.insert(ta,tt)}query(){if(1==arguments.length){let t=arguments[0],tt=new Ue;return this.query(t,tt),tt.getItems()}if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._root.visit(t,tt)}}queryAll(){let t=new x;return this._root.addAllItems(t),t}remove(t,tt){let ta=gs.ensureExtent(t,this._minExtent);return this._root.remove(ta,tt)}collectStats(t){let tt=t.getWidth();tt<this._minExtent&&tt>0&&(this._minExtent=tt);let ta=t.getHeight();ta<this._minExtent&&ta>0&&(this._minExtent=ta)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}getClass(){return gs}get interfaces_(){return[us,a]}};gs.constructor_=function(){this._root=null,this._minExtent=1,this._root=new hs},gs.serialVersionUID=-0x98749f36985dac00;var tE=Object.freeze({__proto__:null,Quadtree:gs});let _s=class _s{constructor(){_s.constructor_.apply(this,arguments)}getBounds(){}getClass(){return _s}get interfaces_(){return[]}};_s.constructor_=function(){};let fs=class fs{constructor(){fs.constructor_.apply(this,arguments)}getItem(){return this._item}getBounds(){return this._bounds}getClass(){return fs}get interfaces_(){return[_s,a]}};fs.constructor_=function(){this._bounds=null,this._item=null;let t=arguments[0],tt=arguments[1];this._bounds=t,this._item=tt};let ps=class ps{constructor(){ps.constructor_.apply(this,arguments)}poll(){if(this.isEmpty())return null;let t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let tt=null,ta=this._items.get(t);for(;2*t<=this._size&&((tt=2*t)!==this._size&&0>this._items.get(tt+1).compareTo(this._items.get(tt))&&tt++,0>this._items.get(tt).compareTo(ta));t=tt)this._items.set(t,this._items.get(tt));this._items.set(t,ta)}clear(){this._size=0,this._items.clear()}peek(){return this.isEmpty()?null:this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let tt=this._size;for(this._items.set(0,t);0>t.compareTo(this._items.get(Math.trunc(tt/2)));tt/=2)this._items.set(tt,this._items.get(Math.trunc(tt/2)));this._items.set(tt,t)}getClass(){return ps}get interfaces_(){return[]}};ps.constructor_=function(){this._size=null,this._items=null,this._size=0,this._items=new x,this._items.add(null)};let ms=class ms{constructor(){ms.constructor_.apply(this,arguments)}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){u.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}getClass(){return ms}get interfaces_(){return[_s,a]}};ms.constructor_=function(){if(this._childBoundables=new x,this._bounds=null,this._level=null,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this._level=t}},ms.serialVersionUID=0x5a1e55ec41369800;let ys=class ys{constructor(){ys.constructor_.apply(this,arguments)}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof ms}expandToQueue(t,tt){let ta=ys.isComposite(this._boundable1),th=ys.isComposite(this._boundable2);if(ta&&th)return ys.area(this._boundable1)>ys.area(this._boundable2)?this.expand(this._boundable1,this._boundable2,t,tt):this.expand(this._boundable2,this._boundable1,t,tt),null;if(ta)return this.expand(this._boundable1,this._boundable2,t,tt),null;if(th)return this.expand(this._boundable2,this._boundable1,t,tt),null;throw new n("neither boundable is composite")}isLeaves(){return!(ys.isComposite(this._boundable1)||ys.isComposite(this._boundable2))}compareTo(t){return this._distance<t._distance?-1:this._distance>t._distance?1:0}expand(t,tt,ta,th){for(let tu=t.getChildBoundables().iterator();tu.hasNext();){let t=tu.next(),tc=new ys(t,tt,this._itemDistance);tc.getDistance()<th&&ta.add(tc)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}getClass(){return ys}get interfaces_(){return[r]}};ys.constructor_=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._boundable1=t,this._boundable2=tt,this._itemDistance=ta,this._distance=this.distance()};let xs=class xs{constructor(){xs.constructor_.apply(this,arguments)}static compareDoubles(t,tt){return t>tt?1:t<tt?-1:0}queryInternal(){if(_(arguments[2],Fe)&&arguments[0]instanceof Object&&arguments[1]instanceof ms){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=tt.getChildBoundables();for(let tt=0;tt<th.size();tt++){let tu=th.get(tt);this.getIntersectsOp().intersects(tu.getBounds(),t)&&(tu instanceof ms?this.queryInternal(t,tu,ta):tu instanceof fs?ta.visitItem(tu.getItem()):u.shouldNeverReachHere())}}else if(_(arguments[2],m)&&arguments[0]instanceof Object&&arguments[1]instanceof ms){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=tt.getChildBoundables();for(let tt=0;tt<th.size();tt++){let tu=th.get(tt);this.getIntersectsOp().intersects(tu.getBounds(),t)&&(tu instanceof ms?this.queryInternal(t,tu,ta):tu instanceof fs?ta.add(tu.getItem()):u.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0==arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1==arguments.length){let t=0;for(let tt=arguments[0].getChildBoundables().iterator();tt.hasNext();){let ta=tt.next();ta instanceof ms?t+=this.size(ta):ta instanceof fs&&(t+=1)}return t}}removeItem(t,tt){let ta=null;for(let th=t.getChildBoundables().iterator();th.hasNext();){let t=th.next();t instanceof fs&&t.getItem()===tt&&(ta=t)}return null!==ta&&(t.getChildBoundables().remove(ta),!0)}itemsTree(){if(0==arguments.length){this.build();let t=this.itemsTree(this._root);return null===t?new x:t}if(1==arguments.length){let t=arguments[0],tt=new x;for(let ta=t.getChildBoundables().iterator();ta.hasNext();){let t=ta.next();if(t instanceof ms){let ta=this.itemsTree(t);null!==ta&&tt.add(ta)}else t instanceof fs?tt.add(t.getItem()):u.shouldNeverReachHere()}return 0>=tt.size()?null:tt}}insert(t,tt){u.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new fs(t,tt))}boundablesAtLevel(){if(1==arguments.length){let t=arguments[0],tt=new x;return this.boundablesAtLevel(t,this._root,tt),tt}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(u.isTrue(t>-2),tt.getLevel()===t)return ta.add(tt),null;for(let th=tt.getChildBoundables().iterator();th.hasNext();){let tt=th.next();tt instanceof ms?this.boundablesAtLevel(t,tt,ta):(u.isTrue(tt instanceof fs),-1===t&&ta.add(tt))}return null}}query(){if(1==arguments.length){let t=arguments[0];this.build();let tt=new x;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,tt),tt}if(2==arguments.length){let t=arguments[0],tt=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,tt)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,tt)}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=this.removeItem(tt,ta);if(th)return!0;let tu=null;for(let tc=tt.getChildBoundables().iterator();tc.hasNext();){let tt=tc.next();if(this.getIntersectsOp().intersects(tt.getBounds(),t)&&tt instanceof ms&&(th=this.remove(t,tt,ta))){tu=tt;break}}return null!==tu&&tu.getChildBoundables().isEmpty()&&tt.getChildBoundables().remove(tu),th}}createHigherLevels(t,tt){u.isTrue(!t.isEmpty());let ta=this.createParentBoundables(t,tt+1);return 1===ta.size()?ta.get(0):this.createHigherLevels(ta,tt+1)}depth(){if(0==arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1==arguments.length){let t=0;for(let tt=arguments[0].getChildBoundables().iterator();tt.hasNext();){let ta=tt.next();if(ta instanceof ms){let tt=this.depth(ta);tt>t&&(t=tt)}}return t+1}}createParentBoundables(t,tt){u.isTrue(!t.isEmpty());let ta=new x;ta.add(this.createNode(tt));let th=new x(t);tu.sort(th,this.getComparator());for(let t=th.iterator();t.hasNext();){let th=t.next();this.lastNode(ta).getChildBoundables().size()===this.getNodeCapacity()&&ta.add(this.createNode(tt)),this.lastNode(ta).addChildBoundable(th)}return ta}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}getClass(){return xs}get interfaces_(){return[a]}};xs.IntersectsOp=function(){},xs.constructor_=function(){if(this._root=null,this._built=!1,this._itemBoundables=new x,this._nodeCapacity=null,0==arguments.length)xs.constructor_.call(this,xs.DEFAULT_NODE_CAPACITY);else if(1==arguments.length){let t=arguments[0];u.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}},xs.serialVersionUID=-0xca109b37d2b3ac00,xs.DEFAULT_NODE_CAPACITY=10;let Es=class Es{constructor(){Es.constructor_.apply(this,arguments)}distance(t,tt){}getClass(){return Es}get interfaces_(){return[]}};Es.constructor_=function(){};let Is=class Is extends xs{constructor(){super(),Is.constructor_.apply(this,arguments)}static centreX(t){return Is.avg(t.getMinX(),t.getMaxX())}static avg(t,tt){return(t+tt)/2}static getItems(t){let tt=Array(t.size()).fill(null),ta=0;for(;!t.isEmpty();){let th=t.poll();tt[ta]=th.getBoundable(0).getItem(),ta++}return tt}static centreY(t){return Is.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,tt){u.isTrue(t.length>0);let ta=new x;for(let th=0;th<t.length;th++)ta.addAll(this.createParentBoundablesFromVerticalSlice(t[th],tt));return ta}createNode(t){return new Ns(t)}size(){return 0==arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2==arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N))return super.insert.apply(this,arguments);{let t=arguments[0],tt=arguments[1];if(t.isNull())return null;super.insert.call(this,t,tt)}}getIntersectsOp(){return Is.intersectsOp}verticalSlices(t,tt){let ta=Math.trunc(Math.ceil(t.size()/tt)),th=Array(tt).fill(null),tu=t.iterator();for(let t=0;t<tt;t++){th[t]=new x;let tt=0;for(;tu.hasNext()&&tt<ta;){let ta=tu.next();th[t].add(ta),tt++}}return th}query(){if(1==arguments.length){let t=arguments[0];return super.query.call(this,t)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];super.query.call(this,t,tt)}}getComparator(){return Is.yComparator}createParentBoundablesFromVerticalSlice(t,tt){return super.createParentBoundables.call(this,t,tt)}remove(){if(2==arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N){let t=arguments[0],tt=arguments[1];return super.remove.call(this,t,tt)}return super.remove.apply(this,arguments)}depth(){return 0==arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,tt){u.isTrue(!t.isEmpty());let ta=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),th=new x(t);tu.sort(th,Is.xComparator);let tc=this.verticalSlices(th,Math.trunc(Math.ceil(Math.sqrt(ta))));return this.createParentBoundablesFromVerticalSlices(tc,tt)}nearestNeighbour(){if(1==arguments.length){if(_(arguments[0],Es)){let t=arguments[0],tt=new ys(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(tt)}if(arguments[0]instanceof ys){let t=arguments[0];return this.nearestNeighbour(t,i.POSITIVE_INFINITY)}}else if(2==arguments.length){if(arguments[0]instanceof Is&&_(arguments[1],Es)){let t=arguments[0],tt=arguments[1],ta=new ys(this.getRoot(),t.getRoot(),tt);return this.nearestNeighbour(ta)}if(arguments[0]instanceof ys&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=null,th=new ps;for(th.add(t);!th.isEmpty()&&tt>0;){let t=th.poll(),tu=t.getDistance();if(tu>=tt)break;t.isLeaves()?(tt=tu,ta=t):t.expandToQueue(th,tt)}return[ta.getBoundable(0).getItem(),ta.getBoundable(1).getItem()]}if(arguments[0]instanceof ys&&Number.isInteger(arguments[1])){let t=arguments[0],tt=arguments[1];return this.nearestNeighbour(t,i.POSITIVE_INFINITY,tt)}}else if(3==arguments.length){if(_(arguments[2],Es)&&arguments[0]instanceof N&&arguments[1]instanceof Object){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=new fs(t,tt),tu=new ys(this.getRoot(),th,ta);return this.nearestNeighbour(tu)[0]}if(Number.isInteger(arguments[2])&&arguments[0]instanceof ys&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=tt,tu=new ps;tu.add(t);let tc=new ps;for(;!tu.isEmpty()&&th>=0;){let t=tu.poll(),tt=t.getDistance();if(tt>=th)break;t.isLeaves()?tc.size()<ta?tc.add(t):(tc.peek().getDistance()>tt&&(tc.poll(),tc.add(t)),th=tc.peek().getDistance()):t.expandToQueue(tu,th)}return Is.getItems(tc)}}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=new fs(t,tt),tc=new ys(this.getRoot(),tu,ta);return this.nearestNeighbour(tc,th)}}getClass(){return Is}get interfaces_(){return[us,a]}};let Ns=class Ns extends ms{constructor(){super(),Ns.constructor_.apply(this,arguments)}computeBounds(){let t=null;for(let tt=this.getChildBoundables().iterator();tt.hasNext();){let ta=tt.next();null===t?t=new N(ta.getBounds()):t.expandToInclude(ta.getBounds())}return t}getClass(){return Ns}get interfaces_(){return[]}};Ns.constructor_=function(){let t=arguments[0];ms.constructor_.call(this,t)},Is.STRtreeNode=Ns,Is.constructor_=function(){if(0==arguments.length)Is.constructor_.call(this,Is.DEFAULT_NODE_CAPACITY);else if(1==arguments.length){let t=arguments[0];xs.constructor_.call(this,t)}},Is.serialVersionUID=0x39920f7d5f261e0,Is.xComparator=new class{get interfaces_(){return[l]}compare(t,tt){return xs.compareDoubles(Is.centreX(t.getBounds()),Is.centreX(tt.getBounds()))}},Is.yComparator=new class{get interfaces_(){return[l]}compare(t,tt){return xs.compareDoubles(Is.centreY(t.getBounds()),Is.centreY(tt.getBounds()))}},Is.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,tt){return t.intersects(tt)}},Is.DEFAULT_NODE_CAPACITY=10;var tI=Object.freeze({__proto__:null,kdtree:tx,quadtree:tE,strtree:Object.freeze({__proto__:null,STRtree:Is})});let tN=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];let Ls=class Ls{constructor(t){this.geometryFactory=t||new Wt}read(t){let tt;let ta=(tt="string"==typeof t?JSON.parse(t):t).type;if(!tC[ta])throw Error("Unknown GeoJSON type: "+tt.type);return -1!==tN.indexOf(ta)?tC[ta].call(this,tt.coordinates):"GeometryCollection"===ta?tC[ta].call(this,tt.geometries):tC[ta].call(this,tt)}write(t){let tt=t.getGeometryType();if(!tS[tt])throw Error("Geometry is not supported");return tS[tt].call(this,t)}};let tC={Feature:function(t){let tt={};for(let ta in t)tt[ta]=t[ta];if(t.geometry){let ta=t.geometry.type;if(!tC[ta])throw Error("Unknown GeoJSON type: "+t.type);tt.geometry=this.read(t.geometry)}return t.bbox&&(tt.bbox=tC.bbox.call(this,t.bbox)),tt},FeatureCollection:function(t){let tt={};if(t.features){tt.features=[];for(let ta=0;ta<t.features.length;++ta)tt.features.push(this.read(t.features[ta]))}return t.bbox&&(tt.bbox=this.parse.bbox.call(this,t.bbox)),tt},coordinates:function(t){let tt=[];for(let ta=0;ta<t.length;++ta){let th=t[ta];tt.push(new g(th[0],th[1]))}return tt},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){let tt=new g(t[0],t[1]);return this.geometryFactory.createPoint(tt)},MultiPoint:function(t){let tt=[];for(let ta=0;ta<t.length;++ta)tt.push(tC.Point.call(this,t[ta]));return this.geometryFactory.createMultiPoint(tt)},LineString:function(t){let tt=tC.coordinates.call(this,t);return this.geometryFactory.createLineString(tt)},MultiLineString:function(t){let tt=[];for(let ta=0;ta<t.length;++ta)tt.push(tC.LineString.call(this,t[ta]));return this.geometryFactory.createMultiLineString(tt)},Polygon:function(t){let tt=tC.coordinates.call(this,t[0]),ta=this.geometryFactory.createLinearRing(tt),th=[];for(let tt=1;tt<t.length;++tt){let ta=t[tt],tu=tC.coordinates.call(this,ta),tc=this.geometryFactory.createLinearRing(tu);th.push(tc)}return this.geometryFactory.createPolygon(ta,th)},MultiPolygon:function(t){let tt=[];for(let ta=0;ta<t.length;++ta){let th=t[ta];tt.push(tC.Polygon.call(this,th))}return this.geometryFactory.createMultiPolygon(tt)},GeometryCollection:function(t){let tt=[];for(let ta=0;ta<t.length;++ta){let th=t[ta];tt.push(this.read(th))}return this.geometryFactory.createGeometryCollection(tt)}},tS={coordinate:function(t){return[t.x,t.y]},Point:function(t){return{type:"Point",coordinates:tS.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){let tt=[];for(let ta=0;ta<t._geometries.length;++ta){let th=t._geometries[ta],tu=tS.Point.call(this,th);tt.push(tu.coordinates)}return{type:"MultiPoint",coordinates:tt}},LineString:function(t){let tt=[],ta=t.getCoordinates();for(let t=0;t<ta.length;++t){let th=ta[t];tt.push(tS.coordinate.call(this,th))}return{type:"LineString",coordinates:tt}},MultiLineString:function(t){let tt=[];for(let ta=0;ta<t._geometries.length;++ta){let th=t._geometries[ta],tu=tS.LineString.call(this,th);tt.push(tu.coordinates)}return{type:"MultiLineString",coordinates:tt}},Polygon:function(t){let tt=[],ta=tS.LineString.call(this,t._shell);tt.push(ta.coordinates);for(let ta=0;ta<t._holes.length;++ta){let th=t._holes[ta],tu=tS.LineString.call(this,th);tt.push(tu.coordinates)}return{type:"Polygon",coordinates:tt}},MultiPolygon:function(t){let tt=[];for(let ta=0;ta<t._geometries.length;++ta){let th=t._geometries[ta],tu=tS.Polygon.call(this,th);tt.push(tu.coordinates)}return{type:"MultiPolygon",coordinates:tt}},GeometryCollection:function(t){let tt=[];for(let ta=0;ta<t._geometries.length;++ta){let th=t._geometries[ta],tu=th.getGeometryType();tt.push(tS[tu].call(this,th))}return{type:"GeometryCollection",geometries:tt}}};function Ps(t){return[t.x,t.y]}var tL=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new Ls(t||new Wt)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new Ls(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,tt){this.geometryFactory=t||new Wt,this.ol=tt||"undefined"!=typeof ol&&ol}inject(t,tt,ta,th,tu,tc,tg,t_){this.ol={geom:{Point:t,LineString:tt,LinearRing:ta,Polygon:th,MultiPoint:tu,MultiLineString:tc,MultiPolygon:tg,GeometryCollection:t_}}}read(t){let tt=this.ol;return t instanceof tt.geom.Point?this.convertFromPoint(t):t instanceof tt.geom.LineString?this.convertFromLineString(t):t instanceof tt.geom.LinearRing?this.convertFromLinearRing(t):t instanceof tt.geom.Polygon?this.convertFromPolygon(t):t instanceof tt.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof tt.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof tt.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof tt.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){let tt=t.getCoordinates();return this.geometryFactory.createPoint(new g(tt[0],tt[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))}convertFromPolygon(t){let tt=t.getLinearRings(),ta=null,th=[];for(let t=0;t<tt.length;t++){let tu=this.convertFromLinearRing(tt[t]);0===t?ta=tu:th.push(tu)}return this.geometryFactory.createPolygon(ta,th)}convertFromMultiPoint(t){let tt=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(tt)}convertFromMultiLineString(t){let tt=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(tt)}convertFromMultiPolygon(t){let tt=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(tt)}convertFromCollection(t){let tt=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(tt)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){let tt=t._points._coordinates.map(Ps);return new this.ol.geom.LineString(tt)}convertToLinearRing(t){let tt=t._points._coordinates.map(Ps);return new this.ol.geom.LinearRing(tt)}convertToPolygon(t){let tt=[t._shell._points._coordinates.map(Ps)];for(let ta=0;ta<t._holes.length;ta++)tt.push(t._holes[ta]._points._coordinates.map(Ps));return new this.ol.geom.Polygon(tt)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ps))}convertToMultiLineString(t){let tt=[];for(let ta=0;ta<t._geometries.length;ta++)tt.push(this.convertToLineString(t._geometries[ta]).getCoordinates());return new this.ol.geom.MultiLineString(tt)}convertToMultiPolygon(t){let tt=[];for(let ta=0;ta<t._geometries.length;ta++)tt.push(this.convertToPolygon(t._geometries[ta]).getCoordinates());return new this.ol.geom.MultiPolygon(tt)}convertToCollection(t){let tt=[];for(let ta=0;ta<t._geometries.length;ta++){let th=t._geometries[ta];tt.push(this.write(th))}return new this.ol.geom.GeometryCollection(tt)}},WKTReader:class{constructor(t){this.parser=new Zt(t||new Wt)}read(t){return this.parser.read(t)}},WKTWriter:$t});let Os=class Os{constructor(){Os.constructor_.apply(this,arguments)}static relativeSign(t,tt){return t<tt?-1:t>tt?1:0}static compare(t,tt,ta){if(tt.equals2D(ta))return 0;let th=Os.relativeSign(tt.x,ta.x),tu=Os.relativeSign(tt.y,ta.y);switch(t){case 0:return Os.compareValue(th,tu);case 1:return Os.compareValue(tu,th);case 2:return Os.compareValue(tu,-th);case 3:return Os.compareValue(-th,tu);case 4:return Os.compareValue(-th,-tu);case 5:return Os.compareValue(-tu,-th);case 6:return Os.compareValue(-tu,th);case 7:return Os.compareValue(th,-tu)}return u.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,tt){return t<0?-1:t>0?1:tt<0?-1:tt>0?1:0}getClass(){return Os}get interfaces_(){return[]}};Os.constructor_=function(){};let bs=class bs{constructor(){bs.constructor_.apply(this,arguments)}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){return this.segmentIndex<t.segmentIndex?-1:this.segmentIndex>t.segmentIndex?1:this.coord.equals2D(t.coord)?0:Os.compare(this._segmentOctant,this.coord,t.coord)}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}isInterior(){return this._isInterior}getClass(){return bs}get interfaces_(){return[r]}};bs.constructor_=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this._segString=t,this.coord=new g(tt),this.segmentIndex=ta,this._segmentOctant=th,this._isInterior=!tt.equals2D(t.getCoordinate(ta))};let Ms=class Ms{constructor(){Ms.constructor_.apply(this,arguments)}getSplitCoordinates(){let t=new I;this.addEndpoints();let tt=this.iterator(),ta=tt.next();for(;tt.hasNext();){let th=tt.next();this.addEdgeCoordinates(ta,th,t),ta=th}return t.toCoordinateArray()}addCollapsedNodes(){let t=new x;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let tt=t.iterator();tt.hasNext();){let t=tt.next().intValue();this.add(this._edge.getCoordinate(t),t)}}print(t){t.println("Intersections:");for(let tt=this.iterator();tt.hasNext();)tt.next().print(t)}findCollapsesFromExistingVertices(t){for(let tt=0;tt<this._edge.size()-2;tt++){let ta=this._edge.getCoordinate(tt),th=(this._edge.getCoordinate(tt+1),this._edge.getCoordinate(tt+2));ta.equals2D(th)&&t.add(new L(tt+1))}}addEdgeCoordinates(t,tt,ta){tt.segmentIndex,t.segmentIndex;let th=this._edge.getCoordinate(tt.segmentIndex),tu=tt.isInterior()||!tt.coord.equals2D(th);ta.add(new g(t.coord),!1);for(let th=t.segmentIndex+1;th<=tt.segmentIndex;th++)ta.add(this._edge.getCoordinate(th));tu&&ta.add(new g(tt.coord))}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();let tt=this.iterator(),ta=tt.next();for(;tt.hasNext();){let th=tt.next(),tu=this.createSplitEdge(ta,th);t.add(tu),ta=th}}findCollapseIndex(t,tt,ta){if(!t.coord.equals2D(tt.coord))return!1;let th=tt.segmentIndex-t.segmentIndex;return tt.isInterior()||th--,1===th&&(ta[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){let tt=[,].fill(null),ta=this.iterator(),th=ta.next();for(;ta.hasNext();){let tu=ta.next();this.findCollapseIndex(th,tu,tt)&&t.add(new L(tt[0])),th=tu}}getEdge(){return this._edge}addEndpoints(){let t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,tt){let ta=tt.segmentIndex-t.segmentIndex+2,th=this._edge.getCoordinate(tt.segmentIndex),tu=tt.isInterior()||!tt.coord.equals2D(th);tu||ta--;let tc=Array(ta).fill(null),tg=0;tc[tg++]=new g(t.coord);for(let ta=t.segmentIndex+1;ta<=tt.segmentIndex;ta++)tc[tg++]=this._edge.getCoordinate(ta);return tu&&(tc[tg]=new g(tt.coord)),new Gs(tc,this._edge.getData())}add(t,tt){let ta=new bs(this._edge,t,tt,this._edge.getSegmentOctant(tt)),th=this._nodeMap.get(ta);return null!==th?(u.isTrue(th.coord.equals2D(t),"Found equal nodes with different coordinates"),th):(this._nodeMap.put(ta,ta),ta)}checkSplitEdgesCorrectness(t){let tt=this._edge.getCoordinates(),ta=t.get(0).getCoordinate(0);if(!ta.equals2D(tt[0]))throw new c("bad split edge start point at "+ta);let th=t.get(t.size()-1).getCoordinates(),tu=th[th.length-1];if(!tu.equals2D(tt[tt.length-1]))throw new c("bad split edge end point at "+tu)}getClass(){return Ms}get interfaces_(){return[]}};Ms.constructor_=function(){this._nodeMap=new ot,this._edge=null;let t=arguments[0];this._edge=t};let Ds=class Ds{constructor(){Ds.constructor_.apply(this,arguments)}static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];if(0===t&&0===tt)throw new n("Cannot compute the octant for point ( "+t+", "+tt+" )");let ta=Math.abs(t),th=Math.abs(tt);return t>=0?tt>=0?ta>=th?0:1:ta>=th?7:6:tt>=0?ta>=th?3:2:ta>=th?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){let t=arguments[0],tt=arguments[1],ta=tt.x-t.x,th=tt.y-t.y;if(0===ta&&0===th)throw new n("Cannot compute the octant for two identical points "+t);return Ds.octant(ta,th)}}getClass(){return Ds}get interfaces_(){return[]}};Ds.constructor_=function(){};let As=class As{constructor(){As.constructor_.apply(this,arguments)}getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}getClass(){return As}get interfaces_(){return[]}};As.constructor_=function(){};let Fs=class Fs{constructor(){Fs.constructor_.apply(this,arguments)}addIntersection(t,tt){}getClass(){return Fs}get interfaces_(){return[As]}};Fs.constructor_=function(){};let Gs=class Gs{constructor(){Gs.constructor_.apply(this,arguments)}static getNodedSubstrings(){if(1==arguments.length){let t=arguments[0],tt=new x;return Gs.getNodedSubstrings(t,tt),tt}if(2==arguments.length){let t=arguments[0],tt=arguments[1];for(let ta=t.iterator();ta.hasNext();)ta.next().getNodeList().addSplitEdges(tt)}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,tt){return t.equals2D(tt)?0:Ds.octant(t,tt)}getData(){return this._data}addIntersection(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.addIntersectionNode(t,tt)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[3],th=new g(t.getIntersection(ta));this.addIntersection(th,tt)}}toString(){return $t.toLineString(new Yt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,tt){let ta=tt,th=ta+1;if(th<this._pts.length){let tt=this._pts[th];t.equals2D(tt)&&(ta=th)}return this._nodeList.add(t,ta)}addIntersections(t,tt,ta){for(let th=0;th<t.getIntersectionNum();th++)this.addIntersection(t,tt,ta,th)}getClass(){return Gs}get interfaces_(){return[Fs]}};Gs.constructor_=function(){this._nodeList=new Ms(this),this._pts=null,this._data=null;let t=arguments[0],tt=arguments[1];this._pts=t,this._data=tt};let qs=class qs{constructor(){qs.constructor_.apply(this,arguments)}overlap(){if(2==arguments.length);else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];t.getLineSegment(tt,this._overlapSeg1),ta.getLineSegment(th,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}getClass(){return qs}get interfaces_(){return[]}};qs.constructor_=function(){this._overlapSeg1=new ne,this._overlapSeg2=new ne};let Bs=class Bs{constructor(){Bs.constructor_.apply(this,arguments)}getLineSegment(t,tt){tt.p0=this._pts[t],tt.p1=this._pts[t+1]}computeSelect(t,tt,ta,th){let tu=this._pts[tt],tc=this._pts[ta];if(ta-tt==1)return th.select(this,tt),null;if(!t.intersects(tu,tc))return null;let tg=Math.trunc((tt+ta)/2);tt<tg&&this.computeSelect(t,tt,tg,th),tg<ta&&this.computeSelect(t,tg,ta,th)}getCoordinates(){let t=Array(this._end-this._start+1).fill(null),tt=0;for(let ta=this._start;ta<=this._end;ta++)t[tt++]=this._pts[ta];return t}computeOverlaps(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,tt)}else if(6==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];if(tt-t==1&&tu-th==1)return tc.overlap(this,t,ta,th),null;if(!this.overlaps(t,tt,ta,th,tu))return null;let tg=Math.trunc((t+tt)/2),t_=Math.trunc((th+tu)/2);t<tg&&(th<t_&&this.computeOverlaps(t,tg,ta,th,t_,tc),t_<tu&&this.computeOverlaps(t,tg,ta,t_,tu,tc)),tg<tt&&(th<t_&&this.computeOverlaps(tg,tt,ta,th,t_,tc),t_<tu&&this.computeOverlaps(tg,tt,ta,t_,tu,tc))}}setId(t){this._id=t}select(t,tt){this.computeSelect(t,this._start,this._end,tt)}getEnvelope(){if(null===this._env){let t=this._pts[this._start],tt=this._pts[this._end];this._env=new N(t,tt)}return this._env}overlaps(t,tt,ta,th,tu){return N.intersects(this._pts[t],this._pts[tt],ta._pts[th],ta._pts[tu])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}getClass(){return Bs}get interfaces_(){return[]}};Bs.constructor_=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this._pts=t,this._start=tt,this._end=ta,this._context=th};let Vs=class Vs{constructor(){Vs.constructor_.apply(this,arguments)}static getChainStartIndices(t){let tt=0,ta=new x;ta.add(new L(tt));do{let th=Vs.findChainEnd(t,tt);ta.add(new L(th)),tt=th}while(tt<t.length-1);return Vs.toIntArray(ta)}static findChainEnd(t,tt){let ta=tt;for(;ta<t.length-1&&t[ta].equals2D(t[ta+1]);)ta++;if(ta>=t.length-1)return t.length-1;let th=Nn.quadrant(t[ta],t[ta+1]),tu=tt+1;for(;tu<t.length&&(t[tu-1].equals2D(t[tu])||Nn.quadrant(t[tu-1],t[tu])===th);)tu++;return tu-1}static getChains(){if(1==arguments.length){let t=arguments[0];return Vs.getChains(t,null)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=new x,th=Vs.getChainStartIndices(t);for(let tu=0;tu<th.length-1;tu++){let tc=new Bs(t,th[tu],th[tu+1],tt);ta.add(tc)}return ta}}static toIntArray(t){let tt=Array(t.size()).fill(null);for(let ta=0;ta<tt.length;ta++)tt[ta]=t.get(ta).intValue();return tt}getClass(){return Vs}get interfaces_(){return[]}};Vs.constructor_=function(){};let zs=class zs{constructor(){zs.constructor_.apply(this,arguments)}computeNodes(t){}getNodedSubstrings(){}getClass(){return zs}get interfaces_(){return[]}};zs.constructor_=function(){};let Ys=class Ys{constructor(){Ys.constructor_.apply(this,arguments)}setSegmentIntersector(t){this._segInt=t}getClass(){return Ys}get interfaces_(){return[zs]}};Ys.constructor_=function(){if(this._segInt=null,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this.setSegmentIntersector(t)}};let Us=class Us extends Ys{constructor(){super(),Us.constructor_.apply(this,arguments)}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Gs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let tt=Vs.getChains(t.getCoordinates(),t).iterator();tt.hasNext();){let t=tt.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let tt=t.iterator();tt.hasNext();)this.add(tt.next());this.intersectChains()}intersectChains(){let t=new ks(this._segInt);for(let tt=this._monoChains.iterator();tt.hasNext();){let ta=tt.next();for(let tt=this._index.query(ta.getEnvelope()).iterator();tt.hasNext();){let th=tt.next();if(th.getId()>ta.getId()&&(ta.computeOverlaps(th,t),this._nOverlaps++),this._segInt.isDone())return null}}}getClass(){return Us}get interfaces_(){return[]}};let ks=class ks extends qs{constructor(){super(),ks.constructor_.apply(this,arguments)}overlap(){if(4!=arguments.length)return super.overlap.apply(this,arguments);{let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=t.getContext(),tc=ta.getContext();this._si.processIntersections(tu,tt,tc,th)}}getClass(){return ks}get interfaces_(){return[]}};ks.constructor_=function(){this._si=null;let t=arguments[0];this._si=t},Us.SegmentOverlapAction=ks,Us.constructor_=function(){if(this._monoChains=new x,this._index=new Is,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0==arguments.length);else if(1==arguments.length){let t=arguments[0];Ys.constructor_.call(this,t)}};let Xs=class Xs{constructor(){Xs.constructor_.apply(this,arguments)}rescale(){if(_(arguments[0],f))for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.rescale(tt.getCoordinates())}else if(arguments[0]instanceof Array){let t=arguments[0];2===t.length&&(new g(t[0]),new g(t[1]));for(let tt=0;tt<t.length;tt++)t[tt].x=t[tt].x/this._scaleFactor+this._offsetX,t[tt].y=t[tt].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&O.out.println(t)}}scale(){if(_(arguments[0],f)){let t=arguments[0],tt=new x(t.size());for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt.add(new Gs(this.scale(t.getCoordinates()),t.getData()))}return tt}if(arguments[0]instanceof Array){let t=arguments[0],tt=Array(t.length).fill(null);for(let ta=0;ta<t.length;ta++)tt[ta]=new g(Math.round((t[ta].x-this._offsetX)*this._scaleFactor),Math.round((t[ta].y-this._offsetY)*this._scaleFactor),t[ta].z);return X.removeRepeatedPoints(tt)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){let t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let tt=t;this._isScaled&&(tt=this.scale(t)),this._noder.computeNodes(tt)}getClass(){return Xs}get interfaces_(){return[zs]}};Xs.constructor_=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2==arguments.length){let t=arguments[0],tt=arguments[1];Xs.constructor_.call(this,t,tt,0,0)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1];this._noder=t,this._scaleFactor=tt,this._isScaled=!this.isIntegerPrecision()}};var tR=Object.freeze({__proto__:null,MCIndexNoder:Us,ScaledNoder:Xs,SegmentString:As});let Ws=class Ws{constructor(){Ws.constructor_.apply(this,arguments)}static isSimple(){if(1==arguments.length){let t=arguments[0];return new Ws(t).isSimple()}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new Ws(t,tt).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;let tt=new ct;for(let ta=0;ta<t.getNumGeometries();ta++){let th=t.getGeometryN(ta).getCoordinate();if(tt.contains(th))return this._nonSimpleLocation=th,!1;tt.add(th)}return!0}isSimplePolygonal(t){for(let tt=Ee.getLines(t).iterator();tt.hasNext();){let t=tt.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){let tt=new ot;for(let ta=t.getEdgeIterator();ta.hasNext();){let t=ta.next(),th=(t.getMaximumSegmentIndex(),t.isClosed()),tu=t.getCoordinate(0);this.addEndpoint(tt,tu,th);let tc=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(tt,tc,th)}for(let t=tt.values().iterator();t.hasNext();){let tt=t.next();if(tt.isClosed&&2!==tt.degree)return this._nonSimpleLocation=tt.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;let tt=new Jn(0,t),ta=new ee,th=tt.computeSelfNodes(ta,!0);return!th.hasIntersection()||(th.hasProperIntersection()?(this._nonSimpleLocation=th.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(tt)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(tt)))}hasNonEndpointIntersection(t){for(let tt=t.getEdgeIterator();tt.hasNext();){let t=tt.next(),ta=t.getMaximumSegmentIndex();for(let tt=t.getEdgeIntersectionList().iterator();tt.hasNext();){let t=tt.next();if(!t.isEndPoint(ta))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,tt,ta){let th=t.get(tt);null===th&&(th=new js(tt),t.put(tt,th)),th.addEndpoint(ta)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof Rt?this.isSimpleLinearGeometry(t):t instanceof pt?this.isSimpleLinearGeometry(t):t instanceof Dt?this.isSimpleMultiPoint(t):_(t,bt)?this.isSimplePolygonal(t):!(t instanceof ft)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);if(!this.computeSimple(ta))return!1}return!0}getClass(){return Ws}get interfaces_(){return[]}};let js=class js{constructor(){js.constructor_.apply(this,arguments)}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}getClass(){return js}get interfaces_(){return[]}};js.constructor_=function(){this.pt=null,this.isClosed=null,this.degree=null;let t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0},Ws.EndpointInfo=js,Ws.constructor_=function(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1==arguments.length){let t=arguments[0];this._inputGeom=t}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!tt.isInBoundary(2)}};let Ks=class Ks{constructor(){Ks.constructor_.apply(this,arguments)}static bufferDistanceError(t){return 1-Math.cos(Math.PI/2/t/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=Ks.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=Ks.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==Ks.JOIN_ROUND&&(this._quadrantSegments=Ks.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}getClass(){return Ks}get interfaces_(){return[]}};Ks.constructor_=function(){if(this._quadrantSegments=Ks.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=Ks.CAP_ROUND,this._joinStyle=Ks.JOIN_ROUND,this._mitreLimit=Ks.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=Ks.DEFAULT_SIMPLIFY_FACTOR,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this.setQuadrantSegments(t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(tt)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(tt),this.setJoinStyle(ta),this.setMitreLimit(th)}},Ks.CAP_ROUND=1,Ks.CAP_FLAT=2,Ks.CAP_SQUARE=3,Ks.JOIN_ROUND=1,Ks.JOIN_MITRE=2,Ks.JOIN_BEVEL=3,Ks.DEFAULT_QUADRANT_SEGMENTS=8,Ks.DEFAULT_MITRE_LIMIT=5,Ks.DEFAULT_SIMPLIFY_FACTOR=.01;let Zs=class Zs{constructor(){Zs.constructor_.apply(this,arguments)}getCoordinate(){return this._minCoord}getRightmostSide(t,tt){let ta=this.getRightmostSideOfSegment(t,tt);return ta<0&&(ta=this.getRightmostSideOfSegment(t,tt-1)),ta<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),ta}findRightmostEdgeAtVertex(){let t=this._minDe.getEdge().getCoordinates();u.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");let tt=t[this._minIndex-1],ta=t[this._minIndex+1],th=v.index(this._minCoord,ta,tt),tu=!1;tt.y<this._minCoord.y&&ta.y<this._minCoord.y&&th===v.COUNTERCLOCKWISE?tu=!0:tt.y>this._minCoord.y&&ta.y>this._minCoord.y&&th===v.CLOCKWISE&&(tu=!0),tu&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,tt){let ta=t.getEdge().getCoordinates();if(tt<0||tt+1>=ta.length||ta[tt].y===ta[tt+1].y)return -1;let th=vn.LEFT;return ta[tt].y<ta[tt+1].y&&(th=vn.RIGHT),th}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){let tt=t.getEdge().getCoordinates();for(let ta=0;ta<tt.length-1;ta++)(null===this._minCoord||tt[ta].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=ta,this._minCoord=tt[ta])}findRightmostEdgeAtNode(){let t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();t.isForward()&&this.checkForRightmostCoordinate(t)}u.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===vn.LEFT&&(this._orientedDe=this._minDe.getSym())}getClass(){return Zs}get interfaces_(){return[]}};function Qs(){this.array_=[]}Zs.constructor_=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null},Qs.prototype.addLast=function(t){this.array_.push(t)},Qs.prototype.removeFirst=function(){return this.array_.shift()},Qs.prototype.isEmpty=function(){return 0===this.array_.length};let Js=class Js{constructor(){Js.constructor_.apply(this,arguments)}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();)t.next().setVisited(!1)}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let tt=null;for(let ta=t.getEdges().iterator();ta.hasNext();){let t=ta.next();if(t.isVisited()||t.getSym().isVisited()){tt=t;break}}if(null===tt)throw new jn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(tt);for(let tt=t.getEdges().iterator();tt.hasNext();){let t=tt.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();let tt=this._finder.getEdge();tt.getNode(),tt.getLabel(),tt.setEdgeDepths(vn.RIGHT,t),this.copySymDepths(tt),this.computeDepths(tt)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){let tt=t.next();tt.getDepth(vn.RIGHT)>=1&&0>=tt.getDepth(vn.LEFT)&&!tt.isInteriorAreaEdge()&&tt.setInResult(!0)}}computeDepths(t){let tt=new J,ta=new Qs,th=t.getNode();for(ta.addLast(th),tt.add(th),t.setVisited(!0);!ta.isEmpty();){let t=ta.removeFirst();tt.add(t),this.computeNodeDepth(t);for(let th=t.getEdges().iterator();th.hasNext();){let t=th.next().getSym();if(t.isVisited())continue;let tu=t.getNode();tt.contains(tu)||(ta.addLast(tu),tt.add(tu))}}}compareTo(t){return this._rightMostCoord.x<t._rightMostCoord.x?-1:this._rightMostCoord.x>t._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){let t=new N;for(let tt=this._dirEdgeList.iterator();tt.hasNext();){let ta=tt.next().getEdge().getCoordinates();for(let tt=0;tt<ta.length-1;tt++)t.expandToInclude(ta[tt])}this._env=t}return this._env}addReachable(t){let tt=new ln;for(tt.add(t);!tt.empty();){let t=tt.pop();this.add(t,tt)}}copySymDepths(t){let tt=t.getSym();tt.setDepth(vn.LEFT,t.getDepth(vn.RIGHT)),tt.setDepth(vn.RIGHT,t.getDepth(vn.LEFT))}add(t,tt){t.setVisited(!0),this._nodes.add(t);for(let ta=t.getEdges().iterator();ta.hasNext();){let t=ta.next();this._dirEdgeList.add(t);let th=t.getSym().getNode();th.isVisited()||tt.push(th)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}getClass(){return Js}get interfaces_(){return[r]}};Js.constructor_=function(){this._finder=null,this._dirEdgeList=new x,this._nodes=new x,this._rightMostCoord=null,this._env=null,this._finder=new Zs};let $s=class $s{constructor(){$s.constructor_.apply(this,arguments)}computeRing(){if(null!==this._ring)return null;let t=Array(this._pts.size()).fill(null);for(let tt=0;tt<this._pts.size();tt++)t[tt]=this._pts.get(tt);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=v.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let tt=t,ta=!0;do{if(null===tt)throw new jn("Found null DirectedEdge");if(tt.getEdgeRing()===this)throw new jn("Directed Edge visited twice during ring-building at "+tt.getCoordinate());this._edges.add(tt);let t=tt.getLabel();u.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(tt.getEdge(),tt.isForward(),ta),ta=!1,this.setEdgeRing(tt,this),tt=this.getNext(tt)}while(tt!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{let tt=t.getNode().getEdges().getOutgoingDegree(this);tt>this._maxNodeDegree&&(this._maxNodeDegree=tt),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,tt,ta){let th=t.getCoordinates();if(tt){let t=1;ta&&(t=0);for(let tt=t;tt<th.length;tt++)this._pts.add(th[tt])}else{let t=th.length-2;ta&&(t=th.length-1);for(let tt=t;tt>=0;tt--)this._pts.add(th[tt])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this._startDe)}containsPoint(t){let tt=this.getLinearRing();if(!tt.getEnvelopeInternal().contains(t)||!je.isInRing(t,tt.getCoordinates()))return!1;for(let tt=this._holes.iterator();tt.hasNext();)if(tt.next().containsPoint(t))return!1;return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1==arguments.length){let t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t.getLocation(tt,vn.RIGHT);if(ta===se.NONE)return null;if(this._label.getLocation(tt)===se.NONE)return this._label.setLocation(tt,ta),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){let tt=Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)tt[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),tt)}getClass(){return $s}get interfaces_(){return[]}};$s.constructor_=function(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new x,this._pts=new x,this._label=new Gn(se.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new x,this._geometryFactory=null,0==arguments.length);else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._geometryFactory=tt,this.computePoints(t),this.computeRing()}};let ti=class ti extends $s{constructor(){super(),ti.constructor_.apply(this,arguments)}setEdgeRing(t,tt){t.setMinEdgeRing(tt)}getNext(t){return t.getNextMin()}getClass(){return ti}get interfaces_(){return[]}};ti.constructor_=function(){let t=arguments[0],tt=arguments[1];$s.constructor_.call(this,t,tt)};let ei=class ei extends $s{constructor(){super(),ei.constructor_.apply(this,arguments)}buildMinimalRings(){let t=new x,tt=this._startDe;do{if(null===tt.getMinEdgeRing()){let ta=new ti(tt,this._geometryFactory);t.add(ta)}tt=tt.getNext()}while(tt!==this._startDe);return t}setEdgeRing(t,tt){t.setEdgeRing(tt)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext();while(t!==this._startDe)}getNext(t){return t.getNext()}getClass(){return ei}get interfaces_(){return[]}};ei.constructor_=function(){let t=arguments[0],tt=arguments[1];$s.constructor_.call(this,t,tt)};let ni=class ni{constructor(){ni.constructor_.apply(this,arguments)}sortShellsAndHoles(t,tt,ta){for(let th=t.iterator();th.hasNext();){let t=th.next();t.isHole()?ta.add(t):tt.add(t)}}computePolygons(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next().toPolygon(this._geometryFactory);tt.add(t)}return tt}placeFreeHoles(t,tt){for(let ta=tt.iterator();ta.hasNext();){let tt=ta.next();if(null===tt.getShell()){let ta=this.findEdgeRingContaining(tt,t);if(null===ta)throw new jn("unable to assign hole to a shell",tt.getCoordinate(0));tt.setShell(ta)}}}buildMinimalEdgeRings(t,tt,ta){let th=new x;for(let tu=t.iterator();tu.hasNext();){let t=tu.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();let th=t.buildMinimalRings(),tu=this.findShell(th);null!==tu?(this.placePolygonHoles(tu,th),tt.add(tu)):ta.addAll(th)}else th.add(t)}return th}containsPoint(t){for(let tt=this._shellList.iterator();tt.hasNext();)if(tt.next().containsPoint(t))return!0;return!1}buildMaximalEdgeRings(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){let ta=new ei(t,this._geometryFactory);tt.add(ta),ta.setInResult()}}return tt}placePolygonHoles(t,tt){for(let ta=tt.iterator();ta.hasNext();){let tt=ta.next();tt.isHole()&&tt.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findEdgeRingContaining(t,tt){let ta=t.getLinearRing(),th=ta.getEnvelopeInternal(),tu=ta.getCoordinateN(0),tc=null,tg=null;for(let t=tt.iterator();t.hasNext();){let tt=t.next(),ta=tt.getLinearRing(),t_=ta.getEnvelopeInternal();null!==tc&&(tg=tc.getLinearRing().getEnvelopeInternal());let td=!1;t_.contains(th)&&je.isInRing(tu,ta.getCoordinates())&&(td=!0),td&&(null===tc||tg.contains(t_))&&(tc=tt)}return tc}findShell(t){let tt=0,ta=null;for(let th=t.iterator();th.hasNext();){let t=th.next();t.isHole()||(ta=t,tt++)}return u.isTrue(tt<=1,"found two shells in MinimalEdgeRing list"),ta}add(){if(1==arguments.length){let t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];Qn.linkResultDirectedEdges(tt);let ta=this.buildMaximalEdgeRings(t),th=new x,tu=this.buildMinimalEdgeRings(ta,this._shellList,th);this.sortShellsAndHoles(tu,this._shellList,th),this.placeFreeHoles(this._shellList,th)}}getClass(){return ni}get interfaces_(){return[]}};ni.constructor_=function(){this._geometryFactory=null,this._shellList=new x;let t=arguments[0];this._geometryFactory=t};let si=class si{constructor(){si.constructor_.apply(this,arguments)}static simplify(t,tt){return new si(t).simplify(tt)}isDeletable(t,tt,ta,th){let tu=this._inputLine[t],tc=this._inputLine[tt],tg=this._inputLine[ta];return!!this.isConcave(tu,tc,tg)&&!!this.isShallow(tu,tc,tg,th)&&this.isShallowSampled(tu,tc,t,ta,th)}deleteShallowConcavities(){let t=1;this._inputLine.length;let tt=this.findNextNonDeletedIndex(t),ta=this.findNextNonDeletedIndex(tt),th=!1;for(;ta<this._inputLine.length;){let tu=!1;this.isDeletable(t,tt,ta,this._distanceTol)&&(this._isDeleted[tt]=si.DELETE,tu=!0,th=!0),t=tu?ta:tt,tt=this.findNextNonDeletedIndex(t),ta=this.findNextNonDeletedIndex(tt)}return th}isShallowConcavity(t,tt,ta,th){return v.index(t,tt,ta)===this._angleOrientation&&D.pointToSegment(tt,t,ta)<th}isShallowSampled(t,tt,ta,th,tu){let tc=Math.trunc((th-ta)/si.NUM_PTS_TO_CHECK);tc<=0&&(tc=1);for(let tg=ta;tg<th;tg+=tc)if(!this.isShallow(t,tt,this._inputLine[tg],tu))return!1;return!0}isConcave(t,tt,ta){return v.index(t,tt,ta)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=v.CLOCKWISE),this._isDeleted=Array(this._inputLine.length).fill(null);let tt=!1;do tt=this.deleteShallowConcavities();while(tt);return this.collapseLine()}findNextNonDeletedIndex(t){let tt=t+1;for(;tt<this._inputLine.length&&this._isDeleted[tt]===si.DELETE;)tt++;return tt}isShallow(t,tt,ta,th){return D.pointToSegment(tt,t,ta)<th}collapseLine(){let t=new I;for(let tt=0;tt<this._inputLine.length;tt++)this._isDeleted[tt]!==si.DELETE&&t.add(this._inputLine[tt]);return t.toCoordinateArray()}getClass(){return si}get interfaces_(){return[]}};si.constructor_=function(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=v.COUNTERCLOCKWISE;let t=arguments[0];this._inputLine=t},si.INIT=0,si.DELETE=1,si.KEEP=1,si.NUM_PTS_TO_CHECK=10;let ii=class ii{constructor(){ii.constructor_.apply(this,arguments)}getCoordinates(){return this._ptList.toArray(ii.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){let tt=new g(t);if(this._precisionModel.makePrecise(tt),this.isRedundant(tt))return null;this._ptList.add(tt)}reverse(){}addPts(t,tt){if(tt)for(let tt=0;tt<t.length;tt++)this.addPt(t[tt]);else for(let tt=t.length-1;tt>=0;tt--)this.addPt(t[tt])}isRedundant(t){if(1>this._ptList.size())return!1;let tt=this._ptList.get(this._ptList.size()-1);return t.distance(tt)<this._minimimVertexDistance}toString(){return(new Wt).createLineString(this.getCoordinates()).toString()}closeRing(){if(1>this._ptList.size())return null;let t=new g(this._ptList.get(0)),tt=this._ptList.get(this._ptList.size()-1);if(this._ptList.size()>=2&&this._ptList.get(this._ptList.size()-2),t.equals(tt))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}getClass(){return ii}get interfaces_(){return[]}};ii.constructor_=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new x},ii.COORDINATE_ARRAY_TYPE=[].fill(null);let ri=class ri{constructor(){ri.constructor_.apply(this,arguments)}addNextSegment(t,tt){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;let ta=v.index(this._s0,this._s1,this._s2),th=ta===v.CLOCKWISE&&this._side===vn.LEFT||ta===v.COUNTERCLOCKWISE&&this._side===vn.RIGHT;0===ta?this.addCollinear(tt):th?this.addOutsideTurn(ta,tt):this.addInsideTurn(ta,tt)}addLineEndCap(t,tt){let ta=new ne(t,tt),th=new ne;this.computeOffsetSegment(ta,vn.LEFT,this._distance,th);let tu=new ne;this.computeOffsetSegment(ta,vn.RIGHT,this._distance,tu);let tc=tt.x-t.x,tg=tt.y-t.y,t_=Math.atan2(tg,tc);switch(this._bufParams.getEndCapStyle()){case Ks.CAP_ROUND:this._segList.addPt(th.p1),this.addDirectedFillet(tt,t_+Math.PI/2,t_-Math.PI/2,v.CLOCKWISE,this._distance),this._segList.addPt(tu.p1);break;case Ks.CAP_FLAT:this._segList.addPt(th.p1),this._segList.addPt(tu.p1);break;case Ks.CAP_SQUARE:let td=new g;td.x=Math.abs(this._distance)*Math.cos(t_),td.y=Math.abs(this._distance)*Math.sin(t_);let tp=new g(th.p1.x+td.x,th.p1.y+td.y),tf=new g(tu.p1.x+td.x,tu.p1.y+td.y);this._segList.addPt(tp),this._segList.addPt(tf)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,tt,ta,th){let tu=!0,tc=null;try{tc=b.intersection(tt.p0,tt.p1,ta.p0,ta.p1),(th<=0?1:tc.distance(t)/Math.abs(th))>this._bufParams.getMitreLimit()&&(tu=!1)}catch(t){if(!(t instanceof S))throw t;tc=new g(0,0),tu=!1}tu?this._segList.addPt(tc):this.addLimitedMitreJoin(tt,ta,th,this._bufParams.getMitreLimit())}addOutsideTurn(t,tt){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*ri.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===Ks.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===Ks.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(tt&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new g(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new g(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,tt){this._segList.addPts(t,tt)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,tt,ta,th,tu){let tc=tt.x-t.x,tg=tt.y-t.y,t_=Math.atan2(tg,tc),td=ta.x-t.x,tp=ta.y-t.y,tf=Math.atan2(tp,td);th===v.CLOCKWISE?t_<=tf&&(t_+=2*Math.PI):t_>=tf&&(t_-=2*Math.PI),this._segList.addPt(tt),this.addDirectedFillet(t,t_,tf,th,tu),this._segList.addPt(ta)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,tt,ta){this._s1=t,this._s2=tt,this._side=ta,this._seg1.setCoordinates(t,tt),this.computeOffsetSegment(this._seg1,ta,this._distance,this._offset1)}addLimitedMitreJoin(t,tt,ta,th){let tu=this._seg0.p1,tc=re.angle(tu,this._seg0.p0),tg=(re.angle(tu,this._seg1.p1),re.angleBetweenOriented(this._seg0.p0,tu,this._seg1.p1)/2),t_=re.normalize(tc+tg),td=re.normalize(t_+Math.PI),tp=th*ta,tf=ta-tp*Math.abs(Math.sin(tg)),tm=tu.x+tp*Math.cos(td),ty=tu.y+tp*Math.sin(td),tx=new g(tm,ty),tE=new ne(tu,tx),tI=tE.pointAlongOffset(1,tf),tN=tE.pointAlongOffset(1,-tf);this._side===vn.LEFT?(this._segList.addPt(tI),this._segList.addPt(tN)):(this._segList.addPt(tN),this._segList.addPt(tI))}addDirectedFillet(t,tt,ta,th,tu){let tc=th===v.CLOCKWISE?-1:1,tg=Math.abs(tt-ta),t_=Math.trunc(tg/this._filletAngleQuantum+.5);if(t_<1)return null;let td=null;td=tg/t_;let tp=0,tf=new g;for(;tp<tg;){let ta=tt+tc*tp;tf.x=t.x+tu*Math.cos(ta),tf.y=t.y+tu*Math.sin(ta),this._segList.addPt(tf),tp+=td}}computeOffsetSegment(t,tt,ta,th){let tu=tt===vn.LEFT?1:-1,tc=t.p1.x-t.p0.x,tg=t.p1.y-t.p0.y,t_=Math.sqrt(tc*tc+tg*tg),td=tu*ta*tc/t_,tp=tu*ta*tg/t_;th.p0.x=t.p0.x-tp,th.p0.y=t.p0.y+td,th.p1.x=t.p1.x-tp,th.p1.y=t.p1.y+td}addInsideTurn(t,tt){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*ri.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){let t=new g((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);let tt=new g((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(tt)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){let tt=new g(t.x+this._distance,t.y);this._segList.addPt(tt),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,tt){this._segList.addPt(t.p1),this._segList.addPt(tt.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new ii,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*ri.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===Ks.JOIN_BEVEL||this._bufParams.getJoinStyle()===Ks.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,v.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}getClass(){return ri}get interfaces_(){return[]}};ri.constructor_=function(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new ne,this._seg1=new ne,this._offset0=new ne,this._offset1=new ne,this._side=0,this._hasNarrowConcaveAngle=!1;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._precisionModel=t,this._bufParams=tt,this._li=new ee,this._filletAngleQuantum=Math.PI/2/tt.getQuadrantSegments(),tt.getQuadrantSegments()>=8&&tt.getJoinStyle()===Ks.JOIN_ROUND&&(this._closingSegLengthFactor=ri.MAX_CLOSING_SEG_LEN_FACTOR),this.init(ta)},ri.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,ri.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,ri.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,ri.MAX_CLOSING_SEG_LEN_FACTOR=80;let oi=class oi{constructor(){oi.constructor_.apply(this,arguments)}static copyCoordinates(t){let tt=Array(t.length).fill(null);for(let ta=0;ta<tt.length;ta++)tt[ta]=new g(t[ta]);return tt}getOffsetCurve(t,tt){if(this._distance=tt,0===tt)return null;let ta=tt<0,th=this.getSegGen(Math.abs(tt));t.length<=1?this.computePointCurve(t[0],th):this.computeOffsetCurve(t,ta,th);let tu=th.getCoordinates();return ta&&X.reverse(tu),tu}computeSingleSidedBufferCurve(t,tt,ta){let th=this.simplifyTolerance(this._distance);if(tt){ta.addSegments(t,!0);let tt=si.simplify(t,-th),tu=tt.length-1;ta.initSideSegments(tt[tu],tt[tu-1],vn.LEFT),ta.addFirstSegment();for(let t=tu-2;t>=0;t--)ta.addNextSegment(tt[t],!0)}else{ta.addSegments(t,!1);let tt=si.simplify(t,th),tu=tt.length-1;ta.initSideSegments(tt[0],tt[1],vn.LEFT),ta.addFirstSegment();for(let t=2;t<=tu;t++)ta.addNextSegment(tt[t],!0)}ta.addLastSegment(),ta.closeRing()}computeRingBufferCurve(t,tt,ta){let th=this.simplifyTolerance(this._distance);tt===vn.RIGHT&&(th=-th);let tu=si.simplify(t,th),tc=tu.length-1;ta.initSideSegments(tu[tc-1],tu[0],tt);for(let t=1;t<=tc;t++){let tt=1!==t;ta.addNextSegment(tu[t],tt)}ta.closeRing()}computeLineBufferCurve(t,tt){let ta=this.simplifyTolerance(this._distance),th=si.simplify(t,ta),tu=th.length-1;tt.initSideSegments(th[0],th[1],vn.LEFT);for(let t=2;t<=tu;t++)tt.addNextSegment(th[t],!0);tt.addLastSegment(),tt.addLineEndCap(th[tu-1],th[tu]);let tc=si.simplify(t,-ta),tg=tc.length-1;tt.initSideSegments(tc[tg],tc[tg-1],vn.LEFT);for(let t=tg-2;t>=0;t--)tt.addNextSegment(tc[t],!0);tt.addLastSegment(),tt.addLineEndCap(tc[1],tc[0]),tt.closeRing()}computePointCurve(t,tt){switch(this._bufParams.getEndCapStyle()){case Ks.CAP_ROUND:tt.createCircle(t);break;case Ks.CAP_SQUARE:tt.createSquare(t)}}getLineCurve(t,tt){if(this._distance=tt,tt<0&&!this._bufParams.isSingleSided()||0===tt)return null;let ta=this.getSegGen(Math.abs(tt));return t.length<=1?this.computePointCurve(t[0],ta):this._bufParams.isSingleSided()?this.computeSingleSidedBufferCurve(t,tt<0,ta):this.computeLineBufferCurve(t,ta),ta.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,tt,ta){if(this._distance=ta,t.length<=2)return this.getLineCurve(t,ta);if(0===ta)return oi.copyCoordinates(t);let th=this.getSegGen(ta);return this.computeRingBufferCurve(t,tt,th),th.getCoordinates()}computeOffsetCurve(t,tt,ta){let th=this.simplifyTolerance(this._distance);if(tt){let tt=si.simplify(t,-th),tu=tt.length-1;ta.initSideSegments(tt[tu],tt[tu-1],vn.LEFT),ta.addFirstSegment();for(let t=tu-2;t>=0;t--)ta.addNextSegment(tt[t],!0)}else{let tt=si.simplify(t,th),tu=tt.length-1;ta.initSideSegments(tt[0],tt[1],vn.LEFT),ta.addFirstSegment();for(let t=2;t<=tu;t++)ta.addNextSegment(tt[t],!0)}ta.addLastSegment()}getSegGen(t){return new ri(this._precisionModel,this._bufParams,t)}getClass(){return oi}get interfaces_(){return[]}};oi.constructor_=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;let t=arguments[0],tt=arguments[1];this._precisionModel=t,this._bufParams=tt};let li=class li{constructor(){li.constructor_.apply(this,arguments)}findStabbedSegments(){if(1==arguments.length){let t=arguments[0],tt=new x;for(let ta=this._subgraphs.iterator();ta.hasNext();){let th=ta.next(),tu=th.getEnvelope();t.y<tu.getMinY()||t.y>tu.getMaxY()||this.findStabbedSegments(t,th.getDirectedEdges(),tt)}return tt}if(3==arguments.length){if(_(arguments[2],m)&&arguments[0]instanceof g&&arguments[1]instanceof Kn){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=tt.getEdge().getCoordinates();for(let tu=0;tu<th.length-1;tu++){if(this._seg.p0=th[tu],this._seg.p1=th[tu+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),Math.max(this._seg.p0.x,this._seg.p1.x)<t.x||this._seg.isHorizontal()||t.y<this._seg.p0.y||t.y>this._seg.p1.y||v.index(this._seg.p0,this._seg.p1,t)===v.RIGHT)continue;let tc=tt.getDepth(vn.LEFT);this._seg.p0.equals(th[tu])||(tc=tt.getDepth(vn.RIGHT));let tg=new ai(this._seg,tc);ta.add(tg)}}else if(_(arguments[2],m)&&arguments[0]instanceof g&&_(arguments[1],m)){let t=arguments[0],tt=arguments[1],ta=arguments[2];for(let th=tt.iterator();th.hasNext();){let tt=th.next();tt.isForward()&&this.findStabbedSegments(t,tt,ta)}}}}getDepth(t){let tt=this.findStabbedSegments(t);return 0===tt.size()?0:tu.min(tt)._leftDepth}getClass(){return li}get interfaces_(){return[]}};let ai=class ai{constructor(){ai.constructor_.apply(this,arguments)}compareTo(t){if(this._upwardSeg.minX()>=t._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=t._upwardSeg.minX())return -1;let tt=this._upwardSeg.orientationIndex(t._upwardSeg);return 0!==tt?tt:0!=(tt=-1*t._upwardSeg.orientationIndex(this._upwardSeg))?tt:this._upwardSeg.compareTo(t._upwardSeg)}compareX(t,tt){let ta=t.p0.compareTo(tt.p0);return 0!==ta?ta:t.p1.compareTo(tt.p1)}toString(){return this._upwardSeg.toString()}getClass(){return ai}get interfaces_(){return[r]}};ai.constructor_=function(){this._upwardSeg=null,this._leftDepth=null;let t=arguments[0],tt=arguments[1];this._upwardSeg=new ne(t),this._leftDepth=tt},li.DepthSegment=ai,li.constructor_=function(){this._subgraphs=null,this._seg=new ne;let t=arguments[0];this._subgraphs=t};let ci=class ci{constructor(){ci.constructor_.apply(this,arguments)}addPoint(t){if(this._distance<=0)return null;let tt=t.getCoordinates(),ta=this._curveBuilder.getLineCurve(tt,this._distance);this.addCurve(ta,se.EXTERIOR,se.INTERIOR)}addPolygon(t){let tt=this._distance,ta=vn.LEFT;this._distance<0&&(tt=-this._distance,ta=vn.RIGHT);let th=t.getExteriorRing(),tu=X.removeRepeatedPoints(th.getCoordinates());if(this._distance<0&&this.isErodedCompletely(th,this._distance)||this._distance<=0&&tu.length<3)return null;this.addPolygonRing(tu,tt,ta,se.EXTERIOR,se.INTERIOR);for(let th=0;th<t.getNumInteriorRing();th++){let tu=t.getInteriorRingN(th),tc=X.removeRepeatedPoints(tu.getCoordinates());this._distance>0&&this.isErodedCompletely(tu,-this._distance)||this.addPolygonRing(tc,tt,vn.opposite(ta),se.INTERIOR,se.EXTERIOR)}}isTriangleErodedCompletely(t,tt){let ta=new oe(t[0],t[1],t[2]),th=ta.inCentre();return D.pointToSegment(th,ta.p0,ta.p1)<Math.abs(tt)}addLineString(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;let tt=X.removeRepeatedPoints(t.getCoordinates()),ta=this._curveBuilder.getLineCurve(tt,this._distance);this.addCurve(ta,se.EXTERIOR,se.INTERIOR)}addCurve(t,tt,ta){if(null===t||t.length<2)return null;let th=new Gs(t,new Gn(0,se.BOUNDARY,tt,ta));this._curveList.add(th)}getCurves(){return this.add(this._inputGeom),this._curveList}addPolygonRing(t,tt,ta,th,tu){if(0===tt&&t.length<At.MINIMUM_VALID_SIZE)return null;let tc=th,tg=tu;t.length>=At.MINIMUM_VALID_SIZE&&v.isCCW(t)&&(tc=tu,tg=th,ta=vn.opposite(ta));let t_=this._curveBuilder.getRingCurve(t,ta,tt);this.addCurve(t_,tc,tg)}add(t){if(t.isEmpty())return null;if(t instanceof Mt)this.addPolygon(t);else if(t instanceof Rt)this.addLineString(t);else if(t instanceof vt)this.addPoint(t);else if(t instanceof Dt)this.addCollection(t);else if(t instanceof pt)this.addCollection(t);else if(t instanceof Ft)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}}isErodedCompletely(t,tt){let ta=t.getCoordinates();if(ta.length<4)return tt<0;if(4===ta.length)return this.isTriangleErodedCompletely(ta,tt);let th=t.getEnvelopeInternal(),tu=Math.min(th.getHeight(),th.getWidth());return tt<0&&2*Math.abs(tt)>tu}addCollection(t){for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);this.add(ta)}}getClass(){return ci}get interfaces_(){return[]}};ci.constructor_=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new x;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._inputGeom=t,this._distance=tt,this._curveBuilder=ta};let hi=class hi{constructor(){hi.constructor_.apply(this,arguments)}getNextCW(t){this.getEdges();let tt=this._edgeList.indexOf(t),ta=tt-1;return 0===tt&&(ta=this._edgeList.size()-1),this._edgeList.get(ta)}propagateSideLabels(t){let tt=se.NONE;for(let ta=this.iterator();ta.hasNext();){let th=ta.next().getLabel();th.isArea(t)&&th.getLocation(t,vn.LEFT)!==se.NONE&&(tt=th.getLocation(t,vn.LEFT))}if(tt===se.NONE)return null;let ta=tt;for(let tt=this.iterator();tt.hasNext();){let th=tt.next(),tu=th.getLabel();if(tu.getLocation(t,vn.ON)===se.NONE&&tu.setLocation(t,vn.ON,ta),tu.isArea(t)){let tt=tu.getLocation(t,vn.LEFT),tc=tu.getLocation(t,vn.RIGHT);if(tc!==se.NONE){if(tc!==ta)throw new jn("side location conflict",th.getCoordinate());tt===se.NONE&&u.shouldNeverReachHere("found single null side (at "+th.getCoordinate()+")"),ta=tt}else u.isTrue(tu.getLocation(t,vn.LEFT)===se.NONE,"found single null side"),tu.setLocation(t,vn.RIGHT,ta),tu.setLocation(t,vn.LEFT,ta)}}}getCoordinate(){let t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}print(t){O.out.println("EdgeEndStar:   "+this.getCoordinate());for(let tt=this.iterator();tt.hasNext();)tt.next().print(t)}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){let tt=this.getEdges();if(0>=tt.size())return!0;let ta=tt.size()-1,th=tt.get(ta).getLabel().getLocation(t,vn.LEFT);u.isTrue(th!==se.NONE,"Found unlabelled area edge");let tu=th;for(let tt=this.iterator();tt.hasNext();){let ta=tt.next().getLabel();u.isTrue(ta.isArea(t),"Found non-area edge");let th=ta.getLocation(t,vn.LEFT),tc=ta.getLocation(t,vn.RIGHT);if(th===tc||tc!==tu)return!1;tu=th}return!0}findIndex(t){this.iterator();for(let tt=0;tt<this._edgeList.size();tt++)if(this._edgeList.get(tt)===t)return tt;return -1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new x(this._edgeMap.values())),this._edgeList}getLocation(t,tt,ta){return this._ptInAreaLocation[t]===se.NONE&&(this._ptInAreaLocation[t]=Qe.locate(tt,ta[t].getGeometry())),this._ptInAreaLocation[t]}toString(){let t=new w;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let tt=this.iterator();tt.hasNext();){let ta=tt.next();t.append(ta),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let tt=this.iterator();tt.hasNext();)tt.next().computeLabel(t)}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);let tt=[!1,!1];for(let t=this.iterator();t.hasNext();){let ta=t.next().getLabel();for(let t=0;t<2;t++)ta.isLine(t)&&ta.getLocation(t)===se.BOUNDARY&&(tt[t]=!0)}for(let ta=this.iterator();ta.hasNext();){let th=ta.next(),tu=th.getLabel();for(let ta=0;ta<2;ta++)if(tu.isAnyNull(ta)){let tc=se.NONE;if(tt[ta])tc=se.EXTERIOR;else{let tt=th.getCoordinate();tc=this.getLocation(ta,tt,t)}tu.setAllLocationsIfNull(ta,tc)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,tt){this._edgeMap.put(t,tt),this._edgeList=null}getClass(){return hi}get interfaces_(){return[]}};hi.constructor_=function(){this._edgeMap=new ot,this._edgeList=null,this._ptInAreaLocation=[se.NONE,se.NONE]};let ui=class ui extends hi{constructor(){super(),ui.constructor_.apply(this,arguments)}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,tt=null,ta=this._SCANNING_FOR_INCOMING;for(let th=0;th<this._resultAreaEdgeList.size();th++){let tu=this._resultAreaEdgeList.get(th),tc=tu.getSym();if(tu.getLabel().isArea())switch(null===t&&tu.isInResult()&&(t=tu),ta){case this._SCANNING_FOR_INCOMING:if(!tc.isInResult())continue;tt=tc,ta=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!tu.isInResult())continue;tt.setNext(tu),ta=this._SCANNING_FOR_INCOMING}}if(ta===this._LINKING_TO_OUTGOING){if(null===t)throw new jn("no outgoing dirEdge found",this.getCoordinate());u.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),tt.setNext(t)}}insert(t){this.insertEdgeEnd(t,t)}getRightmostEdge(){let t=this.getEdges(),tt=t.size();if(tt<1)return null;let ta=t.get(0);if(1===tt)return ta;let th=t.get(tt-1),tu=ta.getQuadrant(),tc=th.getQuadrant();return Nn.isNorthern(tu)&&Nn.isNorthern(tc)?ta:Nn.isNorthern(tu)||Nn.isNorthern(tc)?0!==ta.getDy()?ta:0!==th.getDy()?th:(u.shouldNeverReachHere("found two horizontal edges incident on node"),null):th}print(t){O.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let tt=this.iterator();tt.hasNext();){let ta=tt.next();t.print("out "),ta.print(t),t.println(),t.print("in "),ta.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new x;for(let t=this.iterator();t.hasNext();){let tt=t.next();(tt.isInResult()||tt.getSym().isInResult())&&this._resultAreaEdgeList.add(tt)}return this._resultAreaEdgeList}updateLabelling(t){for(let tt=this.iterator();tt.hasNext();){let ta=tt.next().getLabel();ta.setAllLocationsIfNull(0,t.getLocation(0)),ta.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,tt=null;for(let ta=this._edgeList.size()-1;ta>=0;ta--){let th=this._edgeList.get(ta),tu=th.getSym();null===tt&&(tt=tu),null!==t&&tu.setNext(t),t=th}tt.setNext(t)}computeDepths(){if(1==arguments.length){let t=arguments[0],tt=this.findIndex(t),ta=t.getDepth(vn.LEFT),th=t.getDepth(vn.RIGHT),tu=this.computeDepths(tt+1,this._edgeList.size(),ta);if(this.computeDepths(0,tt,tu)!==th)throw new jn("depth mismatch at "+t.getCoordinate())}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];for(let th=t;th<tt;th++){let t=this._edgeList.get(th);t.setEdgeDepths(vn.RIGHT,ta),ta=t.getDepth(vn.LEFT)}return ta}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){let tt=t.next();tt.getLabel().merge(tt.getSym().getLabel())}}linkMinimalDirectedEdges(t){let tt=null,ta=null,th=this._SCANNING_FOR_INCOMING;for(let tu=this._resultAreaEdgeList.size()-1;tu>=0;tu--){let tc=this._resultAreaEdgeList.get(tu),tg=tc.getSym();switch(null===tt&&tc.getEdgeRing()===t&&(tt=tc),th){case this._SCANNING_FOR_INCOMING:if(tg.getEdgeRing()!==t)continue;ta=tg,th=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(tc.getEdgeRing()!==t)continue;ta.setNextMin(tc),th=this._SCANNING_FOR_INCOMING}}th===this._LINKING_TO_OUTGOING&&(u.isTrue(null!==tt,"found null for first outgoing dirEdge"),u.isTrue(tt.getEdgeRing()===t,"unable to link last incoming dirEdge"),ta.setNextMin(tt))}getOutgoingDegree(){if(0==arguments.length){let t=0;for(let tt=this.iterator();tt.hasNext();)tt.next().isInResult()&&t++;return t}if(1==arguments.length){let t=arguments[0],tt=0;for(let ta=this.iterator();ta.hasNext();)ta.next().getEdgeRing()===t&&tt++;return tt}}getLabel(){return this._label}findCoveredLineEdges(){let t=se.NONE;for(let tt=this.iterator();tt.hasNext();){let ta=tt.next(),th=ta.getSym();if(!ta.isLineEdge()){if(ta.isInResult()){t=se.INTERIOR;break}if(th.isInResult()){t=se.EXTERIOR;break}}}if(t===se.NONE)return null;let tt=t;for(let t=this.iterator();t.hasNext();){let ta=t.next(),th=ta.getSym();ta.isLineEdge()?ta.getEdge().setCovered(tt===se.INTERIOR):(ta.isInResult()&&(tt=se.EXTERIOR),th.isInResult()&&(tt=se.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Gn(se.NONE);for(let t=this.iterator();t.hasNext();){let tt=t.next().getEdge().getLabel();for(let t=0;t<2;t++){let ta=tt.getLocation(t);ta!==se.INTERIOR&&ta!==se.BOUNDARY||this._label.setLocation(t,se.INTERIOR)}}}getClass(){return ui}get interfaces_(){return[]}};ui.constructor_=function(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2};let gi=class gi extends Zn{constructor(){super(),gi.constructor_.apply(this,arguments)}createNode(t){return new Xn(t,new ui)}getClass(){return gi}get interfaces_(){return[]}};gi.constructor_=function(){};let di=class di{constructor(){di.constructor_.apply(this,arguments)}static orientation(t){return 1===X.increasingDirection(t)}static compareOriented(t,tt,ta,th){let tu=tt?1:-1,tc=th?1:-1,tg=tt?t.length:-1,t_=th?ta.length:-1,td=tt?0:t.length-1,tp=th?0:ta.length-1;for(;;){let tt=t[td].compareTo(ta[tp]);if(0!==tt)return tt;let th=(td+=tu)===tg,tf=(tp+=tc)===t_;if(th&&!tf)return -1;if(!th&&tf)return 1;if(th&&tf)return 0}}compareTo(t){return di.compareOriented(this._pts,this._orientation,t._pts,t._orientation)}getClass(){return di}get interfaces_(){return[r]}};di.constructor_=function(){this._pts=null,this._orientation=null;let t=arguments[0];this._pts=t,this._orientation=di.orientation(t)};let _i=class _i{constructor(){_i.constructor_.apply(this,arguments)}print(t){t.print("MULTILINESTRING ( ");for(let tt=0;tt<this._edges.size();tt++){let ta=this._edges.get(tt);tt>0&&t.print(","),t.print("(");let th=ta.getCoordinates();for(let tt=0;tt<th.length;tt++)tt>0&&t.print(","),t.print(th[tt].x+" "+th[tt].y);t.println(")")}t.print(")  ")}addAll(t){for(let tt=t.iterator();tt.hasNext();)this.add(tt.next())}findEdgeIndex(t){for(let tt=0;tt<this._edges.size();tt++)if(this._edges.get(tt).equals(t))return tt;return -1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){let tt=new di(t.getCoordinates());return this._ocaMap.get(tt)}add(t){this._edges.add(t);let tt=new di(t.getCoordinates());this._ocaMap.put(tt,t)}getClass(){return _i}get interfaces_(){return[]}};_i.constructor_=function(){this._edges=new x,this._ocaMap=new ot};let fi=class fi{constructor(){fi.constructor_.apply(this,arguments)}processIntersections(t,tt,ta,th){}isDone(){}getClass(){return fi}get interfaces_(){return[]}};fi.constructor_=function(){};let pi=class pi{constructor(){pi.constructor_.apply(this,arguments)}static isAdjacentSegments(t,tt){return 1===Math.abs(t-tt)}isTrivialIntersection(t,tt,ta,th){if(t===ta&&1===this._li.getIntersectionNum()){if(pi.isAdjacentSegments(tt,th))return!0;if(t.isClosed()){let ta=t.size()-1;if(0===tt&&th===ta||0===th&&tt===ta)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,tt,ta,th){if(t===ta&&tt===th)return null;this.numTests++;let tu=t.getCoordinates()[tt],tc=t.getCoordinates()[tt+1],tg=ta.getCoordinates()[th],t_=ta.getCoordinates()[th+1];this._li.computeIntersection(tu,tc,tg,t_),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,tt,ta,th)||(this._hasIntersection=!0,t.addIntersections(this._li,tt,0),ta.addIntersections(this._li,th,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}getClass(){return pi}get interfaces_(){return[fi]}};pi.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;let t=arguments[0];this._li=t};let mi=class mi{constructor(){mi.constructor_.apply(this,arguments)}static depthDelta(t){let tt=t.getLocation(0,vn.LEFT),ta=t.getLocation(0,vn.RIGHT);return tt===se.INTERIOR&&ta===se.EXTERIOR?1:tt===se.EXTERIOR&&ta===se.INTERIOR?-1:0}static convertSegStrings(t){let tt=new Wt,ta=new x;for(;t.hasNext();){let th=t.next(),tu=tt.createLineString(th.getCoordinates());ta.add(tu)}return tt.buildGeometry(ta)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){let tt=this._edgeList.findEqualEdge(t);if(null!==tt){let ta=tt.getLabel(),th=t.getLabel();tt.isPointwiseEqual(t)||(th=new Gn(t.getLabel())).flip(),ta.merge(th);let tu=mi.depthDelta(th),tc=tt.getDepthDelta()+tu;tt.setDepthDelta(tc)}else this._edgeList.add(t),t.setDepthDelta(mi.depthDelta(t.getLabel()))}buildSubgraphs(t,tt){let ta=new x;for(let th=t.iterator();th.hasNext();){let t=th.next(),tu=t.getRightmostCoordinate(),tc=new li(ta).getDepth(tu);t.computeDepth(tc),t.findResultEdges(),ta.add(t),tt.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){let tt=new x;for(let ta=t.getNodes().iterator();ta.hasNext();){let t=ta.next();if(!t.isVisited()){let ta=new Js;ta.create(t),tt.add(ta)}}return tu.sort(tt,tu.reverseOrder()),tt}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;let tt=new Us,ta=new ee;return ta.setPrecisionModel(t),tt.setSegmentIntersector(new pi(ta)),tt}buffer(t,tt){let ta=this._workingPrecisionModel;null===ta&&(ta=t.getPrecisionModel()),this._geomFact=t.getFactory();let th=new oi(ta,this._bufParams),tu=new ci(t,tt,th).getCurves();if(0>=tu.size())return this.createEmptyResultGeometry();this.computeNodedEdges(tu,ta),this._graph=new Qn(new gi),this._graph.addEdges(this._edgeList.getEdges());let tc=this.createSubgraphs(this._graph),tg=new ni(this._geomFact);this.buildSubgraphs(tc,tg);let t_=tg.getPolygons();return 0>=t_.size()?this.createEmptyResultGeometry():this._geomFact.buildGeometry(t_)}computeNodedEdges(t,tt){let ta=this.getNoder(tt);ta.computeNodes(t);for(let t=ta.getNodedSubstrings().iterator();t.hasNext();){let tt=t.next(),ta=tt.getCoordinates();if(2===ta.length&&ta[0].equals2D(ta[1]))continue;let th=tt.getData(),tu=new kn(tt.getCoordinates(),new Gn(th));this.insertUniqueEdge(tu)}}setNoder(t){this._workingNoder=t}getClass(){return mi}get interfaces_(){return[]}};mi.constructor_=function(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new _i;let t=arguments[0];this._bufParams=t};let yi=class yi{constructor(){yi.constructor_.apply(this,arguments)}checkEndPtVertexIntersections(){if(0==arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){let tt=t.next().getCoordinates();this.checkEndPtVertexIntersections(tt[0],this._segStrings),this.checkEndPtVertexIntersections(tt[tt.length-1],this._segStrings)}else if(2==arguments.length){let t=arguments[0];for(let tt=arguments[1].iterator();tt.hasNext();){let ta=tt.next().getCoordinates();for(let tt=1;tt<ta.length-1;tt++)if(ta[tt].equals(t))throw new c("found endpt/interior pt intersection at index "+tt+" :pt "+t)}}}checkInteriorIntersections(){if(0==arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){let tt=t.next();for(let t=this._segStrings.iterator();t.hasNext();){let ta=t.next();this.checkInteriorIntersections(tt,ta)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t.getCoordinates(),th=tt.getCoordinates();for(let tu=0;tu<ta.length-1;tu++)for(let ta=0;ta<th.length-1;ta++)this.checkInteriorIntersections(t,tu,tt,ta)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];if(t===ta&&tt===th)return null;let tu=t.getCoordinates()[tt],tc=t.getCoordinates()[tt+1],tg=ta.getCoordinates()[th],t_=ta.getCoordinates()[th+1];if(this._li.computeIntersection(tu,tc,tg,t_),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,tu,tc)||this.hasInteriorIntersection(this._li,tg,t_)))throw new c("found non-noded intersection at "+tu+"-"+tc+" and "+tg+"-"+t_)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0==arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){let tt=t.next();this.checkCollapses(tt)}else if(1==arguments.length){let t=arguments[0].getCoordinates();for(let tt=0;tt<t.length-2;tt++)this.checkCollapse(t[tt],t[tt+1],t[tt+2])}}hasInteriorIntersection(t,tt,ta){for(let th=0;th<t.getIntersectionNum();th++){let tu=t.getIntersection(th);if(!tu.equals(tt)&&!tu.equals(ta))return!0}return!1}checkCollapse(t,tt,ta){if(t.equals(ta))throw new c("found non-noded collapse at "+yi.fact.createLineString([t,tt,ta]))}getClass(){return yi}get interfaces_(){return[]}};yi.constructor_=function(){this._li=new ee,this._segStrings=null;let t=arguments[0];this._segStrings=t},yi.fact=new Wt;let xi=class xi{constructor(){xi.constructor_.apply(this,arguments)}intersectsScaled(t,tt){let ta=Math.min(t.x,tt.x),th=Math.max(t.x,tt.x),tu=Math.min(t.y,tt.y),tc=Math.max(t.y,tt.y),tg=this._maxx<ta||this._minx>th||this._maxy<tu||this._miny>tc;if(tg)return!1;let t_=this.intersectsToleranceSquare(t,tt);return u.isTrue(!(tg&&t_),"Found bad envelope test"),t_}initCorners(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new g(this._maxx,this._maxy),this._corner[1]=new g(this._minx,this._maxy),this._corner[2]=new g(this._minx,this._miny),this._corner[3]=new g(this._maxx,this._miny)}intersects(t,tt){return 1===this._scaleFactor?this.intersectsScaled(t,tt):(this.copyScaled(t,this._p0Scaled),this.copyScaled(tt,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,tt){tt.x=this.scale(t.x),tt.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){let t=xi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new N(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,tt){return this._li.computeIntersection(t,tt,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,tt,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,tt,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,tt,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,tt){let ta=!1,th=!1;return this._li.computeIntersection(t,tt,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,tt,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(ta=!0),this._li.computeIntersection(t,tt,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(th=!0),this._li.computeIntersection(t,tt,this._corner[3],this._corner[0]),!!this._li.isProper()||!(!ta||!th)||!!t.equals(this._pt)||!!tt.equals(this._pt))))}addSnappedNode(t,tt){let ta=t.getCoordinate(tt),th=t.getCoordinate(tt+1);return!!this.intersects(ta,th)&&(t.addIntersection(this.getCoordinate(),tt),!0)}getClass(){return xi}get interfaces_(){return[]}};xi.constructor_=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=[,,,,].fill(null),this._safeEnv=null;let t=arguments[0],tt=arguments[1],ta=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=tt,this._li=ta,tt<=0)throw new n("Scale factor must be non-zero");1!==tt&&(this._pt=new g(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new g,this._p1Scaled=new g),this.initCorners(this._pt)},xi.SAFE_ENV_EXPANSION_FACTOR=.75;let Ei=class Ei{constructor(){Ei.constructor_.apply(this,arguments)}select(){if(1==arguments.length);else if(2==arguments.length){let t=arguments[0],tt=arguments[1];t.getLineSegment(tt,this.selectedSegment),this.select(this.selectedSegment)}}getClass(){return Ei}get interfaces_(){return[]}};Ei.constructor_=function(){this.selectedSegment=new ne};let Ii=class Ii{constructor(){Ii.constructor_.apply(this,arguments)}snap(){if(1==arguments.length){let t=arguments[0];return this.snap(t,null,-1)}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=t.getSafeEnvelope(),tu=new Ni(t,tt,ta);return this._index.query(th,new class{get interfaces_(){return[Fe]}visitItem(t){t.select(th,tu)}}),tu.isNodeAdded()}}getClass(){return Ii}get interfaces_(){return[]}};let Ni=class Ni extends Ei{constructor(){super(),Ni.constructor_.apply(this,arguments)}isNodeAdded(){return this._isNodeAdded}select(){if(!(2==arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof Bs))return super.select.apply(this,arguments);{let t=arguments[0],tt=arguments[1],ta=t.getContext();if(null!==this._parentEdge&&ta===this._parentEdge&&tt===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(ta,tt)}}getClass(){return Ni}get interfaces_(){return[]}};Ni.constructor_=function(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._hotPixel=t,this._parentEdge=tt,this._hotPixelVertexIndex=ta},Ii.HotPixelSnapAction=Ni,Ii.constructor_=function(){this._index=null;let t=arguments[0];this._index=t};let Ci=class Ci{constructor(){Ci.constructor_.apply(this,arguments)}processIntersections(t,tt,ta,th){if(t===ta&&tt===th)return null;let tu=t.getCoordinates()[tt],tc=t.getCoordinates()[tt+1],tg=ta.getCoordinates()[th],t_=ta.getCoordinates()[th+1];if(this._li.computeIntersection(tu,tc,tg,t_),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,tt,0),ta.addIntersections(this._li,th,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}getClass(){return Ci}get interfaces_(){return[fi]}};Ci.constructor_=function(){this._li=null,this._interiorIntersections=null;let t=arguments[0];this._li=t,this._interiorIntersections=new x};let Si=class Si{constructor(){Si.constructor_.apply(this,arguments)}checkCorrectness(t){let tt=Gs.getNodedSubstrings(t),ta=new yi(tt);try{ta.checkValid()}catch(t){if(!(t instanceof C))throw t;t.printStackTrace()}}getNodedSubstrings(){return Gs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,tt){let ta=this.findInteriorIntersections(t,tt);this.computeIntersectionSnaps(ta),this.computeVertexSnaps(t)}findInteriorIntersections(t,tt){let ta=new Ci(tt);return this._noder.setSegmentIntersector(ta),this._noder.computeNodes(t),ta.getInteriorIntersections()}computeVertexSnaps(){if(_(arguments[0],f))for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.computeVertexSnaps(tt)}else if(arguments[0]instanceof Gs){let t=arguments[0],tt=t.getCoordinates();for(let ta=0;ta<tt.length;ta++){let th=new xi(tt[ta],this._scaleFactor,this._li);this._pointSnapper.snap(th,t,ta)&&t.addIntersection(tt[ta],ta)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new Us,this._pointSnapper=new Ii(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next(),ta=new xi(t,this._scaleFactor,this._li);this._pointSnapper.snap(ta)}}getClass(){return Si}get interfaces_(){return[zs]}};Si.constructor_=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;let t=arguments[0];this._pm=t,this._li=new ee,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()};let wi=class wi{constructor(){wi.constructor_.apply(this,arguments)}static bufferOp(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new wi(t).getResultGeometry(tt)}if(3==arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof q&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=new wi(t);return th.setQuadrantSegments(ta),th.getResultGeometry(tt)}if(arguments[2]instanceof Ks&&arguments[0]instanceof q&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1],ta=arguments[2];return new wi(t,ta).getResultGeometry(tt)}}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=new wi(t);return tu.setQuadrantSegments(ta),tu.setEndCapStyle(th),tu.getResultGeometry(tt)}}static precisionScaleFactor(t,tt,ta){let th=t.getEnvelopeInternal(),tu=M.max(Math.abs(th.getMaxX()),Math.abs(th.getMaxY()),Math.abs(th.getMinX()),Math.abs(th.getMinY()))+2*(tt>0?tt:0);return Math.pow(10,ta-Math.trunc(Math.log(tu)/Math.log(10)+1))}bufferFixedPrecision(t){let tt=new Xs(new Si(new Xt(1)),t.getScale()),ta=new mi(this._bufParams);ta.setWorkingPrecisionModel(t),ta.setNoder(tt),this._resultGeometry=ta.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0==arguments.length){for(let t=wi.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof jn))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1==arguments.length){let t=arguments[0],tt=wi.precisionScaleFactor(this._argGeom,this._distance,t),ta=new Xt(tt);this.bufferFixedPrecision(ta)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;let t=this._argGeom.getFactory().getPrecisionModel();t.getType()===Xt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{let t=new mi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof c))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}getClass(){return wi}get interfaces_(){return[]}};wi.constructor_=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new Ks,this._resultGeometry=null,this._saveException=null,1==arguments.length){let t=arguments[0];this._argGeom=t}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._argGeom=t,this._bufParams=tt}},wi.CAP_ROUND=Ks.CAP_ROUND,wi.CAP_BUTT=Ks.CAP_FLAT,wi.CAP_FLAT=Ks.CAP_FLAT,wi.CAP_SQUARE=Ks.CAP_SQUARE,wi.MAX_PRECISION_DIGITS=12;var tw=Object.freeze({__proto__:null,BufferOp:wi,BufferParameters:Ks});let Ti=class Ti{constructor(){Ti.constructor_.apply(this,arguments)}isInsideArea(){return this._segIndex===Ti.INSIDE_AREA}getCoordinate(){return this._pt}getGeometryComponent(){return this._component}getSegmentIndex(){return this._segIndex}getClass(){return Ti}get interfaces_(){return[]}};Ti.constructor_=function(){if(this._component=null,this._segIndex=null,this._pt=null,2==arguments.length){let t=arguments[0],tt=arguments[1];Ti.constructor_.call(this,t,Ti.INSIDE_AREA,tt)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._component=t,this._segIndex=tt,this._pt=ta}},Ti.INSIDE_AREA=-1;let Ri=class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static getLocations(t){let tt=new x;return t.apply(new Ri(tt)),tt}filter(t){(t instanceof vt||t instanceof Rt||t instanceof Mt)&&this._locations.add(new Ti(t,0,t.getCoordinate()))}getClass(){return Ri}get interfaces_(){return[dt]}};Ri.constructor_=function(){this._locations=null;let t=arguments[0];this._locations=t};let Pi=class Pi{constructor(){Pi.constructor_.apply(this,arguments)}static distance(t,tt){return new Pi(t,tt).distance()}static isWithinDistance(t,tt,ta){return!(t.getEnvelopeInternal().distance(tt.getEnvelopeInternal())>ta)&&new Pi(t,tt,ta).distance()<=ta}static nearestPoints(t,tt){return new Pi(t,tt).nearestPoints()}computeContainmentDistance(){if(0==arguments.length){let t=[,,].fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=this._geom[t];if(2>ta.getDimension())return null;let th=1-t,tu=Ce.getPolygons(ta);if(tu.size()>0){let ta=Ri.getLocations(this._geom[th]);if(this.computeContainmentDistance(ta,tu,tt),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[th]=tt[0],this._minDistanceLocation[t]=tt[1],null}}else if(3==arguments.length){if(arguments[2]instanceof Array&&_(arguments[0],m)&&_(arguments[1],m)){let t=arguments[0],tt=arguments[1],ta=arguments[2];for(let th=0;th<t.size();th++){let tu=t.get(th);for(let t=0;t<tt.size();t++)if(this.computeContainmentDistance(tu,tt.get(t),ta),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Ti&&arguments[1]instanceof Mt){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=t.getCoordinate();if(se.EXTERIOR!==this._ptLocator.locate(th,tt))return this._minDistance=0,ta[0]=t,ta[1]=new Ti(tt,th),null}}}computeMinDistanceLinesPoints(t,tt,ta){for(let th=0;th<t.size();th++){let tu=t.get(th);for(let t=0;t<tt.size();t++){let th=tt.get(t);if(this.computeMinDistance(tu,th,ta),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){let t=[,,].fill(null),tt=Ee.getLines(this._geom[0]),ta=Ee.getLines(this._geom[1]),th=Ne.getPoints(this._geom[0]),tu=Ne.getPoints(this._geom[1]);return this.computeMinDistanceLines(tt,ta,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(tt,tu,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(ta,th,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(th,tu,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,tt){if(null===t[0])return null;tt?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0==arguments.length){if(null!==this._minDistanceLocation||(this._minDistanceLocation=[,,].fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance))return null;this.computeFacetDistance()}else if(3==arguments.length){if(arguments[2]instanceof Array&&arguments[0]instanceof Rt&&arguments[1]instanceof vt){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(t.getEnvelopeInternal().distance(tt.getEnvelopeInternal())>this._minDistance)return null;let th=t.getCoordinates(),tu=tt.getCoordinate();for(let tc=0;tc<th.length-1;tc++){let tg=D.pointToSegment(tu,th[tc],th[tc+1]);if(tg<this._minDistance){this._minDistance=tg;let t_=new ne(th[tc],th[tc+1]).closestPoint(tu);ta[0]=new Ti(t,tc,t_),ta[1]=new Ti(tt,0,tu)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Rt&&arguments[1]instanceof Rt){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(t.getEnvelopeInternal().distance(tt.getEnvelopeInternal())>this._minDistance)return null;let th=t.getCoordinates(),tu=tt.getCoordinates();for(let tc=0;tc<th.length-1;tc++)for(let tg=0;tg<tu.length-1;tg++){let t_=D.segmentToSegment(th[tc],th[tc+1],tu[tg],tu[tg+1]);if(t_<this._minDistance){this._minDistance=t_;let td=new ne(th[tc],th[tc+1]),tp=new ne(tu[tg],tu[tg+1]),tf=td.closestPoints(tp);ta[0]=new Ti(t,tc,tf[0]),ta[1]=new Ti(tt,tg,tf[1])}if(this._minDistance<=this._terminateDistance)return null}}}}computeMinDistancePoints(t,tt,ta){for(let th=0;th<t.size();th++){let tu=t.get(th);for(let t=0;t<tt.size();t++){let th=tt.get(t),tc=tu.getCoordinate().distance(th.getCoordinate());if(tc<this._minDistance&&(this._minDistance=tc,ta[0]=new Ti(tu,0,tu.getCoordinate()),ta[1]=new Ti(th,0,th.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new n("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,tt,ta){for(let th=0;th<t.size();th++){let tu=t.get(th);for(let t=0;t<tt.size();t++){let th=tt.get(t);if(this.computeMinDistance(tu,th,ta),this._minDistance<=this._terminateDistance)return null}}}getClass(){return Pi}get interfaces_(){return[]}};Pi.constructor_=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new fn,this._minDistanceLocation=null,this._minDistance=i.MAX_VALUE,2==arguments.length){let t=arguments[0],tt=arguments[1];Pi.constructor_.call(this,t,tt,0)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._geom=[,,].fill(null),this._geom[0]=t,this._geom[1]=tt,this._terminateDistance=ta}};var tT=Object.freeze({__proto__:null,DistanceOp:Pi});let Oi=class Oi{constructor(){Oi.constructor_.apply(this,arguments)}getCoordinates(){if(null===this._coordinates){let t=0,tt=0,ta=new I;for(let th=this._directedEdges.iterator();th.hasNext();){let tu=th.next();tu.getEdgeDirection()?t++:tt++,ta.add(tu.getEdge().getLine().getCoordinates(),!1,tu.getEdgeDirection())}this._coordinates=ta.toCoordinateArray(),tt>t&&X.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}getClass(){return Oi}get interfaces_(){return[]}};Oi.constructor_=function(){this._factory=null,this._directedEdges=new x,this._coordinates=null;let t=arguments[0];this._factory=t};let bi=class bi{constructor(){bi.constructor_.apply(this,arguments)}static getComponentWithVisitedState(t,tt){for(;t.hasNext();){let ta=t.next();if(ta.isVisited()===tt)return ta}return null}static setVisited(t,tt){for(;t.hasNext();)t.next().setVisited(tt)}static setMarked(t,tt){for(;t.hasNext();)t.next().setMarked(tt)}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}getClass(){return bi}get interfaces_(){return[]}};bi.constructor_=function(){this._isMarked=!1,this._isVisited=!1,this._data=null};let Mi=class Mi extends bi{constructor(){super(),Mi.constructor_.apply(this,arguments)}static toEdges(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();)tt.add(ta.next()._parentEdge);return tt}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){let tt=this.getClass().getName(),ta=tt.lastIndexOf("."),th=tt.substring(ta+1);t.print("  "+th+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){return this.compareDirection(t)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}getClass(){return Mi}get interfaces_(){return[r]}};Mi.constructor_=function(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0==arguments.length);else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this._from=t,this._to=tt,this._edgeDirection=th,this._p0=t.getCoordinate(),this._p1=ta;let tu=this._p1.x-this._p0.x,tc=this._p1.y-this._p0.y;this._quadrant=Nn.quadrant(tu,tc),this._angle=Math.atan2(tc,tu)}};let Di=class Di extends Mi{constructor(){super(),Di.constructor_.apply(this,arguments)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(u.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}getClass(){return Di}get interfaces_(){return[]}};Di.constructor_=function(){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];Mi.constructor_.call(this,t,tt,ta,th)};let Ai=class Ai extends bi{constructor(){super(),Ai.constructor_.apply(this,arguments)}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,tt){this._dirEdge=[t,tt],t.setEdge(this),tt.setEdge(this),t.setSym(tt),tt.setSym(t),t.getFromNode().addOutEdge(t),tt.getFromNode().addOutEdge(tt)}getDirEdge(){if(Number.isInteger(arguments[0])){let t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Gi){let t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}getClass(){return Ai}get interfaces_(){return[]}};Ai.constructor_=function(){if(this._dirEdge=null,0==arguments.length);else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this.setDirectedEdges(t,tt)}};let Fi=class Fi{constructor(){Fi.constructor_.apply(this,arguments)}getNextEdge(t){let tt=this.getIndex(t);return this._outEdges.get(this.getIndex(tt+1))}getCoordinate(){let t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(tu.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){let tt=this.getIndex(t);return this._outEdges.get(this.getIndex(tt-1))}getIndex(){if(arguments[0]instanceof Ai){let t=arguments[0];this.sortEdges();for(let tt=0;tt<this._outEdges.size();tt++)if(this._outEdges.get(tt).getEdge()===t)return tt;return -1}if(arguments[0]instanceof Mi){let t=arguments[0];this.sortEdges();for(let tt=0;tt<this._outEdges.size();tt++)if(this._outEdges.get(tt)===t)return tt;return -1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}getClass(){return Fi}get interfaces_(){return[]}};Fi.constructor_=function(){this._outEdges=new x,this._sorted=!1};let Gi=class Gi extends bi{constructor(){super(),Gi.constructor_.apply(this,arguments)}static getEdgesBetween(t,tt){let ta=new J(Mi.toEdges(t.getOutEdges().getEdges())),th=Mi.toEdges(tt.getOutEdges().getEdges());return ta.retainAll(th),ta}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0==arguments.length)this._pt=null;else if(1==arguments.length){let t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}getClass(){return Gi}get interfaces_(){return[]}};Gi.constructor_=function(){if(this._pt=null,this._deStar=null,1==arguments.length){let t=arguments[0];Gi.constructor_.call(this,t,new Fi)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._pt=t,this._deStar=tt}};let qi=class qi extends Ai{constructor(){super(),qi.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return qi}get interfaces_(){return[]}};qi.constructor_=function(){this._line=null;let t=arguments[0];this._line=t};let Bi=class Bi{constructor(){Bi.constructor_.apply(this,arguments)}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}getClass(){return Bi}get interfaces_(){return[]}};Bi.constructor_=function(){this._nodeMap=new ot};let Vi=class Vi{constructor(){Vi.constructor_.apply(this,arguments)}findNodesOfDegree(t){let tt=new x;for(let ta=this.nodeIterator();ta.hasNext();){let th=ta.next();th.getDegree()===t&&tt.add(th)}return tt}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Ai){let t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof Mi){let t=arguments[0],tt=t.getSym();null!==tt&&tt.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Gi){let t=arguments[0];for(let tt=t.getOutEdges().getEdges().iterator();tt.hasNext();){let t=tt.next(),ta=t.getSym();null!==ta&&this.remove(ta),this._dirEdges.remove(t);let th=t.getEdge();null!==th&&this._edges.remove(th)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Ai){let t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof Mi){let t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Gi){let t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Ai){let t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof Mi){let t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}getClass(){return Vi}get interfaces_(){return[]}};Vi.constructor_=function(){this._edges=new J,this._dirEdges=new J,this._nodeMap=new Bi};let zi=class zi extends Vi{constructor(){super(),zi.constructor_.apply(this,arguments)}addEdge(t){if(t.isEmpty())return null;let tt=X.removeRepeatedPoints(t.getCoordinates());if(tt.length<=1)return null;let ta=tt[0],th=tt[tt.length-1],tu=this.getNode(ta),tc=this.getNode(th),tg=new Di(tu,tc,tt[1],!0),t_=new Di(tc,tu,tt[tt.length-2],!1),td=new qi(t);td.setDirectedEdges(tg,t_),this.add(td)}getNode(t){let tt=this.findNode(t);return null===tt&&(tt=new Gi(t),this.add(tt)),tt}getClass(){return zi}get interfaces_(){return[]}};zi.constructor_=function(){};let Yi=class Yi{constructor(){Yi.constructor_.apply(this,arguments)}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){let tt=t.next();tt.isMarked()||(u.isTrue(2===tt.getDegree()),this.buildEdgeStringsStartingAt(tt),tt.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){let tt=t.next();2!==tt.getDegree()&&(this.buildEdgeStringsStartingAt(tt),tt.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let tt=t.getOutEdges().iterator();tt.hasNext();){let t=tt.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;bi.setMarked(this._graph.nodeIterator(),!1),bi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new x,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new x;for(let t=this._edgeStrings.iterator();t.hasNext();){let tt=t.next();this._mergedLineStrings.add(tt.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){let tt=new Oi(this._factory),ta=t;do tt.add(ta),ta.getEdge().setMarked(!0),ta=ta.getNext();while(null!==ta&&ta!==t);return tt}add(){if(arguments[0]instanceof q){let t=arguments[0];for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);ta instanceof Rt&&this.addLineString(ta)}}else if(_(arguments[0],f)){let t=arguments[0];this._mergedLineStrings=null;for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}getClass(){return Yi}get interfaces_(){return[]}};Yi.constructor_=function(){this._graph=new zi,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null};let Ui=class Ui{constructor(){Ui.constructor_.apply(this,arguments)}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}getClass(){return Ui}get interfaces_(){return[]}};Ui.constructor_=function(){this._parentGraph=null,this._edges=new J,this._dirEdges=new x,this._nodeMap=new Bi;let t=arguments[0];this._parentGraph=t};let ki=class ki{constructor(){ki.constructor_.apply(this,arguments)}addReachable(t,tt){let ta=new ln;for(ta.add(t);!ta.empty();){let t=ta.pop();this.addEdges(t,ta,tt)}}findSubgraph(t){let tt=new Ui(this._graph);return this.addReachable(t,tt),tt}getConnectedSubgraphs(){let t=new x;bi.setVisited(this._graph.nodeIterator(),!1);for(let tt=this._graph.edgeIterator();tt.hasNext();){let ta=tt.next().getDirEdge(0).getFromNode();ta.isVisited()||t.add(this.findSubgraph(ta))}return t}addEdges(t,tt,ta){t.setVisited(!0);for(let th=t.getOutEdges().iterator();th.hasNext();){let t=th.next();ta.add(t.getEdge());let tu=t.getToNode();tu.isVisited()||tt.push(tu)}}getClass(){return ki}get interfaces_(){return[]}};ki.constructor_=function(){this._graph=null;let t=arguments[0];this._graph=t};let Xi=class Xi{constructor(){Xi.constructor_.apply(this,arguments)}static findUnvisitedBestOrientedDE(t){let tt=null,ta=null;for(let th=t.getOutEdges().iterator();th.hasNext();){let t=th.next();t.getEdge().isVisited()||(ta=t,t.getEdgeDirection()&&(tt=t))}return null!==tt?tt:ta}static findLowestDegreeNode(t){let tt=L.MAX_VALUE,ta=null;for(let th=t.nodeIterator();th.hasNext();){let t=th.next();(null===ta||t.getDegree()<tt)&&(tt=t.getDegree(),ta=t)}return ta}static isSequenced(t){if(!(t instanceof pt))return!0;let tt=new ct,ta=null,th=new x;for(let tu=0;tu<t.getNumGeometries();tu++){let tc=t.getGeometryN(tu),tg=tc.getCoordinateN(0),t_=tc.getCoordinateN(tc.getNumPoints()-1);if(tt.contains(tg)||tt.contains(t_))return!1;null!==ta&&(tg.equals(ta)||(tt.addAll(th),th.clear())),th.add(tg),th.add(t_),ta=t_}return!0}static reverse(t){let tt=t.getCoordinates(),ta=Array(tt.length).fill(null),th=tt.length;for(let t=0;t<th;t++)ta[th-1-t]=new g(tt[t]);return t.getFactory().createLineString(ta)}static sequence(t){let tt=new Xi;return tt.add(t),tt.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let tt=0;for(let ta=t.nodeIterator();ta.hasNext();)ta.next().getDegree()%2==1&&tt++;return tt<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;let t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;let tt=this._sequencedGeometry.getNumGeometries();u.isTrue(this._lineCount===tt,"Lines were missing from result"),u.isTrue(this._sequencedGeometry instanceof Rt||this._sequencedGeometry instanceof pt,"Result is not lineal")}findSequences(){let t=new x;for(let tt=new ki(this._graph).getConnectedSubgraphs().iterator();tt.hasNext();){let ta=tt.next();if(!this.hasSequence(ta))return null;{let tt=this.findSequence(ta);t.add(tt)}}return t}addReverseSubpath(t,tt,ta){let th=t.getToNode(),tu=null;for(;;){tt.add(t.getSym()),t.getEdge().setVisited(!0),tu=t.getFromNode();let ta=Xi.findUnvisitedBestOrientedDE(tu);if(null===ta)break;t=ta.getSym()}ta&&u.isTrue(tu===th,"path not contiguous")}findSequence(t){bi.setVisited(t.edgeIterator(),!1);let tt=Xi.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),ta=new Qs,th=ta.listIterator();for(this.addReverseSubpath(tt,th,!1);th.hasPrevious();){let t=th.previous(),tt=Xi.findUnvisitedBestOrientedDE(t.getFromNode());null!==tt&&this.addReverseSubpath(tt.getSym(),th,!0)}return this.orient(ta)}reverse(t){let tt=new Qs;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt.addFirst(t.getSym())}return tt}orient(t){let tt=t.get(0),ta=t.get(t.size()-1),th=tt.getFromNode(),tu=ta.getToNode(),tc=!1;if(1===th.getDegree()||1===tu.getDegree()){let t=!1;1===ta.getToNode().getDegree()&&!1===ta.getEdgeDirection()&&(t=!0,tc=!0),1===tt.getFromNode().getDegree()&&!0===tt.getEdgeDirection()&&(t=!0,tc=!1),t||1===tt.getFromNode().getDegree()&&(tc=!0)}return tc?this.reverse(t):t}buildSequencedGeometry(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();)for(let t=ta.next().iterator();t.hasNext();){let ta=t.next(),th=ta.getEdge().getLine(),tu=th;ta.getEdgeDirection()||th.isClosed()||(tu=Xi.reverse(th)),tt.add(tu)}return 0===tt.size()?this._factory.createMultiLineString([].fill(null)):this._factory.buildGeometry(tt)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(_(arguments[0],f))for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.add(tt)}else arguments[0]instanceof q&&arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Rt&&this.addLine(t)}})}getClass(){return Xi}get interfaces_(){return[]}};Xi.constructor_=function(){this._graph=new zi,this._factory=new Wt,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1};var tv=Object.freeze({__proto__:null,LineMerger:Yi,LineSequencer:Xi});let Wi=class Wi{constructor(){Wi.constructor_.apply(this,arguments)}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,tt){let ta=this._isClosed?t.size()-1:t.size();for(let th=0;th<ta;th++){let ta=t.get(th),tu=this.findSnapForVertex(ta,tt);null!==tu&&(t.set(th,new g(tu)),0===th&&this._isClosed&&t.set(t.size()-1,new g(tu)))}}findSnapForVertex(t,tt){for(let ta=0;ta<tt.length&&!t.equals2D(tt[ta]);ta++)if(t.distance(tt[ta])<this._snapTolerance)return tt[ta];return null}snapTo(t){let tt=new I(this._srcPts);return this.snapVertices(tt,t),this.snapSegments(tt,t),tt.toCoordinateArray()}snapSegments(t,tt){if(0===tt.length)return null;let ta=tt.length;tt[0].equals2D(tt[tt.length-1])&&(ta=tt.length-1);for(let th=0;th<ta;th++){let ta=tt[th],tu=this.findSegmentIndexToSnap(ta,t);tu>=0&&t.add(tu+1,new g(ta),!1)}}findSegmentIndexToSnap(t,tt){let ta=i.MAX_VALUE,th=-1;for(let tu=0;tu<tt.size()-1;tu++){if(this._seg.p0=tt.get(tu),this._seg.p1=tt.get(tu+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return -1}let tc=this._seg.distance(t);tc<this._snapTolerance&&tc<ta&&(ta=tc,th=tu)}return th}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}getClass(){return Wi}get interfaces_(){return[]}};Wi.constructor_=function(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new ne,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Rt&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];Wi.constructor_.call(this,t.getCoordinates(),tt)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){let t=arguments[0],tt=arguments[1];this._srcPts=t,this._isClosed=Wi.isClosed(t),this._snapTolerance=tt}};let ji=class ji{constructor(){ji.constructor_.apply(this,arguments)}static snap(t,tt,ta){let th=[,,].fill(null),tu=new ji(t);th[0]=tu.snapTo(tt,ta);let tc=new ji(tt);return th[1]=tc.snapTo(th[0],ta),th}static computeOverlaySnapTolerance(){if(1==arguments.length){let t=arguments[0],tt=ji.computeSizeBasedSnapTolerance(t),ta=t.getPrecisionModel();if(ta.getType()===Xt.FIXED){let t=1/ta.getScale()*2/1.415;t>tt&&(tt=t)}return tt}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return Math.min(ji.computeOverlaySnapTolerance(t),ji.computeOverlaySnapTolerance(tt))}}static computeSizeBasedSnapTolerance(t){let tt=t.getEnvelopeInternal();return Math.min(tt.getHeight(),tt.getWidth())*ji.SNAP_PRECISION_FACTOR}static snapToSelf(t,tt,ta){return new ji(t).snapToSelf(tt,ta)}snapTo(t,tt){let ta=this.extractTargetCoordinates(t);return new Ki(tt,ta).transform(this._srcGeom)}snapToSelf(t,tt){let ta=this.extractTargetCoordinates(this._srcGeom),th=new Ki(t,ta,!0).transform(this._srcGeom),tu=th;return tt&&_(tu,bt)&&(tu=th.buffer(0)),tu}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){let tt=new ct,ta=t.getCoordinates();for(let t=0;t<ta.length;t++)tt.add(ta[t]);return tt.toArray([].fill(null))}computeMinimumSegmentLength(t){let tt=i.MAX_VALUE;for(let ta=0;ta<t.length-1;ta++){let th=t[ta].distance(t[ta+1]);th<tt&&(tt=th)}return tt}getClass(){return ji}get interfaces_(){return[]}};ji.constructor_=function(){this._srcGeom=null;let t=arguments[0];this._srcGeom=t},ji.SNAP_PRECISION_FACTOR=1e-9;let Ki=class Ki extends ye{constructor(){super(),Ki.constructor_.apply(this,arguments)}snapLine(t,tt){let ta=new Wi(t,this._snapTolerance);return ta.setAllowSnappingToSourceVertices(this._isSelfSnap),ta.snapTo(tt)}transformCoordinates(t,tt){let ta=t.toCoordinateArray(),th=this.snapLine(ta,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(th)}getClass(){return Ki}get interfaces_(){return[]}};Ki.constructor_=function(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2==arguments.length){let t=arguments[0],tt=arguments[1];this._snapTolerance=t,this._snapPts=tt}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._snapTolerance=t,this._snapPts=tt,this._isSelfSnap=ta}};var tP=Object.freeze({__proto__:null,GeometrySnapper:ji,LineStringSnapper:Wi});let Qi=class Qi{constructor(){Qi.constructor_.apply(this,arguments)}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Ds.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return $t.toLineString(new Yt(this._pts))}getClass(){return Qi}get interfaces_(){return[As]}};Qi.constructor_=function(){this._pts=null,this._data=null;let t=arguments[0],tt=arguments[1];this._pts=t,this._data=tt};let Ji=class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static createAllIntersectionsFinder(t){let tt=new Ji(t);return tt.setFindAllIntersections(!0),tt}static createAnyIntersectionFinder(t){return new Ji(t)}static createIntersectionCounter(t){let tt=new Ji(t);return tt.setFindAllIntersections(!0),tt.setKeepIntersections(!1),tt}getInteriorIntersection(){return this._interiorIntersection}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}processIntersections(t,tt,ta,th){if(!this._findAllIntersections&&this.hasIntersection()||t===ta&&tt===th||this._isCheckEndSegmentsOnly&&!(this.isEndSegment(t,tt)||this.isEndSegment(ta,th)))return null;let tu=t.getCoordinates()[tt],tc=t.getCoordinates()[tt+1],tg=ta.getCoordinates()[th],t_=ta.getCoordinates()[th+1];this._li.computeIntersection(tu,tc,tg,t_),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=[,,,,].fill(null),this._intSegments[0]=tu,this._intSegments[1]=tc,this._intSegments[2]=tg,this._intSegments[3]=t_,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}isEndSegment(t,tt){return 0===tt||tt>=t.size()-2}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}getClass(){return Ji}get interfaces_(){return[fi]}};Ji.constructor_=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new x,this._intersectionCount=0,this._keepIntersections=!0;let t=arguments[0];this._li=t,this._interiorIntersection=null};let $i=class $i{constructor(){$i.constructor_.apply(this,arguments)}static computeIntersections(t){let tt=new $i(t);return tt.setFindAllIntersections(!0),tt.isValid(),tt.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new Ji(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);let t=new Us;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new jn(this.getErrorMessage(),this._segInt.getInteriorIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";let t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+$t.toLineString(t[0],t[1])+" and "+$t.toLineString(t[2],t[3])}getClass(){return $i}get interfaces_(){return[]}};$i.constructor_=function(){this._li=new ee,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;let t=arguments[0];this._segStrings=t};let tr=class tr{constructor(){tr.constructor_.apply(this,arguments)}static toSegmentStrings(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt.add(new Qi(t.getCoordinates(),t))}return tt}static checkValid(t){new tr(t).checkValid()}checkValid(){this._nv.checkValid()}getClass(){return tr}get interfaces_(){return[]}};tr.constructor_=function(){this._nv=null;let t=arguments[0];this._nv=new $i(tr.toSegmentStrings(t))};let er=class er{constructor(){er.constructor_.apply(this,arguments)}collectLines(t){for(let tt=this._op.getGraph().getEdgeEnds().iterator();tt.hasNext();){let ta=tt.next();this.collectLineEdge(ta,t,this._lineEdgesList),this.collectBoundaryTouchEdge(ta,t,this._lineEdgesList)}}labelIsolatedLine(t,tt){let ta=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(tt));t.getLabel().setLocation(tt,ta)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,tt,ta){let th=t.getLabel(),tu=t.getEdge();t.isLineEdge()&&(t.isVisited()||!hr.isResultOfOp(th,tt)||tu.isCovered()||(ta.add(tu),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();)t.next().getEdges().findCoveredLineEdges();for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){let tt=t.next(),ta=tt.getEdge();if(tt.isLineEdge()&&!ta.isCoveredSet()){let t=this._op.isCoveredByA(tt.getCoordinate());ta.setCovered(t)}}}labelIsolatedLines(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next(),ta=t.getLabel();t.isIsolated()&&(ta.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){let tt=t.next(),ta=(tt.getLabel(),this._geometryFactory.createLineString(tt.getCoordinates()));this._resultLineList.add(ta),tt.setInResult(!0)}}collectBoundaryTouchEdge(t,tt,ta){let th=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(u.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(hr.isResultOfOp(th,tt)&&tt===hr.INTERSECTION&&(ta.add(t.getEdge()),t.setVisitedEdge(!0))))}getClass(){return er}get interfaces_(){return[]}};er.constructor_=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new x,this._resultLineList=new x;let t=arguments[0],tt=arguments[1],ta=arguments[2];this._op=t,this._geometryFactory=tt,this._ptLocator=ta};let nr=class nr{constructor(){nr.constructor_.apply(this,arguments)}filterCoveredNodeToPoint(t){let tt=t.getCoordinate();if(!this._op.isCoveredByLA(tt)){let t=this._geometryFactory.createPoint(tt);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let tt=this._op.getGraph().getNodes().iterator();tt.hasNext();){let ta=tt.next();if(!ta.isInResult()&&!ta.isIncidentEdgeInResult()&&(0===ta.getEdges().getDegree()||t===hr.INTERSECTION)){let tt=ta.getLabel();hr.isResultOfOp(tt,t)&&this.filterCoveredNodeToPoint(ta)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}getClass(){return nr}get interfaces_(){return[]}};nr.constructor_=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new x;let t=arguments[0],tt=arguments[1];this._op=t,this._geometryFactory=tt};let sr=class sr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new s,this._commonSignExp=null}getCommon(){return i.longBitsToDouble(this._commonBits)}add(t){let tt=i.doubleToLongBits(t);return this._isFirst?(this._commonBits=tt,this._commonSignExp=sr.signExpBits(this._commonBits),this._isFirst=!1,null):sr.signExpBits(tt)!==this._commonSignExp?(this._commonBits.high=0,this._commonBits.low=0,null):(this._commonMantissaBitsCount=sr.numCommonMostSigMantissaBits(this._commonBits,tt),void(this._commonBits=sr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))}toString(){if(1==arguments.length){let t=arguments[0],tt=i.longBitsToDouble(t),ta="0000000000000000000000000000000000000000000000000000000000000000"+s.toBinaryString(t),th=ta.substring(ta.length-64);return th.substring(0,1)+"  "+th.substring(1,12)+"(exp) "+th.substring(12)+" [ "+tt+" ]"}}getClass(){return sr}get interfaces_(){return[]}static getBit(t,tt){let ta=1<<tt%32;return tt<32?0!=(t.low&ta)?1:0:0!=(t.high&ta)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,tt){let ta="low";if(tt>32&&(t.low=0,tt%=32,ta="high"),tt>0){let th=tt<32?~((1<<tt)-1):0;t[ta]&=th}return t}static numCommonMostSigMantissaBits(t,tt){let ta=0;for(let th=52;th>=0;th--){if(sr.getBit(t,th)!==sr.getBit(tt,th))return ta;ta++}return 52}};let ir=class ir{constructor(){ir.constructor_.apply(this,arguments)}addCommonBits(t){let tt=new or(this._commonCoord);t.apply(tt),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;let tt=new g(this._commonCoord);tt.x=-tt.x,tt.y=-tt.y;let ta=new or(tt);return t.apply(ta),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}getClass(){return ir}get interfaces_(){return[]}};let rr=class rr{constructor(){rr.constructor_.apply(this,arguments)}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new g(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}getClass(){return rr}get interfaces_(){return[B]}};rr.constructor_=function(){this._commonBitsX=new sr,this._commonBitsY=new sr};let or=class or{constructor(){or.constructor_.apply(this,arguments)}filter(t,tt){let ta=t.getOrdinate(tt,0)+this.trans.x,th=t.getOrdinate(tt,1)+this.trans.y;t.setOrdinate(tt,0,ta),t.setOrdinate(tt,1,th)}isDone(){return!1}isGeometryChanged(){return!0}getClass(){return or}get interfaces_(){return[_t]}};or.constructor_=function(){this.trans=null;let t=arguments[0];this.trans=t},ir.CommonCoordinateFilter=rr,ir.Translater=or,ir.constructor_=function(){this._commonCoord=null,this._ccFilter=new rr};let lr=class lr{constructor(){lr.constructor_.apply(this,arguments)}static overlayOp(t,tt,ta){return new lr(t,tt).getResultGeometry(ta)}static union(t,tt){return lr.overlayOp(t,tt,hr.UNION)}static intersection(t,tt){return lr.overlayOp(t,tt,hr.INTERSECTION)}static symDifference(t,tt){return lr.overlayOp(t,tt,hr.SYMDIFFERENCE)}static difference(t,tt){return lr.overlayOp(t,tt,hr.DIFFERENCE)}selfSnap(t){return new ji(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new ir,this._cbr.add(t[0]),this._cbr.add(t[1]);let tt=[,,].fill(null);return tt[0]=this._cbr.removeCommonBits(t[0].copy()),tt[1]=this._cbr.removeCommonBits(t[1].copy()),tt}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){let tt=this.snap(this._geom),ta=hr.overlayOp(tt[0],tt[1],t);return this.prepareResult(ta)}checkValid(t){t.isValid()||O.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=ji.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){let tt=this.removeCommonBits(t);return ji.snap(tt[0],tt[1],this._snapTolerance)}getClass(){return lr}get interfaces_(){return[]}};lr.constructor_=function(){this._geom=[,,].fill(null),this._snapTolerance=null,this._cbr=null;let t=arguments[0],tt=arguments[1];this._geom[0]=t,this._geom[1]=tt,this.computeSnapTolerance()};let ar=class ar{constructor(){ar.constructor_.apply(this,arguments)}static overlayOp(t,tt,ta){return new ar(t,tt).getResultGeometry(ta)}static union(t,tt){return ar.overlayOp(t,tt,hr.UNION)}static intersection(t,tt){return ar.overlayOp(t,tt,hr.INTERSECTION)}static symDifference(t,tt){return ar.overlayOp(t,tt,hr.SYMDIFFERENCE)}static difference(t,tt){return ar.overlayOp(t,tt,hr.DIFFERENCE)}getResultGeometry(t){let tt=null,ta=!1,th=null;try{tt=hr.overlayOp(this._geom[0],this._geom[1],t),ta=!0}catch(t){if(!(t instanceof c))throw t;th=t}if(!ta)try{tt=lr.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof c?th:t}return tt}getClass(){return ar}get interfaces_(){return[]}};ar.constructor_=function(){this._geom=[,,].fill(null);let t=arguments[0],tt=arguments[1];this._geom[0]=t,this._geom[1]=tt};let cr=class cr{constructor(){cr.constructor_.apply(this,arguments)}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getClass(){return cr}get interfaces_(){return[]}};cr.constructor_=function(){if(this._li=new ee,this._resultPrecisionModel=null,this._arg=null,1==arguments.length){let t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=[,].fill(null),this._arg[0]=new Jn(0,t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];cr.constructor_.call(this,t,tt,V.OGC_SFS_BOUNDARY_RULE)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];t.getPrecisionModel().compareTo(tt.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(tt.getPrecisionModel()),this._arg=[,,].fill(null),this._arg[0]=new Jn(0,t,ta),this._arg[1]=new Jn(1,tt,ta)}};let hr=class hr extends cr{constructor(){super(),hr.constructor_.apply(this,arguments)}static overlayOp(t,tt,ta){return new hr(t,tt).getResultGeometry(ta)}static union(t,tt){if(t.isEmpty()||tt.isEmpty()){if(t.isEmpty()&&tt.isEmpty())return hr.createEmptyResult(hr.UNION,t,tt,t.getFactory());if(t.isEmpty())return tt.copy();if(tt.isEmpty())return t.copy()}if(t.isGeometryCollection()||tt.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return ar.overlayOp(t,tt,hr.UNION)}static intersection(t,tt){return t.isEmpty()||tt.isEmpty()?hr.createEmptyResult(hr.INTERSECTION,t,tt,t.getFactory()):t.isGeometryCollection()?de.map(t,new class{get interfaces_(){return[pe]}map(t){return hr.intersection(t,tt)}}):ar.overlayOp(t,tt,hr.INTERSECTION)}static symDifference(t,tt){if(t.isEmpty()||tt.isEmpty()){if(t.isEmpty()&&tt.isEmpty())return hr.createEmptyResult(hr.SYMDIFFERENCE,t,tt,t.getFactory());if(t.isEmpty())return tt.copy();if(tt.isEmpty())return t.copy()}if(t.isGeometryCollection()||tt.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return ar.overlayOp(t,tt,hr.SYMDIFFERENCE)}static resultDimension(t,tt,ta){let th=tt.getDimension(),tu=ta.getDimension(),tc=-1;switch(t){case hr.INTERSECTION:tc=Math.min(th,tu);break;case hr.UNION:tc=Math.max(th,tu);break;case hr.DIFFERENCE:tc=th;break;case hr.SYMDIFFERENCE:tc=Math.max(th,tu)}return tc}static createEmptyResult(t,tt,ta,th){let tu=null;switch(hr.resultDimension(t,tt,ta)){case -1:tu=th.createGeometryCollection();break;case 0:tu=th.createPoint();break;case 1:tu=th.createLineString();break;case 2:tu=th.createPolygon()}return tu}static difference(t,tt){if(t.isEmpty())return hr.createEmptyResult(hr.DIFFERENCE,t,tt,t.getFactory());if(tt.isEmpty())return t.copy();if(t.isGeometryCollection()||tt.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return ar.overlayOp(t,tt,hr.DIFFERENCE)}static isResultOfOp(){if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t.getLocation(0),th=t.getLocation(1);return hr.isResultOfOp(ta,th,tt)}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];switch(t===se.BOUNDARY&&(t=se.INTERIOR),tt===se.BOUNDARY&&(tt=se.INTERIOR),ta){case hr.INTERSECTION:return t===se.INTERIOR&&tt===se.INTERIOR;case hr.UNION:return t===se.INTERIOR||tt===se.INTERIOR;case hr.DIFFERENCE:return t===se.INTERIOR&&tt!==se.INTERIOR;case hr.SYMDIFFERENCE:return t===se.INTERIOR&&tt!==se.INTERIOR||t!==se.INTERIOR&&tt===se.INTERIOR}return!1}}insertUniqueEdge(t){let tt=this._edgeList.findEqualEdge(t);if(null!==tt){let ta=tt.getLabel(),th=t.getLabel();tt.isPointwiseEqual(t)||(th=new Gn(t.getLabel())).flip();let tu=tt.getDepth();tu.isNull()&&tu.add(ta),tu.add(th),ta.merge(th)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){let tt=t.next(),ta=tt.getSym();tt.isInResult()&&ta.isInResult()&&(tt.setInResult(!1),ta.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,tt,ta,th){let tu=new x;return tu.addAll(t),tu.addAll(tt),tu.addAll(ta),tu.isEmpty()?hr.createEmptyResult(th,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(tu)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();)t.next().getEdges().mergeSymLabels()}isCovered(t,tt){for(let ta=tt.iterator();ta.hasNext();){let tt=ta.next();if(this._ptLocator.locate(t,tt)!==se.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){let t=new x;for(let tt=this._edgeList.iterator();tt.hasNext();){let ta=tt.next();ta.isCollapsed()&&(tt.remove(),t.add(ta.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){let tt=t.next(),ta=tt.getEdges().getLabel();tt.getLabel().merge(ta)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);let tt=new x;this._arg[0].computeSplitEdges(tt),this._arg[1].computeSplitEdges(tt),this.insertUniqueEdges(tt),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),tr.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();let ta=new ni(this._geomFact);ta.add(this._graph),this._resultPolyList=ta.getPolygons();let th=new er(this,this._geomFact,this._ptLocator);this._resultLineList=th.build(t);let tu=new nr(this,this._geomFact,this._ptLocator);this._resultPointList=tu.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,tt){let ta=this._ptLocator.locate(t.getCoordinate(),this._arg[tt].getGeometry());t.getLabel().setLocation(tt,ta)}copyPoints(t){for(let tt=this._arg[t].getNodeIterator();tt.hasNext();){let ta=tt.next();this._graph.addNode(ta.getCoordinate()).setLabel(t,ta.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let tt=this._graph.getEdgeEnds().iterator();tt.hasNext();){let ta=tt.next(),th=ta.getLabel();th.isArea()&&!ta.isInteriorAreaEdge()&&hr.isResultOfOp(th.getLocation(0,vn.RIGHT),th.getLocation(1,vn.RIGHT),t)&&ta.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){let tt=t.next(),ta=tt.getLabel(),th=tt.getDepth();if(!th.isNull()){th.normalize();for(let t=0;t<2;t++)ta.isNull(t)||!ta.isArea()||th.isNull(t)||(0===th.getDelta(t)?ta.toLine(t):(u.isTrue(!th.isNull(t,vn.LEFT),"depth of LEFT side has not been initialized"),ta.setLocation(t,vn.LEFT,th.getLocation(t,vn.LEFT)),u.isTrue(!th.isNull(t,vn.RIGHT),"depth of RIGHT side has not been initialized"),ta.setLocation(t,vn.RIGHT,th.getLocation(t,vn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();)t.next().getEdges().computeLabelling(this._arg);this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){let tt=t.next(),ta=tt.getLabel();tt.isIsolated()&&(ta.isNull(0)?this.labelIncompleteNode(tt,0):this.labelIncompleteNode(tt,1)),tt.getEdges().updateLabelling(ta)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}getClass(){return hr}get interfaces_(){return[]}};hr.constructor_=function(){this._ptLocator=new fn,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new _i,this._resultPolyList=new x,this._resultLineList=new x,this._resultPointList=new x;let t=arguments[0],tt=arguments[1];cr.constructor_.call(this,t,tt),this._graph=new Qn(new gi),this._geomFact=t.getFactory()},hr.INTERSECTION=1,hr.UNION=2,hr.DIFFERENCE=3,hr.SYMDIFFERENCE=4;var tO=Object.freeze({__proto__:null,snap:tP,OverlayOp:hr});let gr=class gr extends Mi{constructor(){super(),gr.constructor_.apply(this,arguments)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}getClass(){return gr}get interfaces_(){return[]}};gr.constructor_=function(){this._edgeRing=null,this._next=null,this._label=-1;let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];Mi.constructor_.call(this,t,tt,ta,th)};let dr=class dr extends Ai{constructor(){super(),dr.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return dr}get interfaces_(){return[]}};dr.constructor_=function(){this._line=null;let t=arguments[0];this._line=t};let _r=class _r{constructor(){_r.constructor_.apply(this,arguments)}static findDifferentPoint(t,tt){for(let ta=0;ta<t.length;ta++)if(!t[ta].equals(tt))return t[ta];return null}visitInteriorRing(t,tt){let ta=t.getCoordinates(),th=ta[0],tu=_r.findDifferentPoint(ta,th),tc=tt.findEdgeInSameDirection(th,tu),tg=tt.findEdgeEnd(tc),t_=null;tg.getLabel().getLocation(0,vn.RIGHT)===se.INTERIOR?t_=tg:tg.getSym().getLabel().getLocation(0,vn.RIGHT)===se.INTERIOR&&(t_=tg.getSym()),u.isTrue(null!==t_,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(t_)}visitShellInteriors(t,tt){if(t instanceof Mt&&this.visitInteriorRing(t.getExteriorRing(),tt),t instanceof Ft)for(let ta=0;ta<t.getNumGeometries();ta++){let th=t.getGeometryN(ta);this.visitInteriorRing(th.getExteriorRing(),tt)}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let tt=t.getEdgeEnds().iterator();tt.hasNext();){let t=tt.next();t.getLabel().getLocation(0,vn.RIGHT)===se.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){let tt=t;do u.isTrue(null!==tt,"found null Directed Edge"),tt.setVisited(!0),tt=tt.getNext();while(tt!==t)}buildEdgeRings(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();if(t.isInResult()&&null===t.getEdgeRing()){let ta=new ei(t,this._geometryFactory);ta.linkDirectedEdgesForMinimalEdgeRings();let th=ta.buildMinimalRings();tt.addAll(th)}}return tt}hasUnvisitedShellEdge(t){for(let tt=0;tt<t.size();tt++){let ta=t.get(tt);if(ta.isHole())continue;let th=ta.getEdges(),tu=th.get(0);if(tu.getLabel().getLocation(0,vn.RIGHT)===se.INTERIOR){for(let t=0;t<th.size();t++)if(!(tu=th.get(t)).isVisited())return this._disconnectedRingcoord=tu.getCoordinate(),!0}}return!1}isInteriorsConnected(){let t=new x;this._geomGraph.computeSplitEdges(t);let tt=new Qn(new gi);tt.addEdges(t),this.setInteriorEdgesInResult(tt),tt.linkResultDirectedEdges();let ta=this.buildEdgeRings(tt.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),tt),!this.hasUnvisitedShellEdge(ta)}getClass(){return _r}get interfaces_(){return[]}};_r.constructor_=function(){this._geometryFactory=new Wt,this._geomGraph=null,this._disconnectedRingcoord=null;let t=arguments[0];this._geomGraph=t};let fr=class fr{constructor(){fr.constructor_.apply(this,arguments)}createEdgeEndForNext(t,tt,ta,th){let tu=ta.segmentIndex+1;if(tu>=t.getNumPoints()&&null===th)return null;let tc=t.getCoordinate(tu);null!==th&&th.segmentIndex===ta.segmentIndex&&(tc=th.coord);let tg=new Wn(t,ta.coord,tc,new Gn(t.getLabel()));tt.add(tg)}createEdgeEndForPrev(t,tt,ta,th){let tu=ta.segmentIndex;if(0===ta.dist){if(0===tu)return null;tu--}let tc=t.getCoordinate(tu);null!==th&&th.segmentIndex>=tu&&(tc=th.coord);let tg=new Gn(t.getLabel());tg.flip();let t_=new Wn(t,ta.coord,tc,tg);tt.add(t_)}computeEdgeEnds(){if(1==arguments.length){let t=arguments[0],tt=new x;for(;t.hasNext();){let ta=t.next();this.computeEdgeEnds(ta,tt)}return tt}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t.getEdgeIntersectionList();ta.addEndpoints();let th=ta.iterator(),tu=null,tc=null;if(!th.hasNext())return null;let tg=th.next();do tu=tc,tc=tg,tg=null,th.hasNext()&&(tg=th.next()),null!==tc&&(this.createEdgeEndForPrev(t,tt,tc,tu),this.createEdgeEndForNext(t,tt,tc,tg));while(null!==tc)}}getClass(){return fr}get interfaces_(){return[]}};fr.constructor_=function(){};let pr=class pr extends Wn{constructor(){super(),pr.constructor_.apply(this,arguments)}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--> Label: "+this._label);for(let tt=this.iterator();tt.hasNext();)tt.next().print(t),t.println()}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,tt){let ta=0,th=!1;for(let tt=this.iterator();tt.hasNext();){let tu=tt.next().getLabel().getLocation(t);tu===se.BOUNDARY&&ta++,tu===se.INTERIOR&&(th=!0)}let tu=se.NONE;th&&(tu=se.INTERIOR),ta>0&&(tu=Jn.determineBoundary(tt,ta)),this._label.setLocation(t,tu)}computeLabelSide(t,tt){for(let ta=this.iterator();ta.hasNext();){let th=ta.next();if(th.getLabel().isArea()){let ta=th.getLabel().getLocation(t,tt);if(ta===se.INTERIOR)return this._label.setLocation(t,tt,se.INTERIOR),null;ta===se.EXTERIOR&&this._label.setLocation(t,tt,se.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,vn.LEFT),this.computeLabelSide(t,vn.RIGHT)}updateIM(t){kn.updateIM(this._label,t)}computeLabel(t){let tt=!1;for(let t=this.iterator();t.hasNext();)t.next().getLabel().isArea()&&(tt=!0);this._label=tt?new Gn(se.NONE,se.NONE,se.NONE):new Gn(se.NONE);for(let ta=0;ta<2;ta++)this.computeLabelOn(ta,t),tt&&this.computeLabelSides(ta)}getClass(){return pr}get interfaces_(){return[]}};pr.constructor_=function(){if(this._edgeEnds=new x,1==arguments.length){let t=arguments[0];pr.constructor_.call(this,null,t)}else if(2==arguments.length){let t=arguments[1];Wn.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Gn(t.getLabel())),this.insert(t)}};let mr=class mr extends hi{constructor(){super(),mr.constructor_.apply(this,arguments)}updateIM(t){for(let tt=this.iterator();tt.hasNext();)tt.next().updateIM(t)}insert(t){let tt=this._edgeMap.get(t);null===tt?(tt=new pr(t),this.insertEdgeEnd(t,tt)):tt.insert(t)}getClass(){return mr}get interfaces_(){return[]}};mr.constructor_=function(){};let yr=class yr extends Xn{constructor(){super(),yr.constructor_.apply(this,arguments)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}getClass(){return yr}get interfaces_(){return[]}};yr.constructor_=function(){let t=arguments[0],tt=arguments[1];Xn.constructor_.call(this,t,tt)};let xr=class xr extends Zn{constructor(){super(),xr.constructor_.apply(this,arguments)}createNode(t){return new yr(t,new mr)}getClass(){return xr}get interfaces_(){return[]}};xr.constructor_=function(){};let Er=class Er{constructor(){Er.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,tt){for(let ta=t.getNodeIterator();ta.hasNext();){let t=ta.next();this._nodes.addNode(t.getCoordinate()).setLabel(tt,t.getLabel().getLocation(tt))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);let tt=(new fr).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(tt)}computeIntersectionNodes(t,tt){for(let ta=t.getEdgeIterator();ta.hasNext();){let t=ta.next(),th=t.getLabel().getLocation(tt);for(let ta=t.getEdgeIntersectionList().iterator();ta.hasNext();){let t=ta.next(),tu=this._nodes.addNode(t.coord);th===se.BOUNDARY?tu.setLabelBoundary(tt):tu.getLabel().isNull(tt)&&tu.setLabel(tt,se.INTERIOR)}}}getClass(){return Er}get interfaces_(){return[]}};Er.constructor_=function(){this._nodes=new Hn(new xr)};let Ir=class Ir{constructor(){Ir.constructor_.apply(this,arguments)}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){let tt=t.next();if(!tt.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=tt.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();)for(let tt=t.next().getEdges().iterator();tt.hasNext();){let t=tt.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}return!1}isNodeConsistentArea(){let t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}getClass(){return Ir}get interfaces_(){return[]}};Ir.constructor_=function(){this._li=new ee,this._geomGraph=null,this._nodeGraph=new Er,this._invalidPoint=null;let t=arguments[0];this._geomGraph=t};let Nr=class Nr{constructor(){Nr.constructor_.apply(this,arguments)}buildIndex(){this._index=new Is;for(let t=0;t<this._rings.size();t++){let tt=this._rings.get(t),ta=tt.getEnvelopeInternal();this._index.insert(ta,tt)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){let tt=this._rings.get(t),ta=tt.getCoordinates(),th=this._index.query(tt.getEnvelopeInternal());for(let t=0;t<th.size();t++){let tu=th.get(t),tc=tu.getCoordinates();if(tt===tu||!tt.getEnvelopeInternal().intersects(tu.getEnvelopeInternal()))continue;let tg=Sr.findPtNotNode(ta,tu,this._graph);if(null!==tg&&je.isInRing(tg,tc))return this._nestedPt=tg,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}getClass(){return Nr}get interfaces_(){return[]}};Nr.constructor_=function(){this._graph=null,this._rings=new x,this._totalEnv=new N,this._index=null,this._nestedPt=null;let t=arguments[0];this._graph=t};let Cr=class Cr{constructor(){Cr.constructor_.apply(this,arguments)}getErrorType(){return this._errorType}getMessage(){return Cr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}getClass(){return Cr}get interfaces_(){return[]}};Cr.constructor_=function(){if(this._errorType=null,this._pt=null,1==arguments.length){let t=arguments[0];Cr.constructor_.call(this,t,null)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._errorType=t,null!==tt&&(this._pt=tt.copy())}},Cr.ERROR=0,Cr.REPEATED_POINT=1,Cr.HOLE_OUTSIDE_SHELL=2,Cr.NESTED_HOLES=3,Cr.DISCONNECTED_INTERIOR=4,Cr.SELF_INTERSECTION=5,Cr.RING_SELF_INTERSECTION=6,Cr.NESTED_SHELLS=7,Cr.DUPLICATE_RINGS=8,Cr.TOO_FEW_POINTS=9,Cr.INVALID_COORDINATE=10,Cr.RING_NOT_CLOSED=11,Cr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];let Sr=class Sr{constructor(){Sr.constructor_.apply(this,arguments)}static findPtNotNode(t,tt,ta){let th=ta.findEdge(tt).getEdgeIntersectionList();for(let tt=0;tt<t.length;tt++){let ta=t[tt];if(!th.isIntersection(ta))return ta}return null}static isValid(){if(arguments[0]instanceof q){let t=arguments[0];return new Sr(t).isValid()}if(arguments[0]instanceof g){let t=arguments[0];return!i.isNaN(t.x)&&!i.isInfinite(t.x)&&!i.isNaN(t.y)&&!i.isInfinite(t.y)}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){let t=arguments[0];for(let tt=0;tt<t.length;tt++)if(!Sr.isValid(t[tt]))return this._validErr=new Cr(Cr.INVALID_COORDINATE,t[tt]),null}else if(arguments[0]instanceof Mt){let t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let tt=0;tt<t.getNumInteriorRing();tt++)if(this.checkInvalidCoordinates(t.getInteriorRingN(tt).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,tt){let ta=new Nr(tt);for(let tt=0;tt<t.getNumInteriorRing();tt++){let th=t.getInteriorRingN(tt);ta.add(th)}ta.isNonNested()||(this._validErr=new Cr(Cr.NESTED_HOLES,ta.getNestedPoint()))}checkConsistentArea(t){let tt=new Ir(t);if(!tt.isNodeConsistentArea())return this._validErr=new Cr(Cr.SELF_INTERSECTION,tt.getInvalidPoint()),null;tt.hasDuplicateRings()&&(this._validErr=new Cr(Cr.DUPLICATE_RINGS,tt.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,tt,ta){let th=t.getCoordinates(),tu=tt.getCoordinates(),tc=Sr.findPtNotNode(th,tt,ta);if(null!==tc&&!je.isInRing(tc,tu))return tc;let tg=Sr.findPtNotNode(tu,t,ta);return null!==tg?je.isInRing(tg,th)?tg:null:(u.shouldNeverReachHere("points in shell and hole appear to be equal"),null)}checkNoSelfIntersectingRings(t){for(let tt=t.getEdgeIterator();tt.hasNext();){let t=tt.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){let tt=new _r(t);tt.isInteriorsConnected()||(this._validErr=new Cr(Cr.DISCONNECTED_INTERIOR,tt.getCoordinate()))}checkNoSelfIntersectingRing(t){let tt=new ct,ta=!0;for(let th=t.iterator();th.hasNext();){let t=th.next();if(ta)ta=!1;else{if(tt.contains(t.coord))return this._validErr=new Cr(Cr.RING_SELF_INTERSECTION,t.coord),null;tt.add(t.coord)}}}checkHolesInShell(t,tt){let ta=t.getExteriorRing(),th=new Xe(ta);for(let tu=0;tu<t.getNumInteriorRing();tu++){let tc=t.getInteriorRingN(tu),tg=Sr.findPtNotNode(tc.getCoordinates(),ta,tt);if(null===tg)return null;if(se.EXTERIOR===th.locate(tg))return this._validErr=new Cr(Cr.HOLE_OUTSIDE_SHELL,tg),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Cr(Cr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof vt){let t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Dt){let t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof At){let t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr||(this.checkClosedRing(t),null!==this._validErr))return null;let tt=new Jn(0,t);if(this.checkTooFewPoints(tt),null!==this._validErr)return null;let ta=new ee;tt.computeSelfNodes(ta,!0,!0),this.checkNoSelfIntersectingRings(tt)}else if(arguments[0]instanceof Rt){let t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;let tt=new Jn(0,t);this.checkTooFewPoints(tt)}else if(arguments[0]instanceof Mt){let t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr||(this.checkClosedRings(t),null!==this._validErr))return null;let tt=new Jn(0,t);if(this.checkTooFewPoints(tt),null!==this._validErr||(this.checkConsistentArea(tt),null!==this._validErr)||!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(tt),null!==this._validErr)||(this.checkHolesInShell(t,tt),null!==this._validErr)||(this.checkHolesNotNested(t,tt),null!==this._validErr))return null;this.checkConnectedInteriors(tt)}else if(arguments[0]instanceof Ft){let t=arguments[0];for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);if(this.checkInvalidCoordinates(ta),null!==this._validErr||(this.checkClosedRings(ta),null!==this._validErr))return null}let tt=new Jn(0,t);if(this.checkTooFewPoints(tt),null!==this._validErr||(this.checkConsistentArea(tt),null!==this._validErr)||!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(tt),null!==this._validErr))return null;for(let ta=0;ta<t.getNumGeometries();ta++){let th=t.getGeometryN(ta);if(this.checkHolesInShell(th,tt),null!==this._validErr)return null}for(let ta=0;ta<t.getNumGeometries();ta++){let th=t.getGeometryN(ta);if(this.checkHolesNotNested(th,tt),null!==this._validErr)return null}if(this.checkShellsNotNested(t,tt),null!==this._validErr)return null;this.checkConnectedInteriors(tt)}else if(arguments[0]instanceof ft){let t=arguments[0];for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);if(this.checkValid(ta),null!==this._validErr)return null}}else if(arguments[0]instanceof q){let t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof vt)this.checkValid(t);else if(t instanceof Dt)this.checkValid(t);else if(t instanceof At)this.checkValid(t);else if(t instanceof Rt)this.checkValid(t);else if(t instanceof Mt)this.checkValid(t);else if(t instanceof Ft)this.checkValid(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,tt,ta){let th=t.getCoordinates(),tu=tt.getExteriorRing(),tc=tu.getCoordinates(),tg=Sr.findPtNotNode(th,tu,ta);if(null===tg||!je.isInRing(tg,tc))return null;if(0>=tt.getNumInteriorRing())return this._validErr=new Cr(Cr.NESTED_SHELLS,tg),null;let t_=null;for(let th=0;th<tt.getNumInteriorRing();th++){let tu=tt.getInteriorRingN(th);if(null===(t_=this.checkShellInsideHole(t,tu,ta)))return null}this._validErr=new Cr(Cr.NESTED_SHELLS,t_)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let tt=0;tt<t.getNumInteriorRing();tt++)if(this.checkClosedRing(t.getInteriorRingN(tt)),null!==this._validErr)return null}checkClosedRing(t){if(!t.isClosed()){let tt=null;t.getNumPoints()>=1&&(tt=t.getCoordinateN(0)),this._validErr=new Cr(Cr.RING_NOT_CLOSED,tt)}}checkShellsNotNested(t,tt){for(let ta=0;ta<t.getNumGeometries();ta++){let th=t.getGeometryN(ta).getExteriorRing();for(let tu=0;tu<t.getNumGeometries();tu++){if(ta===tu)continue;let tc=t.getGeometryN(tu);if(this.checkShellNotNested(th,tc,tt),null!==this._validErr)return null}}}getClass(){return Sr}get interfaces_(){return[]}};Sr.constructor_=function(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;let t=arguments[0];this._parentGeometry=t};let wr=class wr{constructor(){wr.constructor_.apply(this,arguments)}static findDirEdgesInRing(t){let tt=t,ta=new x;do ta.add(tt),tt=tt.getNext(),u.isTrue(null!==tt,"found null DE in ring"),u.isTrue(tt===t||!tt.isInRing(),"found DE already in ring");while(tt!==t);return ta}static addEdge(t,tt,ta){if(tt)for(let tt=0;tt<t.length;tt++)ta.add(t[tt],!1);else for(let tt=t.length-1;tt>=0;tt--)ta.add(t[tt],!1)}static findEdgeRingContaining(t,tt){let ta=t.getRing(),th=ta.getEnvelopeInternal(),tu=ta.getCoordinateN(0),tc=null,tg=null;for(let t=tt.iterator();t.hasNext();){let tt=t.next(),t_=tt.getRing(),td=t_.getEnvelopeInternal();if(td.equals(th)||!td.contains(th))continue;tu=X.ptNotInList(ta.getCoordinates(),t_.getCoordinates());let tp=!1;je.isInRing(tu,t_.getCoordinates())&&(tp=!0),tp&&(null===tc||tg.contains(td))&&(tg=(tc=tt).getRing().getEnvelopeInternal())}return tc}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){let t=new I;for(let tt=this._deList.iterator();tt.hasNext();){let ta=tt.next(),th=ta.getEdge();wr.addEdge(th.getLine().getCoordinates(),ta.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Sr.isValid(this._ring))}build(t){let tt=t;do this.add(tt),tt.setRing(this),tt=tt.getNext(),u.isTrue(null!==tt,"found null DE in ring"),u.isTrue(tt===t||!tt.isInRing(),"found DE already in ring");while(tt!==t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=Array(this._holes.size()).fill(null);for(let tt=0;tt<this._holes.size();tt++)t[tt]=this._holes.get(tt)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof At){let t=arguments[0];null===this._holes&&(this._holes=new x),this._holes.add(t)}else if(arguments[0]instanceof wr){let t=arguments[0];t.setShell(this);let tt=t.getRing();null===this._holes&&(this._holes=new x),this._holes.add(tt)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){let tt=this._deList.get(t).getSym().getRing();if(tt.isOuterHole())return tt}return null}computeHole(){let t=this.getRing();this._isHole=v.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return $t.toLineString(new Yt(this.getCoordinates()))}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&O.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof C))throw t;O.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){let tt=this._deList.get(t).getSym().getRing().getShell();if(null!==tt&&tt.isIncludedSet())return this.setIncluded(!tt.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}getClass(){return wr}get interfaces_(){return[]}};let Lr=class Lr{constructor(){Lr.constructor_.apply(this,arguments)}compare(t,tt){return t.getRing().getEnvelope().compareTo(tt.getRing().getEnvelope())}getClass(){return Lr}get interfaces_(){return[l]}};Lr.constructor_=function(){},wr.EnvelopeComparator=Lr,wr.constructor_=function(){this._factory=null,this._deList=new x,this._lowestEdge=null,this._ring=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;let t=arguments[0];this._factory=t};let Tr=class Tr extends Vi{constructor(){super(),Tr.constructor_.apply(this,arguments)}static findLabeledEdgeRings(t){let tt=new x,ta=1;for(let th=t.iterator();th.hasNext();){let t=th.next();if(t.isMarked()||t.getLabel()>=0)continue;tt.add(t);let tu=wr.findDirEdgesInRing(t);Tr.label(tu,ta),ta++}return tt}static getDegreeNonDeleted(t){let tt=0;for(let ta=t.getOutEdges().getEdges().iterator();ta.hasNext();)ta.next().isMarked()||tt++;return tt}static deleteAllEdges(t){for(let tt=t.getOutEdges().getEdges().iterator();tt.hasNext();){let t=tt.next();t.setMarked(!0);let ta=t.getSym();null!==ta&&ta.setMarked(!0)}}static label(t,tt){for(let ta=t.iterator();ta.hasNext();)ta.next().setLabel(tt)}static computeNextCWEdges(t){let tt=null,ta=null;for(let th=t.getOutEdges().getEdges().iterator();th.hasNext();){let t=th.next();t.isMarked()||(null===tt&&(tt=t),null!==ta&&ta.getSym().setNext(t),ta=t)}null!==ta&&ta.getSym().setNext(tt)}static computeNextCCWEdges(t,tt){let ta=null,th=null,tu=t.getOutEdges().getEdges();for(let t=tu.size()-1;t>=0;t--){let tc=tu.get(t),tg=tc.getSym(),t_=null;tc.getLabel()===tt&&(t_=tc);let td=null;tg.getLabel()===tt&&(td=tg),null===t_&&null===td||(null!==td&&(th=td),null!==t_&&(null!==th&&(th.setNext(t_),th=null),null===ta&&(ta=t_)))}null!==th&&(u.isTrue(null!==ta),th.setNext(ta))}static getDegree(t,tt){let ta=0;for(let th=t.getOutEdges().getEdges().iterator();th.hasNext();)th.next().getLabel()===tt&&ta++;return ta}static findIntersectionNodes(t,tt){let ta=t,th=null;do{let tu=ta.getFromNode();Tr.getDegree(tu,tt)>1&&(null===th&&(th=new x),th.add(tu)),ta=ta.getNext(),u.isTrue(null!==ta,"found null DE in ring"),u.isTrue(ta===t||!ta.isInRing(),"found DE already in ring")}while(ta!==t);return th}findEdgeRing(t){let tt=new wr(this._factory);return tt.build(t),tt}computeDepthParity(){if(0==arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){let tt=t.next();Tr.computeNextCWEdges(tt)}}addEdge(t){if(t.isEmpty())return null;let tt=X.removeRepeatedPoints(t.getCoordinates());if(tt.length<2)return null;let ta=tt[0],th=tt[tt.length-1],tu=this.getNode(ta),tc=this.getNode(th),tg=new gr(tu,tc,tt[1],!0),t_=new gr(tc,tu,tt[tt.length-2],!1),td=new dr(t);td.setDirectedEdges(tg,t_),this.add(td)}deleteCutEdges(){this.computeNextCWEdges(),Tr.findLabeledEdgeRings(this._dirEdges);let t=new x;for(let tt=this._dirEdges.iterator();tt.hasNext();){let ta=tt.next();if(ta.isMarked())continue;let th=ta.getSym();if(ta.getLabel()===th.getLabel()){ta.setMarked(!0),th.setMarked(!0);let tt=ta.getEdge();t.add(tt.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Tr.label(this._dirEdges,-1);let t=Tr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);let tt=new x;for(let t=this._dirEdges.iterator();t.hasNext();){let ta=t.next();if(ta.isMarked()||ta.isInRing())continue;let th=this.findEdgeRing(ta);tt.add(th)}return tt}getNode(t){let tt=this.findNode(t);return null===tt&&(tt=new Gi(t),this.add(tt)),tt}convertMaximalToMinimalEdgeRings(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next(),ta=t.getLabel(),th=Tr.findIntersectionNodes(t,ta);if(null!==th)for(let t=th.iterator();t.hasNext();){let tt=t.next();Tr.computeNextCCWEdges(tt,ta)}}}deleteDangles(){let t=this.findNodesOfDegree(1),tt=new J,ta=new ln;for(let tt=t.iterator();tt.hasNext();)ta.push(tt.next());for(;!ta.isEmpty();){let t=ta.pop();Tr.deleteAllEdges(t);for(let th=t.getOutEdges().getEdges().iterator();th.hasNext();){let t=th.next();t.setMarked(!0);let tu=t.getSym();null!==tu&&tu.setMarked(!0);let tc=t.getEdge();tt.add(tc.getLine());let tg=t.getToNode();1===Tr.getDegreeNonDeleted(tg)&&ta.push(tg)}}return tt}getClass(){return Tr}get interfaces_(){return[]}};Tr.constructor_=function(){this._factory=null;let t=arguments[0];this._factory=t};let Rr=class Rr{constructor(){Rr.constructor_.apply(this,arguments)}static findOuterShells(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next(),ta=t.getOuterHole();null===ta||ta.isProcessed()||(t.setIncluded(!0),ta.setProcessed(!0))}}static extractPolygons(t,tt){let ta=new x;for(let th=t.iterator();th.hasNext();){let t=th.next();(tt||t.isIncluded())&&ta.add(t.getPolygon())}return ta}static assignHolesToShells(t,tt){for(let ta=t.iterator();ta.hasNext();){let t=ta.next();Rr.assignHoleToShell(t,tt)}}static assignHoleToShell(t,tt){let ta=wr.findEdgeRingContaining(t,tt);null!==ta&&ta.addHole(t)}static findDisjointShells(t){Rr.findOuterShells(t);let tt=null;do{tt=!1;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(tt=!0))}}while(tt)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Wt),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Wt.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,tt,ta){for(let th=t.iterator();th.hasNext();){let t=th.next();t.isValid()?tt.add(t):ta.add(t.getLineString())}}polygonize(){if(null!==this._polyList||(this._polyList=new x,null===this._graph))return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();let t=this._graph.getEdgeRings(),tt=new x;this._invalidRingLines=new x,this._isCheckingRingsValid?this.findValidRings(t,tt,this._invalidRingLines):tt=t,this.findShellsAndHoles(tt),Rr.assignHolesToShells(this._holeList,this._shellList),tu.sort(this._shellList,new wr.EnvelopeComparator);let ta=!0;this._extractOnlyPolygonal&&(Rr.findDisjointShells(this._shellList),ta=!1),this._polyList=Rr.extractPolygons(this._shellList,ta)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(_(arguments[0],f))for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.add(tt)}else if(arguments[0]instanceof Rt){let t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Tr(this._geomFactory)),this._graph.addEdge(t)}else arguments[0]instanceof q&&arguments[0].apply(this._lineStringAdder)}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new x,this._shellList=new x;for(let tt=t.iterator();tt.hasNext();){let t=tt.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}getClass(){return Rr}get interfaces_(){return[]}};let Pr=class Pr{constructor(){Pr.constructor_.apply(this,arguments)}filter(t){t instanceof Rt&&this.p.add(t)}getClass(){return Pr}get interfaces_(){return[G]}};Pr.constructor_=function(){this.p=null;let t=arguments[0];this.p=t},Rr.LineStringAdder=Pr,Rr.constructor_=function(){if(this._lineStringAdder=new Pr(this),this._graph=null,this._dangles=new x,this._cutEdges=new x,this._invalidRingLines=new x,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0==arguments.length)Rr.constructor_.call(this,!1);else if(1==arguments.length){let t=arguments[0];this._extractOnlyPolygonal=t}};var tb=Object.freeze({__proto__:null,Polygonizer:Rr});let Or=class Or{constructor(){Or.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this._nodes.add(t)}}computeProperIntersectionIM(t,tt){let ta=this._arg[0].getGeometry().getDimension(),th=this._arg[1].getGeometry().getDimension(),tu=t.hasProperIntersection(),tc=t.hasProperInteriorIntersection();2===ta&&2===th?tu&&tt.setAtLeast("212101212"):2===ta&&1===th?(tu&&tt.setAtLeast("FFF0FFFF2"),tc&&tt.setAtLeast("1FFFFF1FF")):1===ta&&2===th?(tu&&tt.setAtLeast("F0FFFFFF2"),tc&&tt.setAtLeast("1F1FFFFFF")):1===ta&&1===th&&tc&&tt.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,tt){for(let ta=this._arg[t].getEdgeIterator();ta.hasNext();){let t=ta.next();t.isIsolated()&&(this.labelIsolatedEdge(t,tt,this._arg[tt].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,tt,ta){if(ta.getDimension()>0){let th=this._ptLocator.locate(t.getCoordinate(),ta);t.getLabel().setAllLocations(tt,th)}else t.getLabel().setAllLocations(tt,se.EXTERIOR)}computeIM(){let t=new ie;if(t.set(se.EXTERIOR,se.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);let tt=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(tt,t);let ta=new fr,th=ta.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(th);let tu=ta.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(tu),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();)t.next().getEdges().computeLabelling(this._arg)}copyNodesAndLabels(t){for(let tt=this._arg[t].getNodeIterator();tt.hasNext();){let ta=tt.next();this._nodes.addNode(ta.getCoordinate()).setLabel(t,ta.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let tt=this._arg[t].getEdgeIterator();tt.hasNext();){let ta=tt.next(),th=ta.getLabel().getLocation(t);for(let tt=ta.getEdgeIntersectionList().iterator();tt.hasNext();){let ta=tt.next(),tu=this._nodes.find(ta.coord);tu.getLabel().isNull(t)&&(th===se.BOUNDARY?tu.setLabelBoundary(t):tu.setLabel(t,se.INTERIOR))}}}labelIsolatedNode(t,tt){let ta=this._ptLocator.locate(t.getCoordinate(),this._arg[tt].getGeometry());t.getLabel().setAllLocations(tt,ta)}computeIntersectionNodes(t){for(let tt=this._arg[t].getEdgeIterator();tt.hasNext();){let ta=tt.next(),th=ta.getLabel().getLocation(t);for(let tt=ta.getEdgeIntersectionList().iterator();tt.hasNext();){let ta=tt.next(),tu=this._nodes.addNode(ta.coord);th===se.BOUNDARY?tu.setLabelBoundary(t):tu.getLabel().isNull(t)&&tu.setLabel(t,se.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){let tt=t.next(),ta=tt.getLabel();u.isTrue(ta.getGeometryCount()>0,"node with empty label found"),tt.isIsolated()&&(ta.isNull(0)?this.labelIsolatedNode(tt,0):this.labelIsolatedNode(tt,1))}}updateIM(t){for(let tt=this._isolatedEdges.iterator();tt.hasNext();)tt.next().updateIM(t);for(let tt=this._nodes.iterator();tt.hasNext();){let ta=tt.next();ta.updateIM(t),ta.updateIMFromEdges(t)}}computeDisjointIM(t){let tt=this._arg[0].getGeometry();tt.isEmpty()||(t.set(se.INTERIOR,se.EXTERIOR,tt.getDimension()),t.set(se.BOUNDARY,se.EXTERIOR,tt.getBoundaryDimension()));let ta=this._arg[1].getGeometry();ta.isEmpty()||(t.set(se.EXTERIOR,se.INTERIOR,ta.getDimension()),t.set(se.EXTERIOR,se.BOUNDARY,ta.getBoundaryDimension()))}getClass(){return Or}get interfaces_(){return[]}};Or.constructor_=function(){this._li=new ee,this._ptLocator=new fn,this._arg=null,this._nodes=new Hn(new xr),this._im=null,this._isolatedEdges=new x,this._invalidPoint=null;let t=arguments[0];this._arg=t};let br=class br{constructor(){br.constructor_.apply(this,arguments)}static contains(t,tt){return new br(t).contains(tt)}isContainedInBoundary(t){if(t instanceof Mt)return!1;if(t instanceof vt)return this.isPointContainedInBoundary(t);if(t instanceof Rt)return this.isLineStringContainedInBoundary(t);for(let tt=0;tt<t.getNumGeometries();tt++){let ta=t.getGeometryN(tt);if(!this.isContainedInBoundary(ta))return!1}return!0}isLineSegmentContainedInBoundary(t,tt){if(t.equals(tt))return this.isPointContainedInBoundary(t);if(t.x===tt.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===tt.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){let tt=t.getCoordinateSequence(),ta=new g,th=new g;for(let t=0;t<tt.size()-1;t++)if(tt.getCoordinate(t,ta),tt.getCoordinate(t+1,th),!this.isLineSegmentContainedInBoundary(ta,th))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof vt){let t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){let t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}getClass(){return br}get interfaces_(){return[]}};br.constructor_=function(){this._rectEnv=null;let t=arguments[0];this._rectEnv=t.getEnvelopeInternal()};let Mr=class Mr{constructor(){Mr.constructor_.apply(this,arguments)}intersects(t,tt){let ta=new N(t,tt);if(!this._rectEnv.intersects(ta))return!1;if(this._rectEnv.intersects(t)||this._rectEnv.intersects(tt))return!0;if(t.compareTo(tt)>0){let ta=t;t=tt,tt=ta}let th=!1;return tt.y>t.y&&(th=!0),th?this._li.computeIntersection(t,tt,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,tt,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}getClass(){return Mr}get interfaces_(){return[]}};Mr.constructor_=function(){this._li=new ee,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;let t=arguments[0];this._rectEnv=t,this._diagUp0=new g(t.getMinX(),t.getMinY()),this._diagUp1=new g(t.getMaxX(),t.getMaxY()),this._diagDown0=new g(t.getMinX(),t.getMaxY()),this._diagDown1=new g(t.getMaxX(),t.getMinY())};let Dr=class Dr{constructor(){Dr.constructor_.apply(this,arguments)}static intersects(t,tt){return new Dr(t).intersects(tt)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;let tt=new Ar(this._rectEnv);if(tt.applyTo(t),tt.intersects())return!0;let ta=new Fr(this._rectangle);if(ta.applyTo(t),ta.containsPoint())return!0;let th=new Gr(this._rectangle);return th.applyTo(t),!!th.intersects()}getClass(){return Dr}get interfaces_(){return[]}};Dr.constructor_=function(){this._rectangle=null,this._rectEnv=null;let t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()};let Ar=class Ar extends Se{constructor(){super(),Ar.constructor_.apply(this,arguments)}isDone(){return!0===this._intersects}visit(t){let tt=t.getEnvelopeInternal();return this._rectEnv.intersects(tt)?this._rectEnv.contains(tt)?(this._intersects=!0,null):tt.getMinX()>=this._rectEnv.getMinX()&&tt.getMaxX()<=this._rectEnv.getMaxX()?(this._intersects=!0,null):tt.getMinY()>=this._rectEnv.getMinY()&&tt.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}getClass(){return Ar}get interfaces_(){return[]}};Ar.constructor_=function(){this._rectEnv=null,this._intersects=!1;let t=arguments[0];this._rectEnv=t};let Fr=class Fr extends Se{constructor(){super(),Fr.constructor_.apply(this,arguments)}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof Mt))return null;let tt=t.getEnvelopeInternal();if(!this._rectEnv.intersects(tt))return null;let ta=new g;for(let th=0;th<4;th++)if(this._rectSeq.getCoordinate(th,ta),tt.contains(ta)&&Qe.containsPointInPolygon(ta,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}getClass(){return Fr}get interfaces_(){return[]}};Fr.constructor_=function(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;let t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()};let Gr=class Gr extends Se{constructor(){super(),Gr.constructor_.apply(this,arguments)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){let tt=t.getEnvelopeInternal();if(!this._rectEnv.intersects(tt))return null;let ta=Ee.getLines(t);this.checkIntersectionWithLineStrings(ta)}checkIntersectionWithLineStrings(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){let tt=t.getCoordinateSequence();for(let t=1;t<tt.size();t++)if(tt.getCoordinate(t-1,this._p0),tt.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}getClass(){return Gr}get interfaces_(){return[]}};Gr.constructor_=function(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new g,this._p1=new g;let t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Mr(this._rectEnv)};let qr=class qr extends cr{constructor(){super(),qr.constructor_.apply(this,arguments)}static covers(t,tt){return!(2===tt.getDimension()&&2>t.getDimension())&&!(1===tt.getDimension()&&1>t.getDimension()&&tt.getLength()>0)&&!!t.getEnvelopeInternal().covers(tt.getEnvelopeInternal())&&(!!t.isRectangle()||new qr(t,tt).getIntersectionMatrix().isCovers())}static intersects(t,tt){if(!t.getEnvelopeInternal().intersects(tt.getEnvelopeInternal()))return!1;if(t.isRectangle())return Dr.intersects(t,tt);if(tt.isRectangle())return Dr.intersects(tt,t);if(t.isGeometryCollection()||tt.isGeometryCollection()){for(let ta=0;ta<t.getNumGeometries();ta++)for(let th=0;th<tt.getNumGeometries();th++)if(t.getGeometryN(ta).intersects(tt.getGeometryN(th)))return!0;return!1}return new qr(t,tt).getIntersectionMatrix().isIntersects()}static touches(t,tt){return!!t.getEnvelopeInternal().intersects(tt.getEnvelopeInternal())&&new qr(t,tt).getIntersectionMatrix().isTouches(t.getDimension(),tt.getDimension())}static equalsTopo(t,tt){return!!t.getEnvelopeInternal().equals(tt.getEnvelopeInternal())&&qr.relate(t,tt).isEquals(t.getDimension(),tt.getDimension())}static relate(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new qr(t,tt).getIntersectionMatrix()}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return new qr(t,tt,ta).getIntersectionMatrix()}}static overlaps(t,tt){return!!t.getEnvelopeInternal().intersects(tt.getEnvelopeInternal())&&new qr(t,tt).getIntersectionMatrix().isOverlaps(t.getDimension(),tt.getDimension())}static crosses(t,tt){return!!t.getEnvelopeInternal().intersects(tt.getEnvelopeInternal())&&new qr(t,tt).getIntersectionMatrix().isCrosses(t.getDimension(),tt.getDimension())}static contains(t,tt){return!(2===tt.getDimension()&&2>t.getDimension())&&!(1===tt.getDimension()&&1>t.getDimension()&&tt.getLength()>0)&&!!t.getEnvelopeInternal().contains(tt.getEnvelopeInternal())&&(t.isRectangle()?br.contains(t,tt):new qr(t,tt).getIntersectionMatrix().isContains())}getIntersectionMatrix(){return this._relate.computeIM()}getClass(){return qr}get interfaces_(){return[]}};qr.constructor_=function(){if(this._relate=null,2==arguments.length){let t=arguments[0],tt=arguments[1];cr.constructor_.call(this,t,tt),this._relate=new Or(this._arg)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];cr.constructor_.call(this,t,tt,ta),this._relate=new Or(this._arg)}};var tM=Object.freeze({__proto__:null,RelateOp:qr});let Vr=class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static union(t,tt){return new Vr(t,tt).union()}union(){let t=new fn,tt=new ct;for(let ta=0;ta<this._pointGeom.getNumGeometries();ta++){let th=this._pointGeom.getGeometryN(ta).getCoordinate();t.locate(th,this._otherGeom)===se.EXTERIOR&&tt.add(th)}if(0===tt.size())return this._otherGeom;let ta=null,th=X.toCoordinateArray(tt);return ta=1===th.length?this._geomFact.createPoint(th[0]):this._geomFact.createMultiPointFromCoords(th),_e.combine(ta,this._otherGeom)}getClass(){return Vr}get interfaces_(){return[]}};Vr.constructor_=function(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;let t=arguments[0],tt=arguments[1];this._pointGeom=t,this._otherGeom=tt,this._geomFact=tt.getFactory()};let zr=class zr{constructor(){zr.constructor_.apply(this,arguments)}static restrictToPolygons(t){if(_(t,bt))return t;let tt=Ce.getPolygons(t);return 1===tt.size()?tt.get(0):t.getFactory().createMultiPolygon(Wt.toPolygonArray(tt))}static getGeometry(t,tt){return tt>=t.size()?null:t.get(tt)}static union(t){return new zr(t).union()}reduceToGeometries(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next(),th=null;_(t,m)?th=this.unionTree(t):t instanceof q&&(th=t),tt.add(th)}return tt}extractByEnvelope(t,tt,ta){let th=new x;for(let tu=0;tu<tt.getNumGeometries();tu++){let tc=tt.getGeometryN(tu);tc.getEnvelopeInternal().intersects(t)?th.add(tc):ta.add(tc)}return this._geomFactory.buildGeometry(th)}unionOptimized(t,tt){let ta=t.getEnvelopeInternal(),th=tt.getEnvelopeInternal();if(!ta.intersects(th))return _e.combine(t,tt);if(1>=t.getNumGeometries()&&1>=tt.getNumGeometries())return this.unionActual(t,tt);let tu=ta.intersection(th);return this.unionUsingEnvelopeIntersection(t,tt,tu)}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();let t=new Is(zr.STRTREE_NODE_CAPACITY);for(let tt=this._inputPolys.iterator();tt.hasNext();){let ta=tt.next();t.insert(ta.getEnvelopeInternal(),ta)}this._inputPolys=null;let tt=t.itemsTree();return this.unionTree(tt)}binaryUnion(){if(1==arguments.length){let t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(ta-tt<=1){let ta=zr.getGeometry(t,tt);return this.unionSafe(ta,null)}if(ta-tt==2)return this.unionSafe(zr.getGeometry(t,tt),zr.getGeometry(t,tt+1));{let th=Math.trunc((ta+tt)/2),tu=this.binaryUnion(t,tt,th),tc=this.binaryUnion(t,th,ta);return this.unionSafe(tu,tc)}}}repeatedUnion(t){let tt=null;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt=null===tt?t.copy():tt.union(t)}return tt}unionSafe(t,tt){return null===t&&null===tt?null:null===t?tt.copy():null===tt?t.copy():this.unionOptimized(t,tt)}unionActual(t,tt){return zr.restrictToPolygons(t.union(tt))}unionTree(t){let tt=this.reduceToGeometries(t);return this.binaryUnion(tt)}unionUsingEnvelopeIntersection(t,tt,ta){let th=new x,tu=this.extractByEnvelope(ta,t,th),tc=this.extractByEnvelope(ta,tt,th),tg=this.unionActual(tu,tc);return th.add(tg),_e.combine(th)}bufferUnion(){if(1==arguments.length){let t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return t.getFactory().createGeometryCollection([t,tt]).buffer(0)}}getClass(){return zr}get interfaces_(){return[]}};zr.constructor_=function(){this._inputPolys=null,this._geomFactory=null;let t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new x)},zr.STRTREE_NODE_CAPACITY=4;let Yr=class Yr{constructor(){Yr.constructor_.apply(this,arguments)}static union(){if(1==arguments.length){if(_(arguments[0],f)){let t=arguments[0];return new Yr(t).union()}if(arguments[0]instanceof q){let t=arguments[0];return new Yr(t).union()}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new Yr(t,tt).union()}}unionNoOpt(t){let tt=this._geomFact.createPoint();return ar.overlayOp(t,tt,hr.UNION)}unionWithNull(t,tt){return null===t&&null===tt?null:null===tt?t:null===t?tt:t.union(tt)}extract(){if(_(arguments[0],f))for(let t=arguments[0].iterator();t.hasNext();){let tt=t.next();this.extract(tt)}else if(arguments[0]instanceof q){let t=arguments[0];null===this._geomFact&&(this._geomFact=t.getFactory()),fe.extract(t,q.TYPENAME_POLYGON,this._polygons),fe.extract(t,q.TYPENAME_LINESTRING,this._lines),fe.extract(t,q.TYPENAME_POINT,this._points)}}union(){if(null===this._geomFact)return null;let t=null;if(this._points.size()>0){let tt=this._geomFact.buildGeometry(this._points);t=this.unionNoOpt(tt)}let tt=null;if(this._lines.size()>0){let t=this._geomFact.buildGeometry(this._lines);tt=this.unionNoOpt(t)}let ta=null;this._polygons.size()>0&&(ta=zr.union(this._polygons));let th=this.unionWithNull(tt,ta),tu=null;return null===(tu=null===t?th:null===th?t:Vr.union(t,th))?this._geomFact.createGeometryCollection():tu}getClass(){return Yr}get interfaces_(){return[]}};Yr.constructor_=function(){if(this._polygons=new x,this._lines=new x,this._points=new x,this._geomFact=null,1==arguments.length){if(_(arguments[0],f)){let t=arguments[0];this.extract(t)}else if(arguments[0]instanceof q){let t=arguments[0];this.extract(t)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._geomFact=tt,this.extract(t)}};var tD=Object.freeze({__proto__:null,BoundaryOp:mt,IsSimpleOp:Ws,buffer:tw,distance:tT,linemerge:tv,overlay:tO,polygonize:tb,relate:tM,union:Object.freeze({__proto__:null,UnaryUnionOp:Yr}),valid:Object.freeze({__proto__:null,IsValidOp:Sr,ConsistentAreaTester:Ir})});let Hr=class Hr extends Gt.CoordinateOperation{constructor(){super(),Hr.constructor_.apply(this,arguments)}edit(){if(2==arguments.length&&arguments[1]instanceof q&&arguments[0]instanceof Array){let t=arguments[0],tt=arguments[1];if(0===t.length)return null;let ta=Array(t.length).fill(null);for(let tt=0;tt<t.length;tt++){let th=new g(t[tt]);this._targetPM.makePrecise(th),ta[tt]=th}let th=new I(ta,!1).toCoordinateArray(),tu=0;tt instanceof Rt&&(tu=2),tt instanceof At&&(tu=4);let tc=ta;return this._removeCollapsed&&(tc=null),th.length<tu?tc:th}return super.edit.apply(this,arguments)}getClass(){return Hr}get interfaces_(){return[]}};Hr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0;let t=arguments[0],tt=arguments[1];this._targetPM=t,this._removeCollapsed=tt};let Wr=class Wr{constructor(){Wr.constructor_.apply(this,arguments)}static reduce(t,tt){return new Wr(tt).reduce(t)}static reducePointwise(t,tt){let ta=new Wr(tt);return ta.setPointwise(!0),ta.reduce(t)}fixPolygonalTopology(t){let tt=t;this._changePrecisionModel||(tt=this.changePM(t,this._targetPM));let ta=wi.bufferOp(tt,0),th=ta;return this._changePrecisionModel||(th=t.getFactory().createGeometry(ta)),th}reducePointwise(t){let tt=null;if(this._changePrecisionModel){let ta=this.createFactory(t.getFactory(),this._targetPM);tt=new Gt(ta)}else tt=new Gt;let ta=this._removeCollapsed;return t.getDimension()>=2&&(ta=!0),tt.edit(t,new Hr(this._targetPM,ta))}changePM(t,tt){return this.createEditor(t.getFactory(),tt).edit(t,new Gt.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,tt){return new Wt(tt,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){let tt=this.reducePointwise(t);return this._isPointwise?tt:_(tt,bt)?Sr.isValid(tt)?tt:this.fixPolygonalTopology(tt):tt}setPointwise(t){this._isPointwise=t}createEditor(t,tt){if(t.getPrecisionModel()===tt)return new Gt;let ta=this.createFactory(t,tt);return new Gt(ta)}getClass(){return Wr}get interfaces_(){return[]}};Wr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;let t=arguments[0];this._targetPM=t};var tA=Object.freeze({__proto__:null,GeometryPrecisionReducer:Wr});let Kr=class Kr{constructor(){Kr.constructor_.apply(this,arguments)}static simplify(t,tt){let ta=new Kr(t);return ta.setDistanceTolerance(tt),ta.simplify()}simplifySection(t,tt){if(t+1===tt)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[tt];let ta=-1,th=t;for(let tu=t+1;tu<tt;tu++){let t=this._seg.distance(this._pts[tu]);t>ta&&(ta=t,th=tu)}if(ta<=this._distanceTolerance)for(let ta=t+1;ta<tt;ta++)this._usePt[ta]=!1;else this.simplifySection(t,th),this.simplifySection(th,tt)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);let t=new I;for(let tt=0;tt<this._pts.length;tt++)this._usePt[tt]&&t.add(new g(this._pts[tt]));return t.toCoordinateArray()}getClass(){return Kr}get interfaces_(){return[]}};Kr.constructor_=function(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new ne;let t=arguments[0];this._pts=t};let Zr=class Zr{constructor(){Zr.constructor_.apply(this,arguments)}static simplify(t,tt){let ta=new Zr(t);return ta.setDistanceTolerance(tt),ta.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Qr(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return Zr}get interfaces_(){return[]}};let Qr=class Qr extends ye{constructor(){super(),Qr.constructor_.apply(this,arguments)}transformPolygon(t,tt){if(t.isEmpty())return null;let ta=super.transformPolygon.call(this,t,tt);return tt instanceof Ft?ta:this.createValidArea(ta)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,tt){let ta=t.toCoordinateArray(),th=null;return th=0===ta.length?[].fill(null):Kr.simplify(ta,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(th)}transformMultiPolygon(t,tt){let ta=super.transformMultiPolygon.call(this,t,tt);return this.createValidArea(ta)}transformLinearRing(t,tt){let ta=tt instanceof Mt,th=super.transformLinearRing.call(this,t,tt);return!ta||th instanceof At?th:null}getClass(){return Qr}get interfaces_(){return[]}};Qr.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;let t=arguments[0],tt=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=tt},Zr.DPTransformer=Qr,Zr.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;let t=arguments[0];this._inputGeom=t};let Jr=class Jr extends ne{constructor(){super(),Jr.constructor_.apply(this,arguments)}getIndex(){return this._index}getParent(){return this._parent}getClass(){return Jr}get interfaces_(){return[]}};Jr.constructor_=function(){if(this._parent=null,this._index=null,2==arguments.length){let t=arguments[0],tt=arguments[1];Jr.constructor_.call(this,t,tt,null,-1)}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];ne.constructor_.call(this,t,tt),this._parent=ta,this._index=th}};let $r=class $r{constructor(){$r.constructor_.apply(this,arguments)}static extractCoordinates(t){let tt=Array(t.size()+1).fill(null),ta=null;for(let th=0;th<t.size();th++)ta=t.get(th),tt[th]=ta.p0;return tt[tt.length-1]=ta.p1,tt}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString($r.extractCoordinates(this._resultSegs))}getResultSize(){let t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing($r.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){let t=this._parentLine.getCoordinates();this._segs=Array(t.length-1).fill(null);for(let tt=0;tt<t.length-1;tt++){let ta=new Jr(t[tt],t[tt+1],this._parentLine,tt);this._segs[tt]=ta}}getResultCoordinates(){return $r.extractCoordinates(this._resultSegs)}getClass(){return $r}get interfaces_(){return[]}};$r.constructor_=function(){if(this._parentLine=null,this._segs=null,this._resultSegs=new x,this._minimumSize=null,1==arguments.length){let t=arguments[0];$r.constructor_.call(this,t,2)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._parentLine=t,this._minimumSize=tt,this.init()}};let to=class to{constructor(){to.constructor_.apply(this,arguments)}remove(t){this._index.remove(new N(t.p0,t.p1),t)}add(){if(arguments[0]instanceof $r){let t=arguments[0].getSegments();for(let tt=0;tt<t.length;tt++){let ta=t[tt];this.add(ta)}}else if(arguments[0]instanceof ne){let t=arguments[0];this._index.insert(new N(t.p0,t.p1),t)}}query(t){let tt=new N(t.p0,t.p1),ta=new eo(t);return this._index.query(tt,ta),ta.getItems()}getClass(){return to}get interfaces_(){return[]}};to.constructor_=function(){this._index=new gs};let eo=class eo{constructor(){eo.constructor_.apply(this,arguments)}visitItem(t){N.intersects(t.p0,t.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}getClass(){return eo}get interfaces_(){return[Fe]}};eo.constructor_=function(){this._querySeg=null,this._items=new x;let t=arguments[0];this._querySeg=t};let no=class no{constructor(){no.constructor_.apply(this,arguments)}static isInLineSection(t,tt,ta){if(ta.getParent()!==t.getParent())return!1;let th=ta.getIndex();return th>=tt[0]&&th<tt[1]}flatten(t,tt){let ta=this._linePts[t],th=this._linePts[tt],tu=new ne(ta,th);return this.remove(this._line,t,tt),this._outputIndex.add(tu),tu}hasBadIntersection(t,tt,ta){return!!this.hasBadOutputIntersection(ta)||!!this.hasBadInputIntersection(t,tt,ta)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,tt,ta){ta+=1;let th=[,,].fill(null);if(t+1===tt){let tt=this._line.getSegment(t);return this._line.addToResult(tt),null}let tu=!0;this._line.getResultSize()<this._line.getMinimumSize()&&ta+1<this._line.getMinimumSize()&&(tu=!1);let tc=[,].fill(null),tg=this.findFurthestPoint(this._linePts,t,tt,tc);tc[0]>this._distanceTolerance&&(tu=!1);let t_=new ne;if(t_.p0=this._linePts[t],t_.p1=this._linePts[tt],th[0]=t,th[1]=tt,this.hasBadIntersection(this._line,th,t_)&&(tu=!1),tu){let ta=this.flatten(t,tt);return this._line.addToResult(ta),null}this.simplifySection(t,tg,ta),this.simplifySection(tg,tt,ta)}hasBadOutputIntersection(t){for(let tt=this._outputIndex.query(t).iterator();tt.hasNext();){let ta=tt.next();if(this.hasInteriorIntersection(ta,t))return!0}return!1}findFurthestPoint(t,tt,ta,th){let tu=new ne;tu.p0=t[tt],tu.p1=t[ta];let tc=-1,tg=tt;for(let th=tt+1;th<ta;th++){let tt=t[th],ta=tu.distance(tt);ta>tc&&(tc=ta,tg=th)}return th[0]=tc,tg}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,tt,ta){for(let th=tt;th<ta;th++){let tt=t.getSegment(th);this._inputIndex.remove(tt)}}hasInteriorIntersection(t,tt){return this._li.computeIntersection(t.p0,t.p1,tt.p0,tt.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,tt,ta){for(let th=this._inputIndex.query(ta).iterator();th.hasNext();){let tu=th.next();if(this.hasInteriorIntersection(tu,ta)){if(no.isInLineSection(t,tt,tu))continue;return!0}}return!1}getClass(){return no}get interfaces_(){return[]}};no.constructor_=function(){this._li=new ee,this._inputIndex=new to,this._outputIndex=new to,this._line=null,this._linePts=null,this._distanceTolerance=0;let t=arguments[0],tt=arguments[1];this._inputIndex=t,this._outputIndex=tt};let so=class so{constructor(){so.constructor_.apply(this,arguments)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let tt=t.iterator();tt.hasNext();)this._inputIndex.add(tt.next());for(let tt=t.iterator();tt.hasNext();){let t=new no(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(tt.next())}}getClass(){return so}get interfaces_(){return[]}};so.constructor_=function(){this._inputIndex=new to,this._outputIndex=new to,this._distanceTolerance=0};let io=class io{constructor(){io.constructor_.apply(this,arguments)}static simplify(t,tt){let ta=new io(t);return ta.setDistanceTolerance(tt),ta.getResultGeometry()}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():(this._linestringMap=new kt,this._inputGeom.apply(new oo(this)),this._lineSimplifier.simplify(this._linestringMap.values()),new ro(this._linestringMap).transform(this._inputGeom))}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}getClass(){return io}get interfaces_(){return[]}};let ro=class ro extends ye{constructor(){super(),ro.constructor_.apply(this,arguments)}transformCoordinates(t,tt){if(0===t.size())return null;if(tt instanceof Rt){let t=this._linestringMap.get(tt);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,tt)}getClass(){return ro}get interfaces_(){return[]}};ro.constructor_=function(){this._linestringMap=null;let t=arguments[0];this._linestringMap=t};let oo=class oo{constructor(){oo.constructor_.apply(this,arguments)}filter(t){if(t instanceof Rt){if(t.isEmpty())return null;let tt=t.isClosed()?4:2,ta=new $r(t,tt);this.tps._linestringMap.put(t,ta)}}getClass(){return oo}get interfaces_(){return[G]}};oo.constructor_=function(){this.tps=null;let t=arguments[0];this.tps=t},io.LineStringTransformer=ro,io.LineStringMapBuilderFilter=oo,io.constructor_=function(){this._inputGeom=null,this._lineSimplifier=new so,this._linestringMap=null;let t=arguments[0];this._inputGeom=t};let lo=class lo{constructor(){lo.constructor_.apply(this,arguments)}static simplify(t,tt){return new lo(t,tt).simplify()}simplifyVertex(t){let tt=t,ta=tt.getArea(),th=null;for(;null!==tt;){let t=tt.getArea();t<ta&&(ta=t,th=tt),tt=tt._next}return null!==th&&ta<this._tolerance&&th.remove(),t.isLive()?ta:-1}simplify(){let t=ao.buildLine(this._pts),tt=this._tolerance;do tt=this.simplifyVertex(t);while(tt<this._tolerance);let ta=t.getCoordinates();return ta.length<2?[ta[0],new g(ta[0])]:ta}getClass(){return lo}get interfaces_(){return[]}};let ao=class ao{constructor(){ao.constructor_.apply(this,arguments)}static buildLine(t){let tt=null,ta=null;for(let th=0;th<t.length;th++){let tu=new ao(t[th]);null===tt&&(tt=tu),tu.setPrev(ta),null!==ta&&(ta.setNext(tu),ta.updateArea()),ta=tu}return tt}getCoordinates(){let t=new I,tt=this;do t.add(tt._pt,!1),tt=tt._next;while(null!==tt);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=ao.MAX_AREA,null;this._area=Math.abs(oe.area(this._prev._pt,this._pt,this._next._pt))}remove(){let t=this._prev,tt=this._next,ta=null;return null!==this._prev&&(this._prev.setNext(tt),this._prev.updateArea(),ta=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===ta&&(ta=this._next)),this._isLive=!1,ta}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}getClass(){return ao}get interfaces_(){return[]}};ao.constructor_=function(){this._pt=null,this._prev=null,this._next=null,this._area=ao.MAX_AREA,this._isLive=!0;let t=arguments[0];this._pt=t},ao.MAX_AREA=i.MAX_VALUE,lo.VWVertex=ao,lo.constructor_=function(){this._pts=null,this._tolerance=null;let t=arguments[0],tt=arguments[1];this._pts=t,this._tolerance=tt*tt};let co=class co{constructor(){co.constructor_.apply(this,arguments)}static simplify(t,tt){let ta=new co(t);return ta.setDistanceTolerance(tt),ta.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new ho(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return co}get interfaces_(){return[]}};let ho=class ho extends ye{constructor(){super(),ho.constructor_.apply(this,arguments)}transformPolygon(t,tt){if(t.isEmpty())return null;let ta=super.transformPolygon.call(this,t,tt);return tt instanceof Ft?ta:this.createValidArea(ta)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,tt){let ta=t.toCoordinateArray(),th=null;return th=0===ta.length?[].fill(null):lo.simplify(ta,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(th)}transformMultiPolygon(t,tt){let ta=super.transformMultiPolygon.call(this,t,tt);return this.createValidArea(ta)}transformLinearRing(t,tt){let ta=tt instanceof Mt,th=super.transformLinearRing.call(this,t,tt);return!ta||th instanceof At?th:null}getClass(){return ho}get interfaces_(){return[]}};ho.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;let t=arguments[0],tt=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=tt},co.VWTransformer=ho,co.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;let t=arguments[0];this._inputGeom=t};var tF=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Zr,TopologyPreservingSimplifier:io,VWSimplifier:co});let go=class go{constructor(){go.constructor_.apply(this,arguments)}static pointAlongReverse(t,tt){let ta=new g;return ta.x=t.p1.x-tt*(t.p1.x-t.p0.x),ta.y=t.p1.y-tt*(t.p1.y-t.p0.y),ta}splitAt(){if(1==arguments.length){let t=arguments[0],tt=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(tt),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=go.pointAlongReverse(this._seg,tt),null;this._splitPt=t}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=this.getConstrainedLength(t)/this._segLen;tt.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(ta):this._splitPt=go.pointAlongReverse(this._seg,ta)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}getClass(){return go}get interfaces_(){return[]}};go.constructor_=function(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;let t=arguments[0];this._seg=t,this._segLen=t.getLength()};let _o=class _o{constructor(){_o.constructor_.apply(this,arguments)}findSplitPoint(t,tt){}getClass(){return _o}get interfaces_(){return[]}};_o.constructor_=function(){};let fo=class fo{constructor(){fo.constructor_.apply(this,arguments)}static projectedSplitPoint(t,tt){return t.getLineSegment().project(tt)}findSplitPoint(t,tt){let ta=t.getLineSegment(),th=ta.getLength()/2,tu=new go(ta),tc=fo.projectedSplitPoint(t,tt),tg=2*tc.distance(tt)*.8;return tg>th&&(tg=th),tu.setMinimumLength(tg),tu.splitAt(tc),tu.getSplitPoint()}getClass(){return fo}get interfaces_(){return[_o]}};fo.constructor_=function(){};let po=class po{constructor(){po.constructor_.apply(this,arguments)}static triArea(t,tt,ta){return(tt.x-t.x)*(ta.y-t.y)-(tt.y-t.y)*(ta.x-t.x)}static isInCircleDDNormalized(t,tt,ta,th){let tu=R.valueOf(t.x).selfSubtract(th.x),tc=R.valueOf(t.y).selfSubtract(th.y),tg=R.valueOf(tt.x).selfSubtract(th.x),t_=R.valueOf(tt.y).selfSubtract(th.y),td=R.valueOf(ta.x).selfSubtract(th.x),tp=R.valueOf(ta.y).selfSubtract(th.y),tf=tu.multiply(t_).selfSubtract(tg.multiply(tc)),tm=tg.multiply(tp).selfSubtract(td.multiply(t_)),ty=td.multiply(tc).selfSubtract(tu.multiply(tp)),tx=tu.multiply(tu).selfAdd(tc.multiply(tc)),tE=tg.multiply(tg).selfAdd(t_.multiply(t_)),tI=td.multiply(td).selfAdd(tp.multiply(tp));return tx.selfMultiply(tm).selfAdd(tE.selfMultiply(ty)).selfAdd(tI.selfMultiply(tf)).doubleValue()>0}static checkRobustInCircle(t,tt,ta,th){let tu=po.isInCircleNonRobust(t,tt,ta,th),tc=po.isInCircleDDSlow(t,tt,ta,th),tg=po.isInCircleCC(t,tt,ta,th),t_=oe.circumcentre(t,tt,ta);O.out.println("p radius diff a = "+Math.abs(th.distance(t_)-t.distance(t_))/t.distance(t_)),tu===tc&&tu===tg||(O.out.println("inCircle robustness failure (double result = "+tu+", DD result = "+tc+", CC result = "+tg+")"),O.out.println($t.toLineString(new Yt([t,tt,ta,th]))),O.out.println("Circumcentre = "+$t.toPoint(t_)+" radius = "+t.distance(t_)),O.out.println("p radius diff a = "+Math.abs(th.distance(t_)/t.distance(t_)-1)),O.out.println("p radius diff b = "+Math.abs(th.distance(t_)/tt.distance(t_)-1)),O.out.println("p radius diff c = "+Math.abs(th.distance(t_)/ta.distance(t_)-1)),O.out.println())}static isInCircleDDFast(t,tt,ta,th){let tu=R.sqr(t.x).selfAdd(R.sqr(t.y)).selfMultiply(po.triAreaDDFast(tt,ta,th)),tc=R.sqr(tt.x).selfAdd(R.sqr(tt.y)).selfMultiply(po.triAreaDDFast(t,ta,th)),tg=R.sqr(ta.x).selfAdd(R.sqr(ta.y)).selfMultiply(po.triAreaDDFast(t,tt,th)),t_=R.sqr(th.x).selfAdd(R.sqr(th.y)).selfMultiply(po.triAreaDDFast(t,tt,ta));return tu.selfSubtract(tc).selfAdd(tg).selfSubtract(t_).doubleValue()>0}static isInCircleCC(t,tt,ta,th){let tu=oe.circumcentre(t,tt,ta),tc=t.distance(tu);return th.distance(tu)-tc<=0}static isInCircleNormalized(t,tt,ta,th){let tu=t.x-th.x,tc=t.y-th.y,tg=tt.x-th.x,t_=tt.y-th.y,td=ta.x-th.x,tp=ta.y-th.y;return(tu*tu+tc*tc)*(tg*tp-td*t_)+(tg*tg+t_*t_)*(td*tc-tu*tp)+(td*td+tp*tp)*(tu*t_-tg*tc)>0}static isInCircleDDSlow(t,tt,ta,th){let tu=R.valueOf(th.x),tc=R.valueOf(th.y),tg=R.valueOf(t.x),t_=R.valueOf(t.y),td=R.valueOf(tt.x),tp=R.valueOf(tt.y),tf=R.valueOf(ta.x),tm=R.valueOf(ta.y),ty=tg.multiply(tg).add(t_.multiply(t_)).multiply(po.triAreaDDSlow(td,tp,tf,tm,tu,tc)),tx=td.multiply(td).add(tp.multiply(tp)).multiply(po.triAreaDDSlow(tg,t_,tf,tm,tu,tc)),tE=tf.multiply(tf).add(tm.multiply(tm)).multiply(po.triAreaDDSlow(tg,t_,td,tp,tu,tc)),tI=tu.multiply(tu).add(tc.multiply(tc)).multiply(po.triAreaDDSlow(tg,t_,td,tp,tf,tm));return ty.subtract(tx).add(tE).subtract(tI).doubleValue()>0}static isInCircleNonRobust(t,tt,ta,th){return(t.x*t.x+t.y*t.y)*po.triArea(tt,ta,th)-(tt.x*tt.x+tt.y*tt.y)*po.triArea(t,ta,th)+(ta.x*ta.x+ta.y*ta.y)*po.triArea(t,tt,th)-(th.x*th.x+th.y*th.y)*po.triArea(t,tt,ta)>0}static isInCircleRobust(t,tt,ta,th){return po.isInCircleNormalized(t,tt,ta,th)}static triAreaDDSlow(t,tt,ta,th,tu,tc){return ta.subtract(t).multiply(tc.subtract(tt)).subtract(th.subtract(tt).multiply(tu.subtract(t)))}static triAreaDDFast(t,tt,ta){let th=R.valueOf(tt.x).selfSubtract(t.x).selfMultiply(R.valueOf(ta.y).selfSubtract(t.y)),tu=R.valueOf(tt.y).selfSubtract(t.y).selfMultiply(R.valueOf(ta.x).selfSubtract(t.x));return th.selfSubtract(tu)}getClass(){return po}get interfaces_(){return[]}};po.constructor_=function(){};let mo=class mo{constructor(){mo.constructor_.apply(this,arguments)}static interpolateZ(){if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=tt.distance(ta),tu=t.distance(tt),tc=ta.z-tt.z;return tt.z+tc*(tu/th)}if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=tt.x,tc=tt.y,tg=ta.x-tu,t_=th.x-tu,td=ta.y-tc,tp=th.y-tc,tf=tg*tp-t_*td,tm=t.x-tu,ty=t.y-tc;return tt.z+(tp*tm-t_*ty)/tf*(ta.z-tt.z)+(-td*tm+tg*ty)/tf*(th.z-tt.z)}}circleCenter(t,tt){let ta=new mo(this.getX(),this.getY()),th=this.bisector(ta,t),tu=this.bisector(t,tt),tc=new b(th,tu),tg=null;try{tg=new mo(tc.getX(),tc.getY())}catch(th){if(!(th instanceof S))throw th;O.err.println("a: "+ta+"  b: "+t+"  c: "+tt),O.err.println(th)}return tg}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.z}bisector(t,tt){let ta=tt.getX()-t.getX(),th=tt.getY()-t.getY(),tu=new b(t.getX()+ta/2,t.getY()+th/2,1),tc=new b(t.getX()-th+ta/2,t.getY()+ta+th/2,1);return new b(tu,tc)}equals(){if(1==arguments.length){let t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return this._p.distance(t.getCoordinate())<tt}}getCoordinate(){return this._p}isInCircle(t,tt,ta){return po.isInCircleRobust(t._p,tt._p,ta._p,this._p)}interpolateZValue(t,tt,ta){let th=t.getX(),tu=t.getY(),tc=tt.getX()-th,tg=ta.getX()-th,t_=tt.getY()-tu,td=ta.getY()-tu,tp=tc*td-tg*t_,tf=this.getX()-th,tm=this.getY()-tu;return t.getZ()+(td*tf-tg*tm)/tp*(tt.getZ()-t.getZ())+(-t_*tf+tc*tm)/tp*(ta.getZ()-t.getZ())}midPoint(t){let tt=(this._p.x+t.getX())/2,ta=(this._p.y+t.getY())/2,th=(this._p.z+t.getZ())/2;return new mo(tt,ta,th)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,tt){return(t._p.x-this._p.x)*(tt._p.y-this._p.y)-(t._p.y-this._p.y)*(tt._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.z=t}times(t){return new mo(t*this._p.x,t*this._p.y)}cross(){return new mo(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new mo(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,tt){let ta=tt.sub(t),th=this.sub(t),tu=ta.crossProduct(th);return tu>0?mo.LEFT:tu<0?mo.RIGHT:ta.getX()*th.getX()<0||ta.getY()*th.getY()<0?mo.BEHIND:ta.magn()<th.magn()?mo.BEYOND:t.equals(this)?mo.ORIGIN:tt.equals(this)?mo.DESTINATION:mo.BETWEEN}sum(t){return new mo(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,tt){return Math.sqrt(Math.pow(tt.getX()-t.getX(),2)+Math.pow(tt.getY()-t.getY(),2))}circumRadiusRatio(t,tt){let ta=this.circleCenter(t,tt),th=this.distance(ta,t),tu=this.distance(this,t),tc=this.distance(t,tt);return tc<tu&&(tu=tc),(tc=this.distance(tt,this))<tu&&(tu=tc),th/tu}getClass(){return mo}get interfaces_(){return[]}};mo.constructor_=function(){if(this._p=null,1==arguments.length){let t=arguments[0];this._p=new g(t)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];this._p=new g(t,tt)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._p=new g(t,tt,ta)}},mo.LEFT=0,mo.RIGHT=1,mo.BEYOND=2,mo.BEHIND=3,mo.BETWEEN=4,mo.ORIGIN=5,mo.DESTINATION=6;let yo=class yo extends mo{constructor(){super(),yo.constructor_.apply(this,arguments)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}getClass(){return yo}get interfaces_(){return[]}};yo.constructor_=function(){this._isOnConstraint=null,this._constraint=null;let t=arguments[0];mo.constructor_.call(this,t)};let xo=class xo{constructor(){xo.constructor_.apply(this,arguments)}static makeEdge(t,tt){let ta=new xo,th=new xo,tu=new xo,tc=new xo;return ta._rot=th,th._rot=tu,tu._rot=tc,tc._rot=ta,ta.setNext(ta),th.setNext(tc),tu.setNext(tu),tc.setNext(th),ta.setOrig(t),ta.setDest(tt),ta}static swap(t){let tt=t.oPrev(),ta=t.sym().oPrev();xo.splice(t,tt),xo.splice(t.sym(),ta),xo.splice(t,tt.lNext()),xo.splice(t.sym(),ta.lNext()),t.setOrig(tt.dest()),t.setDest(ta.dest())}static splice(t,tt){let ta=t.oNext().rot(),th=tt.oNext().rot(),tu=tt.oNext(),tc=t.oNext(),tg=th.oNext(),t_=ta.oNext();t.setNext(tu),tt.setNext(tc),ta.setNext(tg),th.setNext(t_)}static connect(t,tt){let ta=xo.makeEdge(t.dest(),tt.orig());return xo.splice(ta,t.lNext()),xo.splice(ta.sym(),tt),ta}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new ne(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){let t=this._vertex.getCoordinate(),tt=this.dest().getCoordinate();return $t.toLineString(t,tt)}isLive(){return null!==this._rot}getPrimary(){return 0>=this.orig().getCoordinate().compareTo(this.dest().getCoordinate())?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}getClass(){return xo}get interfaces_(){return[]}};xo.constructor_=function(){this._rot=null,this._vertex=null,this._next=null,this._data=null};let Eo=class Eo{constructor(){Eo.constructor_.apply(this,arguments)}insertSite(t){let tt=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(tt,t))return tt;this._subdiv.isOnEdge(tt,t.getCoordinate())&&(tt=tt.oPrev(),this._subdiv.delete(tt.oNext()));let ta=this._subdiv.makeEdge(tt.orig(),t);xo.splice(ta,tt);let th=ta;do tt=(ta=this._subdiv.connect(tt,ta.sym())).oPrev();while(tt.lNext()!==th);for(;;){let tu=tt.oPrev();if(tu.dest().rightOf(tt)&&t.isInCircle(tt.orig(),tu.dest(),tt.dest()))xo.swap(tt),tt=tt.oPrev();else{if(tt.oNext()===th)return ta;tt=tt.oNext().lPrev()}}}insertSites(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this.insertSite(t)}}getClass(){return Eo}get interfaces_(){return[]}};Eo.constructor_=function(){this._subdiv=null,this._isUsingTolerance=!1;let t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0};let Io=class Io{constructor(){Io.constructor_.apply(this,arguments)}locate(t){}getClass(){return Io}get interfaces_(){return[]}};Io.constructor_=function(){};let No=class No{constructor(){No.constructor_.apply(this,arguments)}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();let tt=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=tt,tt}findEdge(){return this._subdiv.getEdges().iterator().next()}getClass(){return No}get interfaces_(){return[Io]}};No.constructor_=function(){this._subdiv=null,this._lastEdge=null;let t=arguments[0];this._subdiv=t,this.init()};let Co=class Co extends c{constructor(){super(),Co.constructor_.apply(this,arguments)}static msgWithSpatial(t,tt){return null!==tt?t+" [ "+tt+" ]":t}getSegment(){return this._seg}getClass(){return Co}get interfaces_(){return[]}};Co.constructor_=function(){if(this._seg=null,1==arguments.length){if("string"==typeof arguments[0]){let t=arguments[0];c.constructor_.call(this,t)}else if(arguments[0]instanceof ne){let t=arguments[0];c.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new ne(t)}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];c.constructor_.call(this,Co.msgWithSpatial(t,tt)),this._seg=new ne(tt)}};let So=class So{constructor(){So.constructor_.apply(this,arguments)}visit(t){}getClass(){return So}get interfaces_(){return[]}};So.constructor_=function(){};let wo=class wo{constructor(){wo.constructor_.apply(this,arguments)}static getTriangleEdges(t,tt){if(tt[0]=t,tt[1]=tt[0].lNext(),tt[2]=tt[1].lNext(),tt[2].lNext()!==tt[0])throw new n("Edges do not form a triangle")}getTriangleVertices(t){let tt=new Ro;return this.visitTriangles(tt,t),tt.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2])}isVertexOfEdge(t,tt){return!(!tt.equals(t.orig(),this._tolerance)&&!tt.equals(t.dest(),this._tolerance))}connect(t,tt){let ta=xo.connect(t,tt);return this._quadEdges.add(ta),ta}getVoronoiCellPolygon(t,tt){let ta=new x,th=t;do{let tt=t.rot().orig().getCoordinate();ta.add(tt),t=t.oPrev()}while(t!==th);let tu=new I;tu.addAll(ta,!1),tu.closeRing(),4>tu.size()&&(O.out.println(tu),tu.add(tu.get(tu.size()-1),!0));let tc=tu.toCoordinateArray(),tg=tt.createPolygon(tt.createLinearRing(tc)),t_=th.orig();return tg.setUserData(t_.getCoordinate()),tg}setLocator(t){this._locator=t}initSubdiv(){let t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),tt=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);xo.splice(t.sym(),tt);let ta=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return xo.splice(tt.sym(),ta),xo.splice(ta.sym(),t),t}isFrameBorderEdge(t){let tt=[,,,].fill(null);wo.getTriangleEdges(t,tt);let ta=[,,,].fill(null);wo.getTriangleEdges(t.sym(),ta);let th=t.lNext().dest();if(this.isFrameVertex(th))return!0;let tu=t.sym().lNext().dest();return!!this.isFrameVertex(tu)}makeEdge(t,tt){let ta=xo.makeEdge(t,tt);return this._quadEdges.add(ta),ta}visitTriangles(t,tt){this._visitedKey++;let ta=new ln;ta.push(this._startingEdge);let th=new J;for(;!ta.empty();){let tu=ta.pop();if(!th.contains(tu)){let tc=this.fetchTriangleToVisit(tu,ta,tt,th);null!==tc&&t.visit(tc)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,tt){return this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate()),this._seg.distance(tt)<this._edgeCoincidenceTolerance}getEnvelope(){return new N(this._frameEnv)}createFrame(t){let tt=t.getWidth(),ta=t.getHeight(),th=0;th=tt>ta?10*tt:10*ta,this._frameVertex[0]=new mo((t.getMaxX()+t.getMinX())/2,t.getMaxY()+th),this._frameVertex[1]=new mo(t.getMinX()-th,t.getMinY()-th),this._frameVertex[2]=new mo(t.getMaxX()+th,t.getMinY()-th),this._frameEnv=new N(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){let tt=new Po;return this.visitTriangles(tt,t),tt.getTriangles()}getVertices(t){let tt=new J;for(let ta=this._quadEdges.iterator();ta.hasNext();){let th=ta.next(),tu=th.orig();!t&&this.isFrameVertex(tu)||tt.add(tu);let tc=th.dest();!t&&this.isFrameVertex(tc)||tt.add(tc)}return tt}fetchTriangleToVisit(t,tt,ta,th){let tu=t,tc=0,tg=!1;do{this._triEdges[tc]=tu,this.isFrameEdge(tu)&&(tg=!0);let t=tu.sym();th.contains(t)||tt.push(t),th.add(tu),tc++,tu=tu.lNext()}while(tu!==t);return tg&&!ta?null:this._triEdges}getEdges(){if(0==arguments.length)return this._quadEdges;if(1==arguments.length){let t=arguments[0],tt=this.getPrimaryEdges(!1),ta=Array(tt.size()).fill(null),th=0;for(let tu=tt.iterator();tu.hasNext();){let tt=tu.next();ta[th++]=t.createLineString([tt.orig().getCoordinate(),tt.dest().getCoordinate()])}return t.createMultiLineString(ta)}}getVertexUniqueEdges(t){let tt=new x,ta=new J;for(let th=this._quadEdges.iterator();th.hasNext();){let tu=th.next(),tc=tu.orig();ta.contains(tc)||(ta.add(tc),!t&&this.isFrameVertex(tc)||tt.add(tu));let tg=tu.sym(),t_=tg.orig();ta.contains(t_)||(ta.add(t_),!t&&this.isFrameVertex(t_)||tt.add(tg))}return tt}getTriangleEdges(t){let tt=new To;return this.visitTriangles(tt,t),tt.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;let tt=new x,ta=new ln;ta.push(this._startingEdge);let th=new J;for(;!ta.empty();){let tu=ta.pop();if(!th.contains(tu)){let tc=tu.getPrimary();!t&&this.isFrameEdge(tc)||tt.add(tc),ta.push(tu.oNext()),ta.push(tu.sym().oNext()),th.add(tu),th.add(tu.sym())}}return tt}delete(t){xo.splice(t,t.oPrev()),xo.splice(t.sym(),t.sym().oPrev());let tt=t.sym(),ta=t.rot(),th=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(tt),this._quadEdges.remove(ta),this._quadEdges.remove(th),t.delete(),tt.delete(),ta.delete(),th.delete()}locateFromEdge(t,tt){let ta=0,th=this._quadEdges.size(),tu=tt;for(;;){if(++ta>th)throw new Co(tu.toLineSegment());if(t.equals(tu.orig())||t.equals(tu.dest()))break;if(t.rightOf(tu))tu=tu.sym();else if(t.rightOf(tu.oNext())){if(t.rightOf(tu.dPrev()))break;tu=tu.dPrev()}else tu=tu.oNext()}return tu}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new Lo,!0);let tt=new x;for(let ta=this.getVertexUniqueEdges(!1).iterator();ta.hasNext();){let th=ta.next();tt.add(this.getVoronoiCellPolygon(th,t))}return tt}getVoronoiDiagram(t){let tt=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Wt.toGeometryArray(tt))}getTriangles(t){let tt=this.getTriangleCoordinates(!1),ta=Array(tt.size()).fill(null),th=0;for(let tu=tt.iterator();tu.hasNext();){let tt=tu.next();ta[th++]=t.createPolygon(t.createLinearRing(tt))}return t.createGeometryCollection(ta)}insertSite(t){let tt=this.locate(t);if(t.equals(tt.orig(),this._tolerance)||t.equals(tt.dest(),this._tolerance))return tt;let ta=this.makeEdge(tt.orig(),t);xo.splice(ta,tt);let th=ta;do tt=(ta=this.connect(tt,ta.sym())).oPrev();while(tt.lNext()!==th);return th}locate(){if(1==arguments.length){if(arguments[0]instanceof mo){let t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof g){let t=arguments[0];return this._locator.locate(new mo(t))}}else if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=this._locator.locate(new mo(t));if(null===ta)return null;let th=ta;ta.dest().getCoordinate().equals2D(t)&&(th=ta.sym());let tu=th;do{if(tu.dest().getCoordinate().equals2D(tt))return tu;tu=tu.oNext()}while(tu!==th);return null}}getClass(){return wo}get interfaces_(){return[]}};let Lo=class Lo{constructor(){Lo.constructor_.apply(this,arguments)}visit(t){let tt=t[0].orig().getCoordinate(),ta=t[1].orig().getCoordinate(),th=t[2].orig().getCoordinate(),tu=oe.circumcentre(tt,ta,th),tc=new mo(tu);for(let tt=0;tt<3;tt++)t[tt].rot().setOrig(tc)}getClass(){return Lo}get interfaces_(){return[So]}};Lo.constructor_=function(){};let To=class To{constructor(){To.constructor_.apply(this,arguments)}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}getClass(){return To}get interfaces_(){return[So]}};To.constructor_=function(){this._triList=new x};let Ro=class Ro{constructor(){Ro.constructor_.apply(this,arguments)}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}getClass(){return Ro}get interfaces_(){return[So]}};Ro.constructor_=function(){this._triList=new x};let Po=class Po{constructor(){Po.constructor_.apply(this,arguments)}checkTriangleSize(t){t.length>=2?$t.toLineString(t[0],t[1]):t.length>=1&&$t.toPoint(t[0])}visit(t){this._coordList.clear();for(let tt=0;tt<3;tt++){let ta=t[tt].orig();this._coordList.add(ta.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();let t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}getClass(){return Po}get interfaces_(){return[So]}};Po.constructor_=function(){this._coordList=new I,this._triCoords=new x},wo.TriangleCircumcentreVisitor=Lo,wo.TriangleEdgesListVisitor=To,wo.TriangleVertexListVisitor=Ro,wo.TriangleCoordinatesVisitor=Po,wo.constructor_=function(){this._visitedKey=0,this._quadEdges=new x,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=[,,,].fill(null),this._frameEnv=null,this._locator=null,this._seg=new ne,this._triEdges=[,,,].fill(null);let t=arguments[0],tt=arguments[1];this._tolerance=tt,this._edgeCoincidenceTolerance=tt/wo.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new No(this)},wo.EDGE_COINCIDENCE_TOL_FACTOR=1e3;let vo=class vo{constructor(){vo.constructor_.apply(this,arguments)}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).z}getStartZ(){return this._ls.getCoordinate(0).z}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}getClass(){return vo}get interfaces_(){return[]}};vo.constructor_=function(){if(this._ls=null,this._data=null,2==arguments.length){let t=arguments[0],tt=arguments[1];this._ls=new ne(t,tt)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._ls=new ne(t,tt),this._data=ta}else if(6==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5];vo.constructor_.call(this,new g(t,tt,ta),new g(th,tu,tc))}else if(7==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3],tu=arguments[4],tc=arguments[5],tg=arguments[6];vo.constructor_.call(this,new g(t,tt,ta),new g(th,tu,tc),tg)}};let Oo=class Oo{constructor(){Oo.constructor_.apply(this,arguments)}static computeVertexEnvelope(t){let tt=new N;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt.expandToInclude(t.getCoordinate())}return tt}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,tt=0;do tt=this.enforceGabriel(this._segments),t++;while(tt>0&&t<Oo.MAX_SPLIT_ITER)}insertSites(t){for(let tt=t.iterator();tt.hasNext();){let t=tt.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){let t=Array(this._initialVertices.size()+this._segVertices.size()).fill(null),tt=0;for(let ta=this._initialVertices.iterator();ta.hasNext();){let th=ta.next();t[tt++]=th.getCoordinate()}for(let ta=this._segVertices.iterator();ta.hasNext();){let th=ta.next();t[tt++]=th.getCoordinate()}return t}setConstraints(t,tt){this._segments=t,this._segVertices=tt}computeConvexHull(){let t=new Wt,tt=this.getPointArray(),ta=new cn(tt,t);this._convexHull=ta.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){let tt=t.getStart(),ta=t.getEnd(),th=new g((tt.x+ta.x)/2,(tt.y+ta.y)/2),tu=tt.distance(th),tc=new N(th);tc.expandBy(tu);let tg=this._kdt.query(tc),t_=null,td=i.MAX_VALUE;for(let t=tg.iterator();t.hasNext();){let tc=t.next().getCoordinate();if(tc.equals2D(tt)||tc.equals2D(ta))continue;let tg=th.distance(tc);tg<tu&&(null===t_||tg<td)&&(t_=tc,td=tg)}return t_}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){let tt=new x,ta=0,th=new x;for(let tu=t.iterator();tu.hasNext();){let t=tu.next(),tc=this.findNonGabrielPoint(t);if(null===tc)continue;this._splitPt=this._splitFinder.findSplitPoint(t,tc);let tg=this.createVertex(this._splitPt,t);this.insertSite(tg).getCoordinate().equals2D(this._splitPt);let t_=new vo(t.getStartX(),t.getStartY(),t.getStartZ(),tg.getX(),tg.getY(),tg.getZ(),t.getData()),td=new vo(tg.getX(),tg.getY(),tg.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());tt.add(t_),tt.add(td),th.add(t),ta+=1}return t.removeAll(th),t.addAll(tt),ta}createVertex(){if(1==arguments.length){let t=arguments[0];return null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new yo(t)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=null;return(ta=null!==this._vertexFactory?this._vertexFactory.createVertex(t,tt):new yo(t)).setOnConstraint(!0),ta}}getSubdivision(){return this._subdiv}computeBoundingBox(){let t=Oo.computeVertexEnvelope(this._initialVertices),tt=Oo.computeVertexEnvelope(this._segVertices),ta=new N(t);ta.expandToInclude(tt);let th=.2*ta.getWidth(),tu=.2*ta.getHeight(),tc=Math.max(th,tu);this._computeAreaEnv=new N(ta),this._computeAreaEnv.expandBy(tc)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new wo(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new No(this._subdiv)),this._incDel=new Eo(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof yo){let t=arguments[0],tt=this._kdt.insert(t.getCoordinate(),t);if(tt.isRepeated()){let ta=tt.getData();return ta.merge(t),ta}return this._incDel.insertSite(t),t}if(arguments[0]instanceof g){let t=arguments[0];this.insertSite(this.createVertex(t))}}getClass(){return Oo}get interfaces_(){return[]}};Oo.constructor_=function(){this._initialVertices=null,this._segVertices=null,this._segments=new x,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new fo,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;let t=arguments[0],tt=arguments[1];this._initialVertices=new x(t),this._tolerance=tt,this._kdt=new ns(tt)},Oo.MAX_SPLIT_ITER=99;let bo=class bo{constructor(){bo.constructor_.apply(this,arguments)}static extractUniqueCoordinates(t){if(null===t)return new I;let tt=t.getCoordinates();return bo.unique(tt)}static envelope(t){let tt=new N;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt.expandToInclude(t)}return tt}static unique(t){let tt=X.copyDeep(t);return ut.sort(tt),new I(tt,!1)}static toVertices(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();tt.add(new mo(t))}return tt}create(){if(null!==this._subdiv)return null;let t=bo.envelope(this._siteCoords),tt=bo.toVertices(this._siteCoords);this._subdiv=new wo(t,this._tolerance),new Eo(this._subdiv).insertSites(tt)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){let t=arguments[0];this._siteCoords=bo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){let t=arguments[0];this._siteCoords=bo.unique(X.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}getClass(){return bo}get interfaces_(){return[]}};bo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null};let Mo=class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static createConstraintSegments(){if(1==arguments.length){let t=arguments[0],tt=Ee.getLines(t),ta=new x;for(let t=tt.iterator();t.hasNext();){let tt=t.next();Mo.createConstraintSegments(tt,ta)}return ta}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t.getCoordinates();for(let t=1;t<ta.length;t++)tt.add(new vo(ta[t-1],ta[t]))}}createSiteVertices(t){let tt=new x;for(let ta=t.iterator();ta.hasNext();){let t=ta.next();this._constraintVertexMap.containsKey(t)||tt.add(new yo(t))}return tt}create(){if(null!==this._subdiv)return null;let t=bo.envelope(this._siteCoords),tt=new x;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),tt=Mo.createConstraintSegments(this._constraintLines));let ta=this.createSiteVertices(this._siteCoords),th=new Oo(ta,this._tolerance);th.setConstraints(tt,new x(this._constraintVertexMap.values())),th.formInitialDelaunay(),th.enforceConstraints(),this._subdiv=th.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=bo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){let tt=t.getCoordinates();for(let t=0;t<tt.length;t++){let ta=new yo(tt[t]);this._constraintVertexMap.put(tt[t],ta)}}getClass(){return Mo}get interfaces_(){return[]}};Mo.constructor_=function(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new ot};let Do=class Do{constructor(){Do.constructor_.apply(this,arguments)}static clipGeometryCollection(t,tt){let ta=t.getFactory().toGeometry(tt),th=new x;for(let tu=0;tu<t.getNumGeometries();tu++){let tc=t.getGeometryN(tu),tg=null;tt.contains(tc.getEnvelopeInternal())?tg=tc:tt.intersects(tc.getEnvelopeInternal())&&(tg=ta.intersection(tc)).setUserData(tc.getUserData()),null===tg||tg.isEmpty()||th.add(tg)}return t.getFactory().createGeometryCollection(Wt.toGeometryArray(th))}create(){if(null!==this._subdiv)return null;let t=bo.envelope(this._siteCoords);this._diagramEnv=t;let tt=Math.max(this._diagramEnv.getWidth(),this._diagramEnv.getHeight());this._diagramEnv.expandBy(tt),null!==this._clipEnv&&this._diagramEnv.expandToInclude(this._clipEnv);let ta=bo.toVertices(this._siteCoords);this._subdiv=new wo(t,this._tolerance),new Eo(this._subdiv).insertSites(ta)}getDiagram(t){this.create();let tt=this._subdiv.getVoronoiDiagram(t);return Do.clipGeometryCollection(tt,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){let t=arguments[0];this._siteCoords=bo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){let t=arguments[0];this._siteCoords=bo.unique(X.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}getClass(){return Do}get interfaces_(){return[]}};Do.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null};var tG=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:Mo,DelaunayTriangulationBuilder:bo,VoronoiDiagramBuilder:Do,quadedge:Object.freeze({__proto__:null,Vertex:mo})});let Go=class Go{constructor(){Go.constructor_.apply(this,arguments)}static getEndLocation(t){let tt=new Go;return tt.setToEnd(t),tt}static pointAlongSegmentByFraction(t,tt,ta){if(ta<=0)return t;if(ta>=1)return tt;let th=(tt.x-t.x)*ta+t.x,tu=(tt.y-t.y)*ta+t.y,tc=(tt.z-t.z)*ta+t.z;return new g(th,tu,tc)}static compareLocationValues(t,tt,ta,th,tu,tc){return t<th?-1:t>th?1:tt<tu?-1:tt>tu?1:ta<tc?-1:ta>tc?1:0}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){let tt=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex>=tt||this._segmentIndex===tt&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;let tt=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>tt.getNumPoints())&&(this._segmentIndex!==tt.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1)}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){let tt=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex<tt?this:new Go(this._componentIndex,tt,1,!1)}getCoordinate(t){let tt=t.getGeometryN(this._componentIndex),ta=tt.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=tt.getNumPoints()-1)return ta;let th=tt.getCoordinateN(this._segmentIndex+1);return Go.pointAlongSegmentByFraction(ta,th,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){let tt=t.getGeometryN(this._componentIndex),ta=tt.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=tt.getNumPoints()-1){let t=tt.getCoordinateN(tt.getNumPoints()-2);return new ne(t,ta)}let th=tt.getCoordinateN(this._segmentIndex+1);return new ne(ta,th)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){let tt=t.getGeometryN(this._componentIndex);this._segmentIndex=tt.getNumPoints()-1,this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;let tt=t.getGeometryN(this._componentIndex);this._segmentIndex=tt.getNumPoints()-1,this._segmentFraction=1}compareTo(t){return this._componentIndex<t._componentIndex?-1:this._componentIndex>t._componentIndex?1:this._segmentIndex<t._segmentIndex?-1:this._segmentIndex>t._segmentIndex?1:this._segmentFraction<t._segmentFraction?-1:this._segmentFraction>t._segmentFraction?1:0}copy(){return new Go(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction)}snapToVertex(t,tt){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;let ta=this.getSegmentLength(t),th=this._segmentFraction*ta,tu=ta-th;th<=tu&&th<tt?this._segmentFraction=0:tu<=th&&tu<tt&&(this._segmentFraction=1)}compareLocationValues(t,tt,ta){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<tt?-1:this._segmentIndex>tt?1:this._segmentFraction<ta?-1:this._segmentFraction>ta?1:0}getSegmentLength(t){let tt=t.getGeometryN(this._componentIndex),ta=this._segmentIndex;this._segmentIndex>=tt.getNumPoints()-1&&(ta=tt.getNumPoints()-2);let th=tt.getCoordinateN(ta),tu=tt.getCoordinateN(ta+1);return th.distance(tu)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}getClass(){return Go}get interfaces_(){return[r]}};Go.constructor_=function(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];Go.constructor_.call(this,0,t,tt)}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];this._componentIndex=t,this._segmentIndex=tt,this._segmentFraction=ta,this.normalize()}else if(4==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2],th=arguments[3];this._componentIndex=t,this._segmentIndex=tt,this._segmentFraction=ta,th&&this.normalize()}};let qo=class qo{constructor(){qo.constructor_.apply(this,arguments)}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}getClass(){return qo}get interfaces_(){return[]}};qo.constructor_=function(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1==arguments.length){let t=arguments[0];qo.constructor_.call(this,t,0,0)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];qo.constructor_.call(this,t,tt.getComponentIndex(),qo.segmentEndVertexIndex(tt))}else if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];if(!_(t,lt))throw new n("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=tt,this._vertexIndex=ta,this.loadCurrentLine()}};let Bo=class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static indexOf(t,tt){return new Bo(t).indexOf(tt)}static indexOfAfter(t,tt,ta){return new Bo(t).indexOfAfter(tt,ta)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,tt){let ta=i.MAX_VALUE,th=0,tu=0,tc=-1,tg=new ne;for(let t_=new qo(this._linearGeom);t_.hasNext();t_.next())if(!t_.isEndOfLine()){tg.p0=t_.getSegmentStart(),tg.p1=t_.getSegmentEnd();let td=tg.distance(t),tp=tg.segmentFraction(t),tf=t_.getComponentIndex(),tm=t_.getVertexIndex();td<ta&&(null===tt||0>tt.compareLocationValues(tf,tm,tp))&&(th=tf,tu=tm,tc=tp,ta=td)}return ta===i.MAX_VALUE?new Go(tt):new Go(th,tu,tc)}indexOfAfter(t,tt){if(null===tt)return this.indexOf(t);let ta=Go.getEndLocation(this._linearGeom);if(0>=ta.compareTo(tt))return ta;let th=this.indexOfFromStart(t,tt);return u.isTrue(th.compareTo(tt)>=0,"computed location is before specified minimum location"),th}getClass(){return Bo}get interfaces_(){return[]}};Bo.constructor_=function(){this._linearGeom=null;let t=arguments[0];this._linearGeom=t};let Vo=class Vo{constructor(){Vo.constructor_.apply(this,arguments)}static indicesOf(t,tt){return new Vo(t).indicesOf(tt)}indicesOf(t){let tt=t.getGeometryN(0).getCoordinateN(0),ta=t.getGeometryN(t.getNumGeometries()-1),th=ta.getCoordinateN(ta.getNumPoints()-1),tu=new Bo(this._linearGeom),tc=[,,].fill(null);return tc[0]=tu.indexOf(tt),0===t.getLength()?tc[1]=tc[0].copy():tc[1]=tu.indexOfAfter(th,tc[0]),tc}getClass(){return Vo}get interfaces_(){return[]}};Vo.constructor_=function(){this._linearGeom=null;let t=arguments[0];this._linearGeom=t};let zo=class zo{constructor(){zo.constructor_.apply(this,arguments)}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&2>this._coordList.size())return this._coordList=null,null;let t=this._coordList.toCoordinateArray(),tt=t;this._fixInvalidLines&&(tt=this.validCoordinateSequence(t)),this._coordList=null;let ta=null;try{ta=this._geomFact.createLineString(tt)}catch(t){if(!(t instanceof n)||!this._ignoreInvalidLines)throw t}null!==ta&&this._lines.add(ta)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1==arguments.length){let t=arguments[0];this.add(t,!0)}else if(2==arguments.length){let t=arguments[0],tt=arguments[1];null===this._coordList&&(this._coordList=new I),this._coordList.add(t,tt),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){return t.length>=2?t:[t[0],t[0]]}getClass(){return zo}get interfaces_(){return[]}};zo.constructor_=function(){this._geomFact=null,this._lines=new x,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;let t=arguments[0];this._geomFact=t};let Yo=class Yo{constructor(){Yo.constructor_.apply(this,arguments)}static extract(t,tt,ta){return new Yo(t).extract(tt,ta)}computeLinear(t,tt){let ta=new zo(this._line.getFactory());ta.setFixInvalidLines(!0),t.isVertex()||ta.add(t.getCoordinate(this._line));for(let th=new qo(this._line,t);th.hasNext()&&!(0>tt.compareLocationValues(th.getComponentIndex(),th.getVertexIndex(),0));th.next()){let t=th.getSegmentStart();ta.add(t),th.isEndOfLine()&&ta.endLine()}return tt.isVertex()||ta.add(tt.getCoordinate(this._line)),ta.getGeometry()}computeLine(t,tt){let ta=this._line.getCoordinates(),th=new I,tu=t.getSegmentIndex();t.getSegmentFraction()>0&&(tu+=1);let tc=tt.getSegmentIndex();1===tt.getSegmentFraction()&&(tc+=1),tc>=ta.length&&(tc=ta.length-1),t.isVertex()||th.add(t.getCoordinate(this._line));for(let t=tu;t<=tc;t++)th.add(ta[t]);tt.isVertex()||th.add(tt.getCoordinate(this._line)),0>=th.size()&&th.add(t.getCoordinate(this._line));let tg=th.toCoordinateArray();return tg.length<=1&&(tg=[tg[0],tg[0]]),this._line.getFactory().createLineString(tg)}extract(t,tt){return 0>tt.compareTo(t)?this.reverse(this.computeLinear(tt,t)):this.computeLinear(t,tt)}reverse(t){return t instanceof Rt?t.reverse():t instanceof pt?t.reverse():(u.shouldNeverReachHere("non-linear geometry encountered"),null)}getClass(){return Yo}get interfaces_(){return[]}};Yo.constructor_=function(){this._line=null;let t=arguments[0];this._line=t};let Uo=class Uo{constructor(){Uo.constructor_.apply(this,arguments)}clampIndex(t){let tt=t.copy();return tt.clamp(this._linearGeom),tt}project(t){return Bo.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof Rt||this._linearGeom instanceof pt))throw new n("Input geometry must be linear")}extractPoint(){if(1==arguments.length)return arguments[0].getCoordinate(this._linearGeom);if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t.toLowest(this._linearGeom);return ta.getSegment(this._linearGeom).pointAlongOffset(ta.getSegmentFraction(),tt)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return Go.getEndLocation(this._linearGeom)}getStartIndex(){return new Go}indexOfAfter(t,tt){return Bo.indexOfAfter(this._linearGeom,t,tt)}extractLine(t,tt){return Yo.extract(this._linearGeom,t,tt)}indexOf(t){return Bo.indexOf(this._linearGeom,t)}indicesOf(t){return Vo.indicesOf(this._linearGeom,t)}getClass(){return Uo}get interfaces_(){return[]}};Uo.constructor_=function(){this._linearGeom=null;let t=arguments[0];this._linearGeom=t,this.checkGeometryType()};let ko=class ko{constructor(){ko.constructor_.apply(this,arguments)}static indexOf(t,tt){return new ko(t).indexOf(tt)}static indexOfAfter(t,tt,ta){return new ko(t).indexOfAfter(tt,ta)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,tt){let ta=i.MAX_VALUE,th=tt,tu=0,tc=new ne,tg=new qo(this._linearGeom);for(;tg.hasNext();){if(!tg.isEndOfLine()){tc.p0=tg.getSegmentStart(),tc.p1=tg.getSegmentEnd();let t_=tc.distance(t),td=this.segmentNearestMeasure(tc,t,tu);t_<ta&&td>tt&&(th=td,ta=t_),tu+=tc.getLength()}tg.next()}return th}indexOfAfter(t,tt){if(tt<0)return this.indexOf(t);let ta=this._linearGeom.getLength();if(ta<tt)return ta;let th=this.indexOfFromStart(t,tt);return u.isTrue(th>=tt,"computed index is before specified minimum index"),th}segmentNearestMeasure(t,tt,ta){let th=t.projectionFactor(tt);return th<=0?ta:th<=1?ta+th*t.getLength():ta+t.getLength()}getClass(){return ko}get interfaces_(){return[]}};ko.constructor_=function(){this._linearGeom=null;let t=arguments[0];this._linearGeom=t};let Xo=class Xo{constructor(){Xo.constructor_.apply(this,arguments)}static getLength(t,tt){return new Xo(t).getLength(tt)}static getLocation(){if(2==arguments.length){let t=arguments[0],tt=arguments[1];return new Xo(t).getLocation(tt)}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return new Xo(t).getLocation(tt,ta)}}getLength(t){let tt=0,ta=new qo(this._linearGeom);for(;ta.hasNext();){if(!ta.isEndOfLine()){let th=ta.getSegmentStart(),tu=ta.getSegmentEnd().distance(th);if(t.getComponentIndex()===ta.getComponentIndex()&&t.getSegmentIndex()===ta.getVertexIndex())return tt+tu*t.getSegmentFraction();tt+=tu}ta.next()}return tt}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let tt=t.getComponentIndex();if(tt>=this._linearGeom.getNumGeometries()-1)return t;do tt++;while(tt<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(tt).getLength());return new Go(tt,0,0)}getLocation(){if(1==arguments.length){let t=arguments[0];return this.getLocation(t,!0)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=t;t<0&&(ta=this._linearGeom.getLength()+t);let th=this.getLocationForward(ta);return tt?th:this.resolveHigher(th)}}getLocationForward(t){if(t<=0)return new Go;let tt=0,ta=new qo(this._linearGeom);for(;ta.hasNext();){if(ta.isEndOfLine()){if(tt===t){let t=ta.getComponentIndex(),tt=ta.getVertexIndex();return new Go(t,tt,0)}}else{let th=ta.getSegmentStart(),tu=ta.getSegmentEnd().distance(th);if(tt+tu>t){let th=(t-tt)/tu,tc=ta.getComponentIndex(),tg=ta.getVertexIndex();return new Go(tc,tg,th)}tt+=tu}ta.next()}return Go.getEndLocation(this._linearGeom)}getClass(){return Xo}get interfaces_(){return[]}};Xo.constructor_=function(){this._linearGeom=null;let t=arguments[0];this._linearGeom=t};let Ho=class Ho{constructor(){Ho.constructor_.apply(this,arguments)}clampIndex(t){let tt=this.positiveIndex(t),ta=this.getStartIndex();if(tt<ta)return ta;let th=this.getEndIndex();return tt>th?th:tt}locationOf(){if(1==arguments.length){let t=arguments[0];return Xo.getLocation(this._linearGeom,t)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return Xo.getLocation(this._linearGeom,t,tt)}}project(t){return ko.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1==arguments.length){let t=arguments[0];return Xo.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2==arguments.length){let t=arguments[0],tt=arguments[1],ta=Xo.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return ta.getSegment(this._linearGeom).pointAlongOffset(ta.getSegmentFraction(),tt)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,tt){return ko.indexOfAfter(this._linearGeom,t,tt)}extractLine(t,tt){new Uo(this._linearGeom);let ta=this.clampIndex(t),th=this.clampIndex(tt),tu=ta===th,tc=this.locationOf(ta,tu),tg=this.locationOf(th);return Yo.extract(this._linearGeom,tc,tg)}indexOf(t){return ko.indexOf(this._linearGeom,t)}indicesOf(t){let tt=Vo.indicesOf(this._linearGeom,t);return[Xo.getLength(this._linearGeom,tt[0]),Xo.getLength(this._linearGeom,tt[1])]}getClass(){return Ho}get interfaces_(){return[]}};Ho.constructor_=function(){this._linearGeom=null;let t=arguments[0];this._linearGeom=t};var tq=Object.freeze({__proto__:null,LengthIndexedLine:Ho,LengthLocationMap:Xo,LinearGeometryBuilder:zo,LinearIterator:qo,LinearLocation:Go,LocationIndexedLine:Uo});let jo=class jo{constructor(){jo.constructor_.apply(this,arguments)}static transform(t,tt){let ta=new x;for(let th=t.iterator();th.hasNext();)ta.add(tt.execute(th.next()));return ta}static select(t,tt){let ta=new x;for(let th=t.iterator();th.hasNext();){let t=th.next();Boolean.TRUE.equals(tt.execute(t))&&ta.add(t)}return ta}static apply(t,tt){for(let ta=t.iterator();ta.hasNext();)tt.execute(ta.next())}getClass(){return jo}get interfaces_(){return[]}};jo.Function=function(){},jo.constructor_=function(){};let Ko=class Ko{constructor(){Ko.constructor_.apply(this,arguments)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}getClass(){return Ko}get interfaces_(){return[B]}};Ko.constructor_=function(){this.pts=null,this.n=0;let t=arguments[0];this.pts=Array(t).fill(null)};let Zo=class Zo{constructor(){Zo.constructor_.apply(this,arguments)}filter(t){this._n++}getCount(){return this._n}getClass(){return Zo}get interfaces_(){return[B]}};Zo.constructor_=function(){this._n=0};let Qo=class Qo{constructor(){Qo.constructor_.apply(this,arguments)}count(t){let tt=this._counts.get(t);return null===tt?0:tt.count()}add(t){let tt=this._counts.get(t);null===tt?this._counts.put(t,new Jo(1)):tt.increment()}getClass(){return Qo}get interfaces_(){return[]}};let Jo=class Jo{constructor(){Jo.constructor_.apply(this,arguments)}count(){return this.count}increment(){this.count++}getClass(){return Jo}get interfaces_(){return[]}};Jo.constructor_=function(){if(this.count=0,0==arguments.length);else if(1==arguments.length){let t=arguments[0];this.count=t}},Qo.Counter=Jo,Qo.constructor_=function(){this._counts=new kt};var tV=Object.freeze({__proto__:null,CollectionUtil:jo,CoordinateArrayFilter:Ko,CoordinateCountFilter:Zo,GeometricShapeFactory:we,NumberUtil:e,ObjectCounter:Qo,PriorityQueue:ps,StringUtil:wt,UniqueCoordinateArrayFilter:an});let tl=class tl{get interfaces_(){return[]}getClass(){return tl}static union(t,tt){if(t.isEmpty()||tt.isEmpty()){if(t.isEmpty()&&tt.isEmpty())return hr.createEmptyResult(hr.UNION,t,tt,t.getFactory());if(t.isEmpty())return tt.copy();if(tt.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(tt),ar.overlayOp(t,tt,hr.UNION)}};q.prototype.equalsTopo=function(t){return!!this.getEnvelopeInternal().equals(t.getEnvelopeInternal())&&qr.relate(this,t).isEquals(this.getDimension(),t.getDimension())},q.prototype.union=function(){if(0==arguments.length)return Yr.union(this);if(1==arguments.length){let t=arguments[0];return tl.union(this,t)}},q.prototype.isValid=function(){return Sr.isValid(this)},q.prototype.intersection=function(t){return hr.intersection(this,t)},q.prototype.covers=function(t){return qr.covers(this,t)},q.prototype.coveredBy=function(t){return qr.covers(t,this)},q.prototype.touches=function(t){return qr.touches(this,t)},q.prototype.intersects=function(t){return qr.intersects(this,t)},q.prototype.within=function(t){return qr.contains(t,this)},q.prototype.overlaps=function(t){return qr.overlaps(this,t)},q.prototype.disjoint=function(t){return qr.disjoint(this,t)},q.prototype.crosses=function(t){return qr.crosses(this,t)},q.prototype.buffer=function(){if(1==arguments.length){let t=arguments[0];return wi.bufferOp(this,t)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return wi.bufferOp(this,t,tt)}if(3==arguments.length){let t=arguments[0],tt=arguments[1],ta=arguments[2];return wi.bufferOp(this,t,tt,ta)}},q.prototype.convexHull=function(){return new cn(this).getConvexHull()},q.prototype.relate=function(){for(var t=arguments.length,tt=Array(t),ta=0;ta<t;ta++)tt[ta]=arguments[ta];if(1==arguments.length){let t=arguments[0];return qr.relate(this,t)}if(2==arguments.length){let t=arguments[0],tt=arguments[1];return qr.relate(this,t).matches(tt)}},q.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();let t=rn.getCentroid(this);return this.createPointFromInternalCoord(t,this)},q.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=this.getDimension(),tt=(0===t?new _n(this):1===t?new dn(this):new un(this)).getInteriorPoint();return this.createPointFromInternalCoord(tt,this)},q.prototype.symDifference=function(t){return hr.symDifference(this,t)},q.prototype.createPointFromInternalCoord=function(t,tt){return tt.getPrecisionModel().makePrecise(t),tt.getFactory().createPoint(t)},q.prototype.toText=function(){return(new $t).write(this)},q.prototype.toString=function(){this.toText()},q.prototype.contains=function(t){return qr.contains(this,t)},q.prototype.difference=function(t){return hr.difference(this,t)},q.prototype.isSimple=function(){return new Ws(this).isSimple()},q.prototype.isWithinDistance=function(t,tt){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>tt)&&Pi.isWithinDistance(this,t,tt)},q.prototype.distance=function(t){return Pi.distance(this,t)},q.prototype.isEquivalentClass=function(t){return this.getClass()===t.getClass()},t.algorithm=tp,t.densify=tf,t.dissolve=tm,t.geom=tc,t.geomgraph=ty,t.index=tI,t.io=tL,t.linearref=tq,t.noding=tR,t.operation=tD,t.precision=tA,t.simplify=tF,t.triangulate=tG,t.util=tV,t.version="2.1.0 (4e987e1)",Object.defineProperty(t,"__esModule",{value:!0})}(tt)}}]);